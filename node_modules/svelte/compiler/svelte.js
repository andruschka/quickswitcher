(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.svelte = global.svelte || {})));
}(this, (function (exports) { 'use strict';

function getLocator ( source, options ) {
	if ( options === void 0 ) options = {};

	var offsetLine = options.offsetLine || 0;
	var offsetColumn = options.offsetColumn || 0;

	var originalLines = source.split( '\n' );

	var start = 0;
	var lineRanges = originalLines.map( function ( line, i ) {
		var end = start + line.length + 1;
		var range = { start: start, end: end, line: i };

		start = end;
		return range;
	});

	var i = 0;

	function rangeContains ( range, index ) {
		return range.start <= index && index < range.end;
	}

	function getLocation ( range, index ) {
		return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
	}

	return function locate ( search, startIndex ) {
		if ( typeof search === 'string' ) {
			search = source.indexOf( search, startIndex || 0 );
		}

		var range = lineRanges[i];

		var d = search >= range.end ? 1 : -1;

		while ( range ) {
			if ( rangeContains( range, search ) ) return getLocation( range, search );

			i += d;
			range = lineRanges[i];
		}
	};
}

function locate ( source, search, options ) {
	if ( typeof options === 'number' ) {
		throw new Error( 'locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument' );
	}

	return getLocator( source, options )( search, options && options.startIndex );
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false
    pos += set[i + 1];
    if (pos >= code) return true
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36
  if (code < 91) return true
  if (code < 97) return code === 95
  if (code < 123) return true
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))
  if (astral === false) return false
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36
  if (code < 58) return true
  if (code < 65) return false
  if (code < 91) return true
  if (code < 97) return code === 95
  if (code < 123) return true
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
  if (astral === false) return false
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};
// Map keyword names to token types.

var keywordTypes = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywordTypes[name] = new TokenType(name, options)
}

var tt = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("prefix", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class"),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]"
}

// Checks if an object has a property.

function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName)
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];

  if (options.ecmaVersion >= 2015)
    options.ecmaVersion -= 2009;

  if (options.allowReserved == null)
    options.allowReserved = options.ecmaVersion < 5;

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    options.onComment = pushComment(options, options.onComment);

  return options
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? 'Block' : 'Line',
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    if (options.ranges)
      comment.range = [start, end];
    array.push(comment);
  }
}

// Registered plugins
var plugins = {};

function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$")
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      if (reserved = reservedWords[v]) break
    if (options.sourceType == "module") reserved += " await";
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Load plugins
  this.loadPlugins(options.plugins);

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = tt.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false;
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')
    this.skipLineComment(2);
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };

Parser.prototype.extend = function extend (name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];
    if (!plugin) throw new Error("Plugin '" + name + "' not found")
    plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:[^\']|\.)*)'|"((?:[^\"]|\.)*)"|;)/;
pp.strictDirective = function(start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));
    if (!match) return false
    if ((match[1] || match[2]) == "use strict") return true
    start += match[0].length;
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === tt.name && this.value === name
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  return this.value === name && this.eat(tt.name)
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) this.unexpected();
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === tt.eof ||
    this.type === tt.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma)
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    if (!notNext)
      this.next();
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1;
};

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) return
  if (refDestructuringErrors.trailingComma > -1)
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) this.raiseRecoverable(parens, "Parenthesized pattern");
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;
  if (!andThrow) return pos >= 0
  if (pos > -1) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  if (this.awaitPos)
    this.raise(this.awaitPos, "Await expression cannot be a default value");
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    return this.isSimpleAssignTarget(expr.expression)
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) node.body = [];
  while (this.type !== tt.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"};
var switchLabel = {kind: "switch"};
pp$1.isLet = function() {
  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != "let") return false
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) return true // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
    for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) return true
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != "async")
    return false

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet()) {
    starttype = tt._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case tt._debugger: return this.parseDebuggerStatement(node)
  case tt._do: return this.parseDoStatement(node)
  case tt._for: return this.parseForStatement(node)
  case tt._function:
    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
    return this.parseFunctionStatement(node, false)
  case tt._class:
    if (!declaration) this.unexpected();
    return this.parseClass(node, true)
  case tt._if: return this.parseIfStatement(node)
  case tt._return: return this.parseReturnStatement(node)
  case tt._switch: return this.parseSwitchStatement(node)
  case tt._throw: return this.parseThrowStatement(node)
  case tt._try: return this.parseTryStatement(node)
  case tt._const: case tt._var:
    kind = kind || this.value;
    if (!declaration && kind != "var") this.unexpected();
    return this.parseVarStatement(node, kind)
  case tt._while: return this.parseWhileStatement(node)
  case tt._with: return this.parseWithStatement(node)
  case tt.braceL: return this.parseBlock()
  case tt.semi: return this.parseEmptyStatement(node)
  case tt._export:
  case tt._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        this.raise(this.start, "'import' and 'export' may only appear at the top level");
      if (!this.inModule)
        this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
    }
    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction() && declaration) {
      this.next();
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon))
      return this.parseLabeledStatement(node, maybeName, expr)
    else return this.parseExpressionStatement(node, expr)
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var this$1 = this;

  var isBreak = keyword == "break";
  this.next();
  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;
  else if (this.type !== tt.name) this.unexpected();
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break
      if (node.label && isBreak) break
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(tt._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    this.eat(tt.semi);
  else
    this.semicolon();
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(tt.parenL);
  if (this.type === tt.semi) return this.parseFor(node, null)
  var isLet = this.isLet();
  if (this.type === tt._var || this.type === tt._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
        !(kind !== "var" && init$1.declarations[0].init))
      return this.parseForIn(node, init$1)
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    this.toAssignable(init);
    this.checkLVal(init);
    this.checkPatternErrors(refDestructuringErrors, true);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync)
};

pp$1.isFunction = function() {
  return this.type === tt._function || this.isAsyncFunction()
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict && this.isFunction());
  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    this.raise(this.start, "'return' outside of function");
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(tt.braceL);
  this.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  for (var cur, sawDefault = false; this.type != tt.braceR;) {
    if (this$1.type === tt._case || this$1.type === tt._default) {
      var isCase = this$1.type === tt._case;
      if (cur) this$1.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();
      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this$1.expect(tt.colon);
    } else {
      if (!cur) this$1.unexpected();
      cur.consequent.push(this$1.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === tt._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(tt.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(tt.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr) {
  var this$1 = this;

  for (var i = 0; i < this.labels.length; ++i)
    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
  var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null;
  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {
    var label = this$1.labels[i$1];
    if (label.statementStart == node.start) {
      label.statementStart = this$1.start;
      label.kind = kind;
    } else break
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(true);
  if (node.body.type == "ClassDeclaration" ||
      node.body.type == "VariableDeclaration" && (this.strict || node.body.kind != "var") ||
      node.body.type == "FunctionDeclaration" && (this.strict || node.body.generator))
    this.raiseRecoverable(node.body.start, "Invalid labeled declaration");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function() {
  var this$1 = this;

  var node = this.startNode();
  node.body = [];
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(tt.semi);
  node.test = this.type === tt.semi ? null : this.parseExpression();
  this.expect(tt.semi);
  node.update = this.type === tt.parenR ? null : this.parseExpression();
  this.expect(tt.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(tt.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type)
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl);
    if (this$1.eat(tt.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
      this$1.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === tt._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
    if (!this$1.eat(tt.comma)) break
  }
  return node
};

pp$1.parseVarId = function(decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6 && !isAsync)
    node.generator = this.eat(tt.star);
  if (this.options.ecmaVersion >= 8)
    node.async = !!isAsync;

  if (isStatement == null)
    isStatement = this.type == tt.name;
  if (isStatement)
    node.id = this.parseIdent();

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  if (!isStatement && this.type === tt.name)
    node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(tt.parenL);
  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  var this$1 = this;

  this.next();
  if (isStatement == null) isStatement = this.type === tt.name;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    if (this$1.eat(tt.semi)) continue
    var method = this$1.startNode();
    var isGenerator = this$1.eat(tt.star);
    var isAsync = false;
    var isMaybeStatic = this$1.type === tt.name && this$1.value === "static";
    this$1.parsePropertyName(method);
    method.static = isMaybeStatic && this$1.type !== tt.parenL;
    if (method.static) {
      if (isGenerator) this$1.unexpected();
      isGenerator = this$1.eat(tt.star);
      this$1.parsePropertyName(method);
    }
    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&
        method.key.type === "Identifier" && method.key.name === "async" && this$1.type !== tt.parenL &&
        !this$1.canInsertSemicolon()) {
      isAsync = true;
      this$1.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;
      if (!isGenerator && !isAsync && key.type === "Identifier" && this$1.type !== tt.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this$1.parsePropertyName(method);
      }
      if (!method.static && (key.type === "Identifier" && key.name === "constructor" ||
          key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this$1.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this$1.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this$1.raise(key.start, "Constructor can't be a generator");
        if (isAsync) this$1.raise(key.start, "Constructor can't be an async method");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this$1.parseClassMethod(classBody, method, isGenerator, isAsync);
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get")
          this$1.raiseRecoverable(start, "getter should have no params");
        else
          this$1.raiseRecoverable(start, "setter should have exactly one param");
      } else {
        if (method.kind === "set" && method.value.params[0].type === "RestElement")
          this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function(node, isStatement) {
  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  var this$1 = this;

  this.next();
  // export * from '...'
  if (this.eat(tt.star)) {
    this.expectContextual("from");
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(tt._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) this.next();
      node.declaration = this.parseFunction(fNode, null, false, isAsync);
    } else if (this.type === tt._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, null);
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    if (node.declaration.type === "VariableDeclaration")
      this.checkVariableExport(exports, node.declaration.declarations);
    else
      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
    } else {
      // check for keywords used as local names
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
          this$1.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) return
  if (Object.prototype.hasOwnProperty.call(exports, name))
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type == "Identifier")
    this.checkExport(exports, pat.name, pat.start);
  else if (type == "ObjectPattern")
    for (var i = 0; i < pat.properties.length; ++i)
      this$1.checkPatternExport(exports, pat.properties[i].value);
  else if (type == "ArrayPattern")
    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {
      var elt = pat.elements[i$1];
      if (elt) this$1.checkPatternExport(exports, elt);
    }
  else if (type == "AssignmentPattern")
    this.checkPatternExport(exports, pat.left);
  else if (type == "ParenthesizedExpression")
    this.checkPatternExport(exports, pat.expression);
};

pp$1.checkVariableExport = function(exports, decls) {
  var this$1 = this;

  if (!exports) return
  for (var i = 0; i < decls.length; i++)
    this$1.checkPatternExport(exports, decls[i].id);
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var"
    || this.type.keyword === "const"
    || this.type.keyword === "class"
    || this.type.keyword === "function"
    || this.isLet()
    || this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var this$1 = this;

  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma);
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false;

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === tt.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var this$1 = this;

  var nodes = [], first = true;
  if (this.type === tt.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(tt.comma)) return nodes
  }
  if (this.type === tt.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, true);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(tt.braceL);
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma);
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false;

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);
    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      node$2.local = node$2.imported;
      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start);
      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, "The keyword '" + node$2.local.name + "' is reserved");
    }
    this$1.checkLVal(node$2.local, true);
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      if (this.inAsync && node.name === "await")
        this.raise(node.start, "Can not use 'await' as identifier inside an async function");
      break

    case "ObjectPattern":
    case "ArrayPattern":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      for (var i = 0; i < node.properties.length; i++) {
        var prop = node.properties[i];
        if (prop.kind !== "init") this$1.raise(prop.key.start, "Object pattern can't contain getter or setter");
        this$1.toAssignable(prop.value, isBinding);
      }
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      this.toAssignableList(node.elements, isBinding);
      break

    case "AssignmentExpression":
      if (node.operator === "=") {
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern
      } else {
        this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        break
      }

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      node.expression = this.toAssignable(node.expression, isBinding);
      break

    case "MemberExpression":
      if (!isBinding) break

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern")
        this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this$1.toAssignable(elt, isBinding);
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRest = function(allowNonIdent) {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected();
  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion < 6) return this.parseIdent()
  switch (this.type) {
  case tt.name:
    return this.parseIdent()

  case tt.bracketL:
    var node = this.startNode();
    this.next();
    node.elements = this.parseBindingList(tt.bracketR, true, true);
    return this.finishNode(node, "ArrayPattern")

  case tt.braceL:
    return this.parseObj(true)

  default:
    this.unexpected();
  }
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) first = false;
    else this$1.expect(tt.comma);
    if (allowEmpty && this$1.type === tt.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === tt.ellipsis) {
      var rest = this$1.parseRest(allowNonIdent);
      this$1.parseBindingListItem(rest);
      elts.push(rest);
      if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element");
      this$1.expect(close);
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.

pp$2.checkLVal = function(expr, isBinding, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        this.raiseRecoverable(expr.start, "Argument name clash");
      checkClashes[expr.name] = true;
    }
    break

  case "MemberExpression":
    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
    break

  case "ObjectPattern":
    for (var i = 0; i < expr.properties.length; i++)
      this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {
      var elem = expr.elements[i$1];
      if (elem) this$1.checkLVal(elem, isBinding, checkClashes);
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, isBinding, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, isBinding, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, isBinding, checkClashes);
    break

  default:
    this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    return
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
      this.raiseRecoverable(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === tt.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) return this.parseYield()

  var ownDestructuringErrors = false, oldParenAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    refDestructuringErrors.parenthesizedAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type == tt.parenL || this.type == tt.name)
    this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    this.checkPatternErrors(refDestructuringErrors, true);
    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === tt.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  if (this.eat(tt.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(tt.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== tt._in)) {
    if (prec > minPrec) {
      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.inAsync && this.isContextual("await")) {
    expr = this.parseAwait(refDestructuringErrors);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === tt.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    else sawUnary = true;
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(tt.starstar))
    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false)
  else
    return expr
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd == base.end && !this.canInsertSemicolon();
  for (var computed;;) {
    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;
      if (computed) this$1.expect(tt.bracketR);
      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(tt.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === tt.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate();
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base
    }
  }
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
  case tt._super:
    if (!this.inFunction)
      this.raise(this.start, "'super' outside of function or class");

  case tt._this:
    var type = this.type === tt._this ? "ThisExpression" : "Super";
    node = this.startNode();
    this.next();
    return this.finishNode(node, type)

  case tt.name:
    var startPos = this.start, startLoc = this.startLoc;
    var id = this.parseIdent(this.type !== tt.name);
    if (this.options.ecmaVersion >= 8 && id.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function))
      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(tt.arrow))
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === tt.name) {
        id = this.parseIdent();
        if (this.canInsertSemicolon() || !this.eat(tt.arrow))
          this.unexpected();
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case tt.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case tt.num: case tt.string:
    return this.parseLiteral(this.value)

  case tt._null: case tt._true: case tt._false:
    node = this.startNode();
    node.value = this.type === tt._null ? null : this.type === tt._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case tt.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        refDestructuringErrors.parenthesizedAssign = start;
      if (refDestructuringErrors.parenthesizedBind < 0)
        refDestructuringErrors.parenthesizedBind = start;
    }
    return expr

  case tt.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case tt.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case tt._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, false)

  case tt._class:
    return this.parseClass(this.startNode(), false)

  case tt._new:
    return this.parseNew()

  case tt.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected();
  }
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(tt.parenL);
  var val = this.parseExpression();
  this.expect(tt.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== tt.parenR) {
      first ? first = false : this$1.expect(tt.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this$1.type === tt.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRest()));
        if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element");
        break
      } else {
        if (this$1.type === tt.parenL && !innerParenStart) {
          innerParenStart = this$1.start;
        }
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(tt.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (innerParenStart) this.unexpected(innerParenStart);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction)
      this.raiseRecoverable(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false);
  else node.arguments = empty$1;
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function() {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === tt.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function() {
  var this$1 = this;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this$1.expect(tt.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(tt.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma);
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false;

    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this$1.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this$1.start;
        startLoc = this$1.startLoc;
      }
      if (!isPattern)
        isGenerator = this$1.eat(tt.star);
    }
    this$1.parsePropertyName(prop);
    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&
        prop.key.type === "Identifier" && prop.key.name === "async" && this$1.type !== tt.parenL &&
        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {
      isAsync = true;
      this$1.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);
    this$1.checkPropClash(prop, propHash);
    node.properties.push(this$1.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
  if ((isGenerator || isAsync) && this.type === tt.colon)
    this.unexpected();

  if (this.eat(tt.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type != tt.comma && this.type != tt.braceR)) {
    if (isGenerator || isAsync || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        this.raiseRecoverable(start, "getter should have no params");
      else
        this.raiseRecoverable(start, "setter should have exactly one param");
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (this.keywords.test(prop.key.name) ||
        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||
        (this.inGenerator && prop.key.name == "yield") ||
        (this.inAsync && prop.key.name == "await"))
      this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property");
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === tt.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(tt.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(tt.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
  if (this.options.ecmaVersion >= 8)
    node.async = false;
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    node.generator = isGenerator;
  if (this.options.ecmaVersion >= 8)
    node.async = !!isAsync;

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  this.expect(tt.parenL);
  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 8)
    node.async = !!isAsync;

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== tt.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) this.strict = true;
    node.body = this.parseBlock(true);
    node.expression = false;
    this.labels = oldLabels;
  }

  if (oldStrict || useStrict) {
    this.strict = true;
    if (node.id)
      this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {
    this.checkParams(node);
  }
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0; i < params.length; i++)
    if (params[i].type !== "Identifier") return false
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash);
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(tt.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(close)) break
    } else first = false;

    var elt;
    if (allowEmpty && this$1.type === tt.comma)
      elt = null;
    else if (this$1.type === tt.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)
        refDestructuringErrors.trailingComma = this$1.start;
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === tt.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&
        (this.options.ecmaVersion >= 6 ||
         this.input.slice(this.start, this.end).indexOf("\\") == -1))
      this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
    if (this.inGenerator && this.value === "yield")
      this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
    if (this.inAsync && this.value === "await")
      this.raiseRecoverable(this.start, "Can not use 'await' as identifier inside an async function");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier")
};

// Parses yield expression inside generator.

pp$3.parseYield = function() {
  if (!this.yieldPos) this.yieldPos = this.start;

  var node = this.startNode();
  this.next();
  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(tt.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) this.awaitPos = this.start;

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    this.loc = new SourceLocation(parser, loc);
  if (parser.options.directSourceFile)
    this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges)
    this.range = [pos, 0];
};

// Start an AST node, attaching a start offset.

var pp$5 = Parser.prototype;

pp$5.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$5.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    node.loc.end = loc;
  if (this.options.ranges)
    node.range[1] = pos;
  return node
}

pp$5.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$5.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.readTmplToken(); }),
  f_expr: new TokContext("function", true)
};

var pp$6 = Parser.prototype;

pp$6.initialContext = function() {
  return [types.b_stat]
};

pp$6.braceIsBlock = function(prevType) {
  if (prevType === tt.colon) {
    var parent = this.curContext();
    if (parent === types.b_stat || parent === types.b_expr)
      return !parent.isExpr
  }
  if (prevType === tt._return)
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)
    return true
  if (prevType == tt.braceL)
    return this.curContext() === types.b_stat
  return !this.exprAllowed
};

pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType == tt.dot)
    this.exprAllowed = false;
  else if (update = type.updateContext)
    update.call(this, prevType);
  else
    this.exprAllowed = type.beforeExpr;
};

// Token-specific context update code

tt.parenR.updateContext = tt.braceR.updateContext = function() {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

tt.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

tt.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

tt.parenL.updateContext = function(prevType) {
  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

tt.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

tt._function.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&
      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))
    this.context.push(types.f_expr);
  this.exprAllowed = false;
};

tt.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl)
    this.context.pop();
  else
    this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges)
    this.range = [p.start, p.end];
};

// ## Tokenizer

var pp$7 = Parser.prototype;

// Are we running under Rhino?
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

// Move to the next token

pp$7.next = function() {
  if (this.options.onToken)
    this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$7.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  pp$7[Symbol.iterator] = function () {
    var self = this;
    return {next: function () {
      var token = self.getToken();
      return {
        done: token.type === tt.eof,
        value: token
      }
    }}
  };

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$7.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$7.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(tt.eof)

  if (curContext.override) return curContext.override(this)
  else this.readToken(this.fullCharCodeAtPos());
};

pp$7.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    return this.readWord()

  return this.getTokenFromCode(code)
};

pp$7.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$7.skipBlockComment = function() {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition());
};

pp$7.skipLineComment = function(startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos+=startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this$1.pos;
    ch = this$1.input.charCodeAt(this$1.pos);
  }
  if (this.options.onComment)
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition());
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$7.skipSpace = function() {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);
    switch (ch) {
      case 32: case 160: // ' '
        ++this$1.pos;
        break
      case 13:
        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
          ++this$1.pos;
        }
      case 10: case 8232: case 8233:
        ++this$1.pos;
        if (this$1.options.locations) {
          ++this$1.curLine;
          this$1.lineStart = this$1.pos;
        }
        break
      case 47: // '/'
        switch (this$1.input.charCodeAt(this$1.pos + 1)) {
          case 42: // '*'
            this$1.skipBlockComment();
            break
          case 47:
            this$1.skipLineComment(2);
            break
          default:
            break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this$1.pos;
        } else {
          break loop
        }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$7.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$7.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true)
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(tt.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(tt.dot)
  }
};

pp$7.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {++this.pos; return this.readRegexp()}
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.slash, 1)
};

pp$7.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? tt.star : tt.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && next === 42) {
    ++size;
    tokentype = tt.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) return this.finishOp(tt.assign, size + 1)
  return this.finishOp(tokentype, size)
};

pp$7.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
};

pp$7.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.bitwiseXOR, 1)
};

pp$7.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&
        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(tt.incDec, 2)
  }
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.plusMin, 1)
};

pp$7.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
    return this.finishOp(tt.bitShift, size)
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&
      this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) size = 2;
  return this.finishOp(tt.relational, size)
};

pp$7.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(tt.arrow)
  }
  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
};

pp$7.getTokenFromCode = function(code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

    // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(tt.parenL)
  case 41: ++this.pos; return this.finishToken(tt.parenR)
  case 59: ++this.pos; return this.finishToken(tt.semi)
  case 44: ++this.pos; return this.finishToken(tt.comma)
  case 91: ++this.pos; return this.finishToken(tt.bracketL)
  case 93: ++this.pos; return this.finishToken(tt.bracketR)
  case 123: ++this.pos; return this.finishToken(tt.braceL)
  case 125: ++this.pos; return this.finishToken(tt.braceR)
  case 58: ++this.pos; return this.finishToken(tt.colon)
  case 63: ++this.pos; return this.finishToken(tt.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) break
    ++this.pos;
    return this.finishToken(tt.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number
      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

    // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(tt.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$7.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags)
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e
    }
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp("\uffff", "u");

pp$7.readRegexp = function() {
  var this$1 = this;

  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) this$1.raise(start, "Unterminated regular expression");
    var ch = this$1.input.charAt(this$1.pos);
    if (lineBreak.test(ch)) this$1.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;
      else if (ch === "]" && inClass) inClass = false;
      else if (ch === "/" && !inClass) break
      escaped = ch === "\\";
    } else escaped = false;
    ++this$1.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  // Need to use `readWord1` because '\uXXXX' sequences are allowed
  // here (don't ask).
  var mods = this.readWord1();
  var tmp = content, tmpFlags = "";
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0) {
      if (regexpUnicodeSupport) {
        tmpFlags = "u";
      } else {
        // Replace each astral symbol and every Unicode escape sequence that
        // possibly represents an astral symbol or a paired surrogate with a
        // single ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        // Note: replacing with the ASCII symbol `x` might cause false
        // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
        // perfectly valid pattern that is equivalent to `[a-b]`, but it would
        // be replaced by `[x-b]` which throws an error.
        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
          code = Number("0x" + code);
          if (code > 0x10FFFF) this$1.raise(start + offset + 3, "Code point out of bounds");
          return "x"
        });
        tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
        tmpFlags = tmpFlags.replace("u", "");
      }
    }
  }
  // Detect invalid regular expressions.
  var value = null;
  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
  // so don't do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, tmpFlags, start, this);
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$7.readInt = function(radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val;
    if (code >= 97) val = code - 97 + 10; // a
    else if (code >= 65) val = code - 65 + 10; // A
    else if (code >= 48 && code <= 57) val = code - 48; // 0-9
    else val = Infinity;
    if (val >= radix) break
    ++this$1.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null

  return total
};

pp$7.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(tt.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$7.readNumber = function(startsWithDot) {
  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  if (octal && this.pos == start + 1) octal = false;
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos), val;
  if (isFloat) val = parseFloat(str);
  else if (!octal || str.length === 1) val = parseInt(str, 10);
  else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");
  else val = parseInt(str, 8);
  return this.finishToken(tt.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$7.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) return String.fromCharCode(code)
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$7.readString = function(quote) {
  var this$1 = this;

  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated string constant");
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === quote) break
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch)) this$1.raise(this$1.start, "Unterminated string constant");
      ++this$1.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(tt.string, out)
};

// Reads template string tokens.

pp$7.readTmplToken = function() {
  var this$1 = this;

  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated template");
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
      if (this$1.pos === this$1.start && this$1.type === tt.template) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(tt.dollarBraceL)
        } else {
          ++this$1.pos;
          return this$1.finishToken(tt.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(tt.template, out)
    }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;
      switch (ch) {
        case 13:
          if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos;
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
      }
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
};

// Used to read escaped characters

pp$7.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      if (octalStr !== "0" && (this.strict || inTemplate)) {
        this.raise(this.pos - 2, "Octal literal in strict mode");
      }
      this.pos += octalStr.length - 1;
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$7.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$7.readWord1 = function() {
  var this$1 = this;

  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;
      if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
        this$1.raise(this$1.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this$1.pos;
      var esc = this$1.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        this$1.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$7.readWord = function() {
  var word = this.readWord1();
  var type = tt.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + word);
    type = keywordTypes[word];
  }
  return this.finishToken(type, word)
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse$1(input, options) {
  return new Parser(options, input).parse()
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression()
}

const literals = new Map([
	[ 'true', true ],
	[ 'false', false ],
	[ 'null', null ]
]);

function readExpression ( parser ) {
	const start = parser.index;

	const name = parser.readUntil( /\s*}}/ );
	if ( name && /^[a-z]+$/.test( name ) ) {
		const end = start + name.length;

		if ( literals.has( name ) ) {
			return {
				type: 'Literal',
				start,
				end,
				value: literals.get( name ),
				raw: name
			};
		}

		return {
			type: 'Identifier',
			start,
			end: start + name.length,
			name
		};
	}

	parser.index = start;

	try {
		const node = parseExpressionAt( parser.template, parser.index, { preserveParens: true } );
		parser.index = node.end;

		return node;
	} catch ( err ) {
		parser.acornError( err );
	}
}

function spaces ( i ) {
	let result = '';
	while ( i-- ) { result += ' '; }
	return result;
}

const scriptClosingTag = '<\/script>';

function readScript ( parser, start, attributes ) {
	const scriptStart = parser.index;
	const scriptEnd = parser.template.indexOf( scriptClosingTag, scriptStart );

	if ( scriptEnd === -1 ) { parser.error( `<script> must have a closing tag` ); }

	const source = spaces( scriptStart ) + parser.template.slice( scriptStart, scriptEnd );
	parser.index = scriptEnd + scriptClosingTag.length;

	let ast;

	try {
		ast = parse$1( source, {
			ecmaVersion: 8,
			sourceType: 'module'
		});
	} catch ( err ) {
		parser.acornError( err );
	}

	if ( !ast.body.length ) { return null; }

	ast.start = scriptStart;
	return {
		start,
		end: parser.index,
		attributes,
		content: ast
	};
}

var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\n|\r\n?|\f/);
    var column = error.column;
    var line = error.line;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].join('\n');
}

var CssSyntaxError$1 = function(message, source, offset, line, column) {
    var error = new SyntaxError();
    error.name = 'CssSyntaxError';
    error.message = message;
    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

var error = CssSyntaxError$1;

// token types (note: value shouldn't intersect with used char codes)
var WHITESPACE$2 = 1;
var IDENTIFIER$1 = 2;
var NUMBER$1 = 3;
var STRING$1 = 4;
var COMMENT$2 = 5;
var PUNCTUATOR$1 = 6;

var TAB = 9;
var N$1 = 10;
var F$1 = 12;
var R$1 = 13;
var SPACE = 32;

var TYPE$2 = {
    Whitespace:   WHITESPACE$2,
    Identifier:   IDENTIFIER$1,
    Number:           NUMBER$1,
    String:           STRING$1,
    Comment:         COMMENT$2,
    Punctuator:   PUNCTUATOR$1,

    ExclamationMark:      33,  // !
    QuotationMark:        34,  // "
    NumberSign:           35,  // #
    DollarSign:           36,  // $
    PercentSign:          37,  // %
    Ampersand:            38,  // &
    Apostrophe:           39,  // '
    LeftParenthesis:      40,  // (
    RightParenthesis:     41,  // )
    Asterisk:             42,  // *
    PlusSign:             43,  // +
    Comma:                44,  // ,
    HyphenMinus:          45,  // -
    FullStop:             46,  // .
    Solidus:              47,  // /
    Colon:                58,  // :
    Semicolon:            59,  // ;
    LessThanSign:         60,  // <
    EqualsSign:           61,  // =
    GreaterThanSign:      62,  // >
    QuestionMark:         63,  // ?
    CommercialAt:         64,  // @
    LeftSquareBracket:    91,  // [
    Backslash:            92,  // \
    RightSquareBracket:   93,  // ]
    CircumflexAccent:     94,  // ^
    LowLine:              95,  // _
    GraveAccent:          96,  // `
    LeftCurlyBracket:    123,  // {
    VerticalLine:        124,  // |
    RightCurlyBracket:   125,  // }
    Tilde:               126   // ~
};

var NAME$1 = Object.keys(TYPE$2).reduce(function(result, key) {
    result[TYPE$2[key]] = key;
    return result;
}, {});

var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
var SYMBOL_TYPE$1 = new SafeUint32Array$1(Math.max.apply(null, Object.keys(NAME$1).map(Number)) + 1);
var PUNCTUATION = new SafeUint32Array$1(SYMBOL_TYPE$1.length);

for (var i = 0; i < SYMBOL_TYPE$1.length; i++) {
    SYMBOL_TYPE$1[i] = IDENTIFIER$1;
}

// fill categories
[
    TYPE$2.ExclamationMark,    // !
    TYPE$2.QuotationMark,      // "
    TYPE$2.NumberSign,         // #
    TYPE$2.DollarSign,         // $
    TYPE$2.PercentSign,        // %
    TYPE$2.Ampersand,          // &
    TYPE$2.Apostrophe,         // '
    TYPE$2.LeftParenthesis,    // (
    TYPE$2.RightParenthesis,   // )
    TYPE$2.Asterisk,           // *
    TYPE$2.PlusSign,           // +
    TYPE$2.Comma,              // ,
    TYPE$2.HyphenMinus,        // -
    TYPE$2.FullStop,           // .
    TYPE$2.Solidus,            // /
    TYPE$2.Colon,              // :
    TYPE$2.Semicolon,          // ;
    TYPE$2.LessThanSign,       // <
    TYPE$2.EqualsSign,         // =
    TYPE$2.GreaterThanSign,    // >
    TYPE$2.QuestionMark,       // ?
    TYPE$2.CommercialAt,       // @
    TYPE$2.LeftSquareBracket,  // [
    // TYPE.Backslash,          // \
    TYPE$2.RightSquareBracket, // ]
    TYPE$2.CircumflexAccent,   // ^
    // TYPE.LowLine,            // _
    TYPE$2.GraveAccent,        // `
    TYPE$2.LeftCurlyBracket,   // {
    TYPE$2.VerticalLine,       // |
    TYPE$2.RightCurlyBracket,  // }
    TYPE$2.Tilde               // ~
].forEach(function(key) {
    SYMBOL_TYPE$1[Number(key)] = PUNCTUATOR$1;
    PUNCTUATION[Number(key)] = PUNCTUATOR$1;
}, SYMBOL_TYPE$1);

for (var i = 48; i <= 57; i++) {
    SYMBOL_TYPE$1[i] = NUMBER$1;
}

SYMBOL_TYPE$1[SPACE] = WHITESPACE$2;
SYMBOL_TYPE$1[TAB] = WHITESPACE$2;
SYMBOL_TYPE$1[N$1] = WHITESPACE$2;
SYMBOL_TYPE$1[R$1] = WHITESPACE$2;
SYMBOL_TYPE$1[F$1] = WHITESPACE$2;

SYMBOL_TYPE$1[TYPE$2.Apostrophe] = STRING$1;
SYMBOL_TYPE$1[TYPE$2.QuotationMark] = STRING$1;

// whitespace is punctuation ...
PUNCTUATION[SPACE] = PUNCTUATOR$1;
PUNCTUATION[TAB] = PUNCTUATOR$1;
PUNCTUATION[N$1] = PUNCTUATOR$1;
PUNCTUATION[R$1] = PUNCTUATOR$1;
PUNCTUATION[F$1] = PUNCTUATOR$1;
// ... hyper minus is not
PUNCTUATION[TYPE$2.HyphenMinus] = 0;

var _const = {
    TYPE: TYPE$2,
    NAME: NAME$1,

    SYMBOL_TYPE: SYMBOL_TYPE$1,
    PUNCTUATION: PUNCTUATION
};

var constants$1 = _const;
var PUNCTUATION$1 = constants$1.PUNCTUATION;
var SYMBOL_TYPE$2 = constants$1.SYMBOL_TYPE;
var SYMBOL_TYPE_LENGTH$1 = SYMBOL_TYPE$2.length;
var TYPE$3 = constants$1.TYPE;
var FULLSTOP$1 = TYPE$3.FullStop;
var PLUSSIGN$1 = TYPE$3.PlusSign;
var HYPHENMINUS$1 = TYPE$3.HyphenMinus;
var PUNCTUATOR$2 = TYPE$3.Punctuator;
var TAB$1 = 9;
var N$2 = 10;
var F$2 = 12;
var R$2 = 13;
var SPACE$1 = 32;
var BACK_SLASH = 92;
var E = 101; // 'e'.charCodeAt(0)

function firstCharOffset$1(source) {
    return source.charCodeAt(0) === 0xFEFF ? 1 : 0;
}

function isHex(code) {
    return (code >= 48 && code <= 57) || // 0 .. 9
           (code >= 65 && code <= 70) || // A .. F
           (code >= 97 && code <= 102);  // a .. f
}

function isNumber$1(code) {
    return code >= 48 && code <= 57;
}

function isNewline(source, offset, code) {
    if (code === N$2 || code === F$2 || code === R$2) {
        if (code === R$2 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$2) {
            return 2;
        }

        return 1;
    }

    return 0;
}

function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase()
    if (code >= 65 && code <= 90) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr$1(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var refCode = referenceStr.charCodeAt(i - start);

        // testStr[i].toLowerCase()
        if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
        }

        if (testCode !== refCode) {
            return false;
        }
    }

    return true;
}

function endsWith(testStr, referenceStr) {
    return cmpStr$1(testStr, testStr.length - referenceStr.length, testStr.length, referenceStr);
}

function findLastNonSpaceLocation$1(scanner) {
    for (var i = scanner.source.length - 1; i >= 0; i--) {
        var code = scanner.source.charCodeAt(i);

        if (code !== SPACE$1 && code !== TAB$1 && code !== R$2 && code !== N$2 && code !== F$2) {
            break;
        }
    }

    return scanner.getLocation(i + 1);
}

function findWhitespaceEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code !== SPACE$1 && code !== TAB$1 && code !== R$2 && code !== N$2 && code !== F$2) {
            break;
        }
    }

    return offset;
}

function findCommentEnd$1(source, offset) {
    var commentEnd = source.indexOf('*/', offset);

    if (commentEnd === -1) {
        return source.length;
    }

    return commentEnd + 2;
}

function findStringEnd$1(source, offset, quote) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // TODO: bad string
        if (code === BACK_SLASH) {
            offset++;
        } else if (code === quote) {
            offset++;
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code < 48 || code > 57) {  // not a 0 .. 9
            break;
        }
    }

    return offset;
}

function findNumberEnd$1(source, offset, allowFraction) {
    var code;

    offset = findDecimalNumberEnd(source, offset);

    // fraction: .\d+
    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP$1) {
        code = source.charCodeAt(offset + 1);

        if (isNumber$1(code)) {
            offset = findDecimalNumberEnd(source, offset + 1);
        }
    }

    // exponent: e[+-]\d+
    if (offset + 1 < source.length) {
        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
            code = source.charCodeAt(offset + 1);

            if (code === PLUSSIGN$1 || code === HYPHENMINUS$1) {
                if (offset + 2 < source.length) {
                    code = source.charCodeAt(offset + 2);
                }
            }

            if (isNumber$1(code)) {
                offset = findDecimalNumberEnd(source, offset + 2);
            }
        }
    }

    return offset;
}

// skip escaped unicode sequence that can ends with space
// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
function findEscaseEnd(source, offset) {
    for (var i = 0; i < 7 && offset + i < source.length; i++) {
        var code = source.charCodeAt(offset + i);

        if (i !== 6 && isHex(code)) {
            continue;
        }

        if (i > 0) {
            offset += i - 1 + isNewline(source, offset + i, code);
            if (code === SPACE$1 || code === TAB$1) {
                offset++;
            }
        }

        break;
    }

    return offset;
}

function findIdentifierEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscaseEnd(source, offset + 1);
        } else if (code < SYMBOL_TYPE_LENGTH$1 && PUNCTUATION$1[code] === PUNCTUATOR$2) {
            break;
        }
    }

    return offset;
}

var utils$1 = {
    firstCharOffset: firstCharOffset$1,

    isHex: isHex,
    isNumber: isNumber$1,
    isNewline: isNewline,

    cmpChar: cmpChar,
    cmpStr: cmpStr$1,
    endsWith: endsWith,

    findLastNonSpaceLocation: findLastNonSpaceLocation$1,
    findWhitespaceEnd: findWhitespaceEnd$1,
    findCommentEnd: findCommentEnd$1,
    findStringEnd: findStringEnd$1,
    findDecimalNumberEnd: findDecimalNumberEnd,
    findNumberEnd: findNumberEnd$1,
    findEscaseEnd: findEscaseEnd,
    findIdentifierEnd: findIdentifierEnd$1
};

var CssSyntaxError = error;

var constants = _const;
var TYPE$1 = constants.TYPE;
var NAME = constants.NAME;
var SYMBOL_TYPE = constants.SYMBOL_TYPE;
var SYMBOL_TYPE_LENGTH = SYMBOL_TYPE.length;

var utils = utils$1;
var firstCharOffset = utils.firstCharOffset;
var cmpStr = utils.cmpStr;
var isNumber = utils.isNumber;
var findLastNonSpaceLocation = utils.findLastNonSpaceLocation;
var findWhitespaceEnd = utils.findWhitespaceEnd;
var findCommentEnd = utils.findCommentEnd;
var findStringEnd = utils.findStringEnd;
var findNumberEnd = utils.findNumberEnd;
var findIdentifierEnd = utils.findIdentifierEnd;

var NULL = 0;
var WHITESPACE$1 = TYPE$1.Whitespace;
var IDENTIFIER = TYPE$1.Identifier;
var NUMBER = TYPE$1.Number;
var STRING = TYPE$1.String;
var COMMENT$1 = TYPE$1.Comment;
var PUNCTUATOR = TYPE$1.Punctuator;

var N = 10;
var F = 12;
var R = 13;
var STAR = TYPE$1.Asterisk;
var SLASH = TYPE$1.Solidus;
var FULLSTOP = TYPE$1.FullStop;
var PLUSSIGN = TYPE$1.PlusSign;
var HYPHENMINUS = TYPE$1.HyphenMinus;

var MIN_BUFFER_SIZE = 16 * 1024;
var OFFSET_MASK = 0x00FFFFFF;
var TYPE_OFFSET = 24;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

function computeLinesAndColumns(tokenizer, source) {
    var sourceLength = source.length;
    var start = firstCharOffset(source);
    var lines = tokenizer.lines;
    var line = tokenizer.startLine;
    var columns = tokenizer.columns;
    var column = tokenizer.startColumn;

    if (lines === null || lines.length < sourceLength + 1) {
        lines = new SafeUint32Array(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
        columns = new SafeUint32Array(lines.length);
    }

    for (var i = start; i < sourceLength; i++) {
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    tokenizer.linesAnsColumnsComputed = true;
    tokenizer.lines = lines;
    tokenizer.columns = columns;
}

function tokenLayout(tokenizer, source, startPos) {
    var sourceLength = source.length;
    var offsetAndType = tokenizer.offsetAndType;
    var tokenCount = 0;
    var prevType = 0;
    var offset = startPos;

    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
        offsetAndType = new SafeUint32Array(sourceLength + 1024);
    }

    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = code < SYMBOL_TYPE_LENGTH ? SYMBOL_TYPE[code] : IDENTIFIER;

        switch (type) {
            case WHITESPACE$1:
                offset = findWhitespaceEnd(source, offset + 1);
                break;

            case PUNCTUATOR:
                if (code === STAR && prevType === SLASH) { // /*
                    type = COMMENT$1;
                    offset = findCommentEnd(source, offset + 1);
                    tokenCount--; // rewrite prev token
                } else {
                    // edge case for -.123 and +.123
                    if (code === FULLSTOP && (prevType === PLUSSIGN || prevType === HYPHENMINUS)) {
                        if (offset + 1 < sourceLength && isNumber(source.charCodeAt(offset + 1))) {
                            type = NUMBER;
                            offset = findNumberEnd(source, offset + 2, false);
                            tokenCount--; // rewrite prev token
                            break;
                        }
                    }

                    type = code;
                    offset = offset + 1;
                }

                break;

            case NUMBER:
                offset = findNumberEnd(source, offset + 1, prevType !== FULLSTOP);

                // merge number with a preceding dot, dash or plus
                if (prevType === FULLSTOP ||
                    prevType === HYPHENMINUS ||
                    prevType === PLUSSIGN) {
                    tokenCount--; // rewrite prev token
                }

                break;

            case STRING:
                offset = findStringEnd(source, offset + 1, code);
                break;

            default:
                offset = findIdentifierEnd(source, offset);

                // merge identifier with a preceding dash
                if (prevType === HYPHENMINUS) {
                    tokenCount--; // rewrite prev token
                }
        }

        offsetAndType[tokenCount++] = (type << TYPE_OFFSET) | offset;
        prevType = type;
    }

    offsetAndType[tokenCount] = offset;

    tokenizer.offsetAndType = offsetAndType;
    tokenizer.tokenCount = tokenCount;
}

//
// tokenizer
//

var Tokenizer$1 = function(source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source || '', startOffset, startLine, startColumn);
};

Tokenizer$1.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        var start = firstCharOffset(source);

        this.source = source;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAnsColumnsComputed = false;

        this.eof = false;
        this.currentToken = -1;
        this.tokenType = 0;
        this.tokenStart = start;
        this.tokenEnd = start;

        tokenLayout(this, source, start);
        this.next();
    },

    lookupType: function(offset) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_OFFSET;
        }

        return NULL;
    },
    lookupNonWSType: function(offset) {
        offset += this.currentToken;

        for (var type; offset < this.tokenCount; offset++) {
            type = this.offsetAndType[offset] >> TYPE_OFFSET;

            if (type !== WHITESPACE$1) {
                return type;
            }
        }

        return NULL;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_OFFSET) !== WHITESPACE$1) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skip: function(tokenCount) {
        var next = this.currentToken + tokenCount;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_OFFSET;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.currentToken + 1;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_OFFSET;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.eof = true;
            this.tokenType = NULL;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    eat: function(tokenType) {
        if (this.tokenType !== tokenType) {
            this.error(
                NAME[tokenType] + ' is expected',
                // when test type is part of another token show error for current position + 1
                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                this.tokenStart + (this.source.charCodeAt(this.tokenStart) === tokenType ? 1 : 0)
            );
        }

        this.next();
    },
    eatNonWS: function(tokenType) {
        this.skipWS();
        this.eat(tokenType);
    },

    consume: function(tokenType) {
        var start = this.tokenStart;

        this.eat(tokenType);

        return this.substrToCursor(start);
    },
    consumeNonWS: function(tokenType) {
        this.skipWS();

        return this.consume(tokenType);
    },

    expectIdentifier: function(name) {
        if (this.tokenType !== IDENTIFIER || cmpStr(this.source, this.tokenStart, this.tokenEnd, name) === false) {
            this.error('Identifier `' + name + '` is expected');
        }

        this.next();
    },

    getLocation: function(offset, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },

    getLocationRange: function(start, end, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    },

    error: function(message, offset) {
        var location = typeof offset !== 'undefined' && offset < this.source.length
            ? this.getLocation(offset)
            : this.eof
                ? findLastNonSpaceLocation(this)
                : this.getLocation(this.tokenStart);

        throw new CssSyntaxError(
            message || 'Unexpected input',
            this.source,
            location.offset,
            location.line,
            location.column
        );
    },

    getTypes: function() {
        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item) {
            return NAME[item >> TYPE_OFFSET];
        });
    }
};

// extend with error class
Tokenizer$1.CssSyntaxError = CssSyntaxError;

// extend tokenizer with constants
Object.keys(constants).forEach(function(key) {
    Tokenizer$1[key] = constants[key];
});

// extend tokenizer with static methods from utils
Object.keys(utils).forEach(function(key) {
    Tokenizer$1[key] = utils[key];
});

// warm up tokenizer to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
new Tokenizer$1('\n\r\r\n\f//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);+1.2e3 -.4e-5 .6e+7}').getLocation();

var Tokenizer_1 = Tokenizer$1;

var index$1 = Tokenizer_1;

//
//            item        item        item        item
//          /------\    /------\    /------\    /------\
//          | data |    | data |    | data |    | data |
//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
//          | next-+--->| next-+--->| next-+--->| next-+--> null
//          \------/    \------/    \------/    \------/
//             ^                                    ^
//             |                list                |
//             |              /------\              |
//             \--------------+-head |              |
//                            | tail-+--------------/
//                            \------/
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

var cursors = null;
var List$1 = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List$1.createItem = createItem;
List$1.prototype.createItem = createItem;

List$1.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List$1.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List$1.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List$1.prototype.toJSON = List$1.prototype.toArray;

List$1.prototype.isEmpty = function() {
    return this.head === null;
};

List$1.prototype.first = function() {
    return this.head && this.head.data;
};

List$1.prototype.last = function() {
    return this.tail && this.tail.data;
};

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

List$1.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List$1.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List$1.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List$1.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List$1.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List$1.prototype.map = function(fn, context) {
    var result = [];
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.push(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List$1.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List$1.prototype.copy = function() {
    var result = new List$1();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List$1.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List$1.prototype.append = function(item) {
    // tail
    //      ^
    //     item
    this.updateCursors(this.tail, item, null, item);

    // insert to end of the list
    if (this.tail !== null) {
        // if list has a tail, then it also has a head, but head doesn't change

        // last item -> new item
        this.tail.next = item;

        // last item <- new item
        item.prev = this.tail;
    } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = item;
    }

    // tail always start point to new item
    this.tail = item;

    return this;
};

List$1.prototype.appendData = function(data) {
    return this.append(createItem(data));
};

List$1.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t below to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        this.append(item);
    }
};

List$1.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t below to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t below to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List$1.prototype.appendList = function(list) {
    // ignore empty lists
    if (list.head === null) {
        return;
    }

    this.updateCursors(this.tail, list.tail, null, list.head);

    // insert to end of the list
    if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn't change

        // dest tail -> source head
        this.tail.next = list.head;

        // dest tail <- source head
        list.head.prev = this.tail;
    } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
    }

    // tail always start point to new item
    this.tail = list.tail;

    list.head = null;
    list.tail = null;
};

var list = List$1;

var List = list;
var cmpChar$1 = index$1.cmpChar;
var TYPE$4 = index$1.TYPE;

var WHITESPACE$3 = TYPE$4.Whitespace;
var IDENTIFIER$2 = TYPE$4.Identifier;
var STRING$2 = TYPE$4.String;
var NUMBER$2 = TYPE$4.Number;
var COMMENT$3 = TYPE$4.Comment;
var NUMBERSIGN = TYPE$4.NumberSign;
var LEFTPARENTHESIS = TYPE$4.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE$4.LeftSquareBracket;
var PLUSSIGN$2 = TYPE$4.PlusSign;
var HYPHENMINUS$2 = TYPE$4.HyphenMinus;
var COMMA = TYPE$4.Comma;
var SOLIDUS = TYPE$4.Solidus;
var ASTERISK = TYPE$4.Asterisk;
var PERCENTSIGN = TYPE$4.PercentSign;
var FULLSTOP$2 = TYPE$4.FullStop;
var COLON = TYPE$4.Colon;
var GREATERTHANSIGN = TYPE$4.GreaterThanSign;
var VERTICALLINE = TYPE$4.VerticalLine;
var TILDE = TYPE$4.Tilde;
var U = 117; // 'u'.charCodeAt(0)

var ALLOW_OF_CLAUSE = true;
var DISALLOW_OF_CLAUSE = false;

function singleIdentifier() {
    return new List().appendData(
        this.Identifier()
    );
}

function selectorList() {
    return new List().appendData(
        this.SelectorList()
    );
}

function compoundSelector() {
    return new List().appendData(
        this.Selector()
    );
}

function nth() {
    return new List().appendData(
        this.Nth(DISALLOW_OF_CLAUSE)
    );
}

function nthWithOfClause() {
    return new List().appendData(
        this.Nth(ALLOW_OF_CLAUSE)
    );
}

function selectorSequence() {
    var children = new List();
    var space = null;
    var child = null;
    var ignoreWSAfter = false;
    var ignoreWS = false;

    this.readSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT$3:
                this.scanner.next();
                continue;

            case WHITESPACE$3:
                if (ignoreWS) {
                    this.scanner.next();
                } else {
                    space = this.WhiteSpace();
                }
                continue;

            case PLUSSIGN$2:
            case GREATERTHANSIGN:
            case TILDE:
                space = null;
                ignoreWSAfter = true;
                child = this.Combinator();
                break;

            case SOLIDUS:  // /deep/
                child = this.Combinator();
                break;

            case FULLSTOP$2:
                child = this.ClassSelector();
                break;

            case LEFTSQUAREBRACKET:
                child = this.AttributeSelector();
                break;

            case NUMBERSIGN:
                child = this.IdSelector();
                break;

            case COLON:
                if (this.scanner.lookupType(1) === COLON) {
                    child = this.PseudoElementSelector();
                } else {
                    child = this.PseudoClassSelector();
                }

                break;

            case IDENTIFIER$2:
            case ASTERISK:
            case VERTICALLINE:
                child = this.TypeSelector();
                break;

            case NUMBER$2:
                child = this.Percentage();
                break;

            default:
                if (typeof this.readSelectorSequenceFallback === 'function') {
                    child = this.readSelectorSequenceFallback();
                    if (!child) {
                        break scan;
                    }
                } else {
                    break scan;
                }
        }

        if (space !== null) {
            children.appendData(space);
            space = null;
        }

        children.appendData(child);

        if (ignoreWSAfter) {
            ignoreWSAfter = false;
            ignoreWS = true;
        } else {
            ignoreWS = false;
        }
    }

    // nothing were consumed
    if (child === null) {
        this.scanner.error('Selector is expected');
    }

    return children;
}

function defaultSequence(scope) {
    var children = new List();
    var space = null;
    var child = null;
    var ignoreWSAfter = false;
    var ignoreWS = false;

    this.readSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT$3:
                this.scanner.next();
                continue;

            case WHITESPACE$3:
                if (ignoreWS) {
                    this.scanner.next();
                } else {
                    space = this.WhiteSpace();
                }
                continue;

            case NUMBERSIGN:
                child = this.HexColor();
                break;

            case COMMA:
                space = null;
                ignoreWSAfter = true;
                child = this.Operator();
                break;

            case SOLIDUS:
            case ASTERISK:
            case PLUSSIGN$2:
            case HYPHENMINUS$2:
                child = this.Operator();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(defaultSequence);
                break;

            case LEFTSQUAREBRACKET:
                child = this.Brackets(defaultSequence);
                break;

            case STRING$2:
                child = this.String();
                break;

            case NUMBER$2:
                switch (this.scanner.lookupType(1)) {
                    case PERCENTSIGN:
                        child = this.Percentage();
                        break;

                    case IDENTIFIER$2:
                        child = this.Dimension();
                        break;

                    default:
                        child = this.Number();
                }

                break;

            case IDENTIFIER$2:
                // check for unicode range, it should start with u+ or U+
                if (cmpChar$1(this.scanner.source, this.scanner.tokenStart, U) &&
                    cmpChar$1(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$2)) {
                    child = this.UnicodeRange();
                } else if (this.scanner.lookupType(1) === LEFTPARENTHESIS) {
                    if (this.scanner.lookupValue(0, 'url')) {
                        child = this.Url();
                    } else {
                        child = this.Function(scope, defaultSequence);
                    }
                } else {
                    child = this.Identifier();
                }

                break;

            default:
                if (typeof this.readSequenceFallback === 'function') {
                    child = this.readSequenceFallback();
                    if (!child) {
                        break scan;
                    }
                } else {
                    break scan;
                }
        }

        if (space !== null) {
            children.appendData(space);
            space = null;
        }

        children.appendData(child);

        if (ignoreWSAfter) {
            ignoreWSAfter = false;
            ignoreWS = true;
        } else {
            ignoreWS = false;
        }
    }

    return children;
}

var sequence$1 = {
    singleIdentifier: singleIdentifier,
    selectorList: selectorList,
    compoundSelector: compoundSelector,
    nth: nth,
    nthWithOfClause: nthWithOfClause,
    selector: selectorSequence,
    default: defaultSequence
};

var cmpChar$2 = index$1.cmpChar;
var isNumber$2 = index$1.isNumber;
var TYPE$5 = index$1.TYPE;

var IDENTIFIER$3 = TYPE$5.Identifier;
var NUMBER$3 = TYPE$5.Number;
var PLUSSIGN$3 = TYPE$5.PlusSign;
var HYPHENMINUS$3 = TYPE$5.HyphenMinus;
var N$3 = 110; // 'n'.charCodeAt(0)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkTokenIsInteger(scanner, disallowSign) {
    var pos = scanner.tokenStart;

    if (scanner.source.charCodeAt(pos) === PLUSSIGN$3 ||
        scanner.source.charCodeAt(pos) === HYPHENMINUS$3) {
        if (disallowSign) {
            scanner.error();
        }
        pos++;
    }

    for (; pos < scanner.tokenEnd; pos++) {
        if (!isNumber$2(scanner.source.charCodeAt(pos))) {
            scanner.error('Unexpected input', pos);
        }
    }
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
var AnPlusB = function AnPlusB() {
    var start = this.scanner.tokenStart;
    var end = start;
    var prefix = '';
    var a = null;
    var b = null;

    if (this.scanner.tokenType === NUMBER$3 ||
        this.scanner.tokenType === PLUSSIGN$3) {
        checkTokenIsInteger(this.scanner, ALLOW_SIGN);
        prefix = this.scanner.getTokenValue();
        this.scanner.next();
        end = this.scanner.tokenStart;
    }

    if (this.scanner.tokenType === IDENTIFIER$3) {
        var bStart = this.scanner.tokenStart;

        if (cmpChar$2(this.scanner.source, bStart, HYPHENMINUS$3)) {
            if (prefix === '') {
                prefix = '-';
                bStart++;
            } else {
                this.scanner.error('Unexpected hyphen minus');
            }
        }

        if (!cmpChar$2(this.scanner.source, bStart, N$3)) {
            this.scanner.error();
        }

        a = prefix === ''  ? '1'  :
            prefix === '+' ? '+1' :
            prefix === '-' ? '-1' :
            prefix;

        var len = this.scanner.tokenEnd - bStart;
        if (len > 1) {
            // ..n-..
            if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$3) {
                this.scanner.error('Unexpected input', bStart + 1);
            }

            if (len > 2) {
                // ..n-{number}..
                this.scanner.tokenStart = bStart + 2;
            } else {
                // ..n- {number}
                this.scanner.next();
                this.readSC();
            }

            checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
            b = '-' + this.scanner.getTokenValue();
            this.scanner.next();
            end = this.scanner.tokenStart;
        } else {
            prefix = '';
            this.scanner.next();
            end = this.scanner.tokenStart;
            this.readSC();

            if (this.scanner.tokenType === HYPHENMINUS$3 ||
                this.scanner.tokenType === PLUSSIGN$3) {
                prefix = this.scanner.getTokenValue();
                this.scanner.next();
                this.readSC();
            }

            if (this.scanner.tokenType === NUMBER$3) {
                checkTokenIsInteger(this.scanner, prefix !== '');

                if (!isNumber$2(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
                    prefix = this.scanner.source.charAt(this.scanner.tokenStart);
                    this.scanner.tokenStart++;
                }

                if (prefix === '') {
                    // should be an operator before number
                    this.scanner.error();
                } else if (prefix === '+') {
                    // plus is using by default
                    prefix = '';
                }

                b = prefix + this.scanner.getTokenValue();

                this.scanner.next();
                end = this.scanner.tokenStart;
            } else {
                if (prefix) {
                    this.scanner.eat(NUMBER$3);
                }
            }
        }
    } else {
        if (prefix === '' || prefix === '+') { // no number
            this.scanner.error(
                'Number or identifier is expected',
                this.scanner.tokenStart + (
                    this.scanner.tokenType === PLUSSIGN$3 ||
                    this.scanner.tokenType === HYPHENMINUS$3
                )
            );
        }

        b = prefix;
    }

    return {
        type: 'AnPlusB',
        loc: this.getLocation(start, end),
        a: a,
        b: b
    };
};

var TYPE$6 = index$1.TYPE;

var IDENTIFIER$4 = TYPE$6.Identifier;
var SEMICOLON = TYPE$6.Semicolon;
var COMMERCIALAT = TYPE$6.CommercialAt;
var LEFTCURLYBRACKET = TYPE$6.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE$6.RightCurlyBracket;
var BALANCED = true;

function isBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
            return true;
        }

        if (type === LEFTCURLYBRACKET ||
            type === COMMERCIALAT) {
            return false;
        }
    }

    this.scanner.skip(offset);
    this.scanner.eat(RIGHTCURLYBRACKET);
}

var Atrule = function Atrule() {
    var start = this.scanner.tokenStart;
    var name;
    var nameLowerCase;
    var expression = null;
    var block = null;

    this.scanner.eat(COMMERCIALAT);

    name = this.scanner.consume(IDENTIFIER$4);
    nameLowerCase = name.toLowerCase();
    this.readSC();

    if (this.parseAtruleExpression) {
        expression = this.AtruleExpression(name);
        this.readSC();
    } else {
        expression = this.Raw(BALANCED, SEMICOLON, LEFTCURLYBRACKET);
    }

    if (this.atrule.hasOwnProperty(nameLowerCase)) {
        if (typeof this.atrule[nameLowerCase].block === 'function') {
            if (this.scanner.tokenType !== LEFTCURLYBRACKET) {
                this.scanner.error('Curly bracket is expected');
            }

            block = this.atrule[nameLowerCase].block.call(this);
        } else {
            this.scanner.eat(SEMICOLON);
        }
    } else {
        switch (this.scanner.tokenType) {
            case SEMICOLON:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET:
                block = this.Block(isBlockAtrule.call(this) ? this.Declaration : this.Rule);
                break;

            default:
                this.scanner.error('Semicolon or block is expected');
        }
    }

    return {
        type: 'Atrule',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        expression: expression,
        block: block
    };
};

var List$2 = list;

var AtruleExpression = function AtruleExpression(name) {
    var children = null;

    if (name !== null) {
        name = name.toLowerCase();
    }

    // custom consumer
    if (this.atrule.hasOwnProperty(name)) {
        if (typeof this.atrule[name].expression === 'function') {
            children = this.atrule[name].expression.call(this);

            if (children instanceof List$2 === false) {
                return children;
            }
        }
    } else {
        // default consumer
        this.readSC();
        children = this.readSequence(this.scopeAtruleExpression);
    }

    if (children === null || children.isEmpty()) {
        return null;
    }

    return {
        type: 'AtruleExpression',
        loc: this.getLocationFromList(children),
        children: children
    };
};

var TYPE$7 = index$1.TYPE;

var IDENTIFIER$5 = TYPE$7.Identifier;
var STRING$3 = TYPE$7.String;
var DOLLARSIGN = TYPE$7.DollarSign;
var ASTERISK$1 = TYPE$7.Asterisk;
var COLON$1 = TYPE$7.Colon;
var EQUALSSIGN = TYPE$7.EqualsSign;
var LEFTSQUAREBRACKET$1 = TYPE$7.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE$7.RightSquareBracket;
var CIRCUMFLEXACCENT = TYPE$7.CircumflexAccent;
var VERTICALLINE$1 = TYPE$7.VerticalLine;
var TILDE$1 = TYPE$7.Tilde;

function getAttributeName() {
    if (this.scanner.eof) {
        this.scanner.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdentifier = false;
    var checkColon = true;

    if (this.scanner.tokenType === ASTERISK$1) {
        expectIdentifier = true;
        checkColon = false;
        this.scanner.next();
    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
        this.scanner.eat(IDENTIFIER$5);
    }

    if (this.scanner.tokenType === VERTICALLINE$1) {
        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
            this.scanner.next();
            this.scanner.eat(IDENTIFIER$5);
        } else if (expectIdentifier) {
            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdentifier) {
        this.scanner.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON$1) {
        this.scanner.next();
        this.scanner.eat(IDENTIFIER$5);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator$1() {
    var start = this.scanner.tokenStart;
    var tokenType = this.scanner.tokenType;

    if (tokenType !== EQUALSSIGN &&        // =
        tokenType !== TILDE$1 &&             // ~=
        tokenType !== CIRCUMFLEXACCENT &&  // ^=
        tokenType !== DOLLARSIGN &&        // $=
        tokenType !== ASTERISK$1 &&          // *=
        tokenType !== VERTICALLINE$1         // |=
    ) {
        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    if (tokenType === EQUALSSIGN) {
        this.scanner.next();
    } else {
        this.scanner.next();
        this.scanner.eat(EQUALSSIGN);
    }

    return this.scanner.substrToCursor(start);
}

// '[' S* attrib_name ']'
// '[' S* attrib_name S* attrib_match S* [ IDENT | STRING ] S* attrib_flags? S* ']'
var AttributeSelector = function AttributeSelector() {
    var start = this.scanner.tokenStart;
    var name;
    var operator = null;
    var value = null;
    var flags = null;

    this.scanner.eat(LEFTSQUAREBRACKET$1);
    this.readSC();

    name = getAttributeName.call(this);
    this.readSC();

    if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
        // avoid case `[name i]`
        if (this.scanner.tokenType !== IDENTIFIER$5) {
            operator = getOperator$1.call(this);

            this.readSC();

            value = this.scanner.tokenType === STRING$3
                ? this.String()
                : this.Identifier();

            this.readSC();
        }

        // attribute flags
        if (this.scanner.tokenType === IDENTIFIER$5) {
            flags = this.scanner.getTokenValue();
            this.scanner.next();

            this.readSC();
        }
    }

    this.scanner.eat(RIGHTSQUAREBRACKET);

    return {
        type: 'AttributeSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        operator: operator,
        value: value,
        flags: flags
    };
};

var List$3 = list;
var TYPE$8 = index$1.TYPE;

var WHITESPACE$4 = TYPE$8.Whitespace;
var COMMENT$4 = TYPE$8.Comment;
var SEMICOLON$1 = TYPE$8.Semicolon;
var COMMERCIALAT$1 = TYPE$8.CommercialAt;
var LEFTCURLYBRACKET$1 = TYPE$8.LeftCurlyBracket;
var RIGHTCURLYBRACKET$1 = TYPE$8.RightCurlyBracket;

var Block = function Block(defaultConsumer) {
    defaultConsumer = defaultConsumer || this.Declaration;

    var start = this.scanner.tokenStart;
    var children = new List$3();

    this.scanner.eat(LEFTCURLYBRACKET$1);

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case RIGHTCURLYBRACKET$1:
                break scan;

            case WHITESPACE$4:
            case COMMENT$4:
            case SEMICOLON$1:
                this.scanner.next();
                break;

            case COMMERCIALAT$1:
                children.appendData(this.Atrule());
                break;

            default:
                children.appendData(defaultConsumer.call(this));
        }
    }

    this.scanner.eat(RIGHTCURLYBRACKET$1);

    return {
        type: 'Block',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
    };
};

var TYPE$9 = index$1.TYPE;
var LEFTSQUAREBRACKET$2 = TYPE$9.LeftSquareBracket;
var RIGHTSQUAREBRACKET$1 = TYPE$9.RightSquareBracket;

// currently only Grid Layout uses square brackets, but left it universal
// https://drafts.csswg.org/css-grid/#track-sizing
// [ ident* ]
var Brackets = function Brackets(readSequence) {
    var start = this.scanner.tokenStart;
    var children = null;

    this.scanner.eat(LEFTSQUAREBRACKET$2);
    children = readSequence.call(this);
    this.scanner.eat(RIGHTSQUAREBRACKET$1);

    return {
        type: 'Brackets',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
    };
};

var TYPE$10 = index$1.TYPE;
var IDENTIFIER$6 = TYPE$10.Identifier;
var FULLSTOP$3 = TYPE$10.FullStop;

// '.' ident
var ClassSelector = function ClassSelector() {
    this.scanner.eat(FULLSTOP$3);

    return {
        type: 'ClassSelector',
        loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
        name: this.scanner.consume(IDENTIFIER$6)
    };
};

var TYPE$11 = index$1.TYPE;

var PLUSSIGN$4 = TYPE$11.PlusSign;
var SOLIDUS$1 = TYPE$11.Solidus;
var GREATERTHANSIGN$1 = TYPE$11.GreaterThanSign;
var TILDE$2 = TYPE$11.Tilde;

// + | > | ~ | /deep/
var Combinator = function Combinator() {
    var start = this.scanner.tokenStart;

    switch (this.scanner.tokenType) {
        case GREATERTHANSIGN$1:
        case PLUSSIGN$4:
        case TILDE$2:
            this.scanner.next();
            break;

        case SOLIDUS$1:
            this.scanner.next();
            this.scanner.expectIdentifier('deep');
            this.scanner.eat(SOLIDUS$1);
            break;

        default:
            this.scanner.error('Combinator is expected');
    }

    return {
        type: 'Combinator',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
};

var TYPE$12 = index$1.TYPE;

var ASTERISK$2 = TYPE$12.Asterisk;
var SOLIDUS$2 = TYPE$12.Solidus;

// '/*' .* '*/'
var Comment = function Comment() {
    var start = this.scanner.tokenStart;
    var end = this.scanner.tokenEnd;

    if ((end - start + 2) >= 2 &&
        this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
        this.scanner.source.charCodeAt(end - 1) === SOLIDUS$2) {
        end -= 2;
    }

    this.scanner.next();

    return {
        type: 'Comment',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.source.substring(start + 2, end)
    };
};

var TYPE$13 = index$1.TYPE;

var IDENTIFIER$7 = TYPE$13.Identifier;
var COLON$2 = TYPE$13.Colon;
var EXCLAMATIONMARK = TYPE$13.ExclamationMark;
var SOLIDUS$3 = TYPE$13.Solidus;
var ASTERISK$3 = TYPE$13.Asterisk;
var DOLLARSIGN$1 = TYPE$13.DollarSign;
var HYPHENMINUS$4 = TYPE$13.HyphenMinus;
var SEMICOLON$2 = TYPE$13.Semicolon;
var RIGHTCURLYBRACKET$2 = TYPE$13.RightCurlyBracket;
var RIGHTPARENTHESIS = TYPE$13.RightParenthesis;
var BALANCED$1 = true;

function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0;

    // hacks
    switch (this.scanner.tokenType) {
        case ASTERISK$3:
        case DOLLARSIGN$1:
            prefix = 1;
            break;

        // TODO: not sure we should support this hack
        case SOLIDUS$3:
            prefix = this.scanner.lookupType(1) === SOLIDUS$3 ? 2 : 1;
            break;
    }

    if (this.scanner.lookupType(prefix) === HYPHENMINUS$4) {
        prefix++;
    }

    if (prefix) {
        this.scanner.skip(prefix);
    }

    this.scanner.eat(IDENTIFIER$7);

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.scanner.eat(EXCLAMATIONMARK);
    this.readSC();

    this.scanner.expectIdentifier('important');

    // should return identifier in future for original source restoring as is
    // returns true for now since it's fit to optimizer purposes
    return true;
}

function isCustomProperty(name) {
    return name.length >= 2 &&
           name.charCodeAt(0) === HYPHENMINUS$4 &&
           name.charCodeAt(1) === HYPHENMINUS$4;
}

var Declaration = function Declaration() {
    var start = this.scanner.tokenStart;
    var property = readProperty.call(this);
    var important = false;
    var value;

    this.readSC();
    this.scanner.eat(COLON$2);

    if (isCustomProperty(property) ? this.parseCustomProperty : this.parseValue) {
        value = this.Value(property);
    } else {
        value = this.Raw(BALANCED$1, SEMICOLON$2, EXCLAMATIONMARK);
    }

    if (this.scanner.tokenType === EXCLAMATIONMARK) {
        important = getImportant.call(this);
        this.readSC();
    }

    // TODO: include or not to include semicolon to range?
    // if (this.scanner.tokenType === SEMICOLON) {
    //     this.scanner.next();
    // }

    if (!this.scanner.eof &&
        this.scanner.tokenType !== SEMICOLON$2 &&
        this.scanner.tokenType !== RIGHTPARENTHESIS &&
        this.scanner.tokenType !== RIGHTCURLYBRACKET$2) {
        this.scanner.error();
    }

    return {
        type: 'Declaration',
        loc: this.getLocation(start, this.scanner.tokenStart),
        important: important,
        property: property,
        value: value
    };
};

var List$4 = list;
var TYPE$14 = index$1.TYPE;

var WHITESPACE$5 = TYPE$14.Whitespace;
var COMMENT$5 = TYPE$14.Comment;
var SEMICOLON$3 = TYPE$14.Semicolon;

var DeclarationList = function DeclarationList() {
    var children = new List$4();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE$5:
            case COMMENT$5:
            case SEMICOLON$3:
                this.scanner.next();
                break;

            default:
                children.appendData(this.Declaration());
        }
    }

    return {
        type: 'DeclarationList',
        loc: this.getLocationFromList(children),
        children: children
    };
};

var NUMBER$4 = index$1.TYPE.Number;

// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
function readUnit(scanner) {
    var unit = scanner.getTokenValue();
    var backSlashPos = unit.indexOf('\\');

    if (backSlashPos !== -1) {
        // patch token offset
        scanner.tokenStart += backSlashPos;

        // return part before backslash
        return unit.substring(0, backSlashPos);
    }

    // no backslash in unit name
    scanner.next();

    return unit;
}

// number ident
var Dimention = function Dimension() {
    var start = this.scanner.tokenStart;
    var value = this.scanner.consume(NUMBER$4);
    var unit = readUnit(this.scanner);

    return {
        type: 'Dimension',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: value,
        unit: unit
    };
};

var TYPE$15 = index$1.TYPE;

var IDENTIFIER$8 = TYPE$15.Identifier;
var LEFTPARENTHESIS$1 = TYPE$15.LeftParenthesis;
var RIGHTPARENTHESIS$1 = TYPE$15.RightParenthesis;

// ident '(' <sequence> ')'
var _Function = function Function(scope, readSequence) {
    var start = this.scanner.tokenStart;
    var name = this.scanner.consume(IDENTIFIER$8);
    var nameLowerCase = name.toLowerCase();
    var children;

    this.scanner.eat(LEFTPARENTHESIS$1);

    children = scope.hasOwnProperty(nameLowerCase)
        ? scope[nameLowerCase].call(this, scope, start, readSequence)
        : readSequence.call(this, scope);

    this.scanner.eat(RIGHTPARENTHESIS$1);

    return {
        type: 'Function',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        children: children
    };
};

var isNumber$3 = index$1.isNumber;
var TYPE$16 = index$1.TYPE;

var IDENTIFIER$9 = TYPE$16.Identifier;
var NUMBER$5 = TYPE$16.Number;
var NUMBERSIGN$1 = TYPE$16.NumberSign;
var PLUSSIGN$5 = TYPE$16.PlusSign;
var HYPHENMINUS$5 = TYPE$16.HyphenMinus;
var FULLSTOP$4 = TYPE$16.FullStop;

// # ident
var HexColor = function HexColor() {
    var start = this.scanner.tokenStart;

    this.scanner.eat(NUMBERSIGN$1);

    scan:
    switch (this.scanner.tokenType) {
        case NUMBER$5:
            if (!isNumber$3(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
                this.scanner.error('Unexpected input', this.scanner.tokenStart);
            }

            for (var pos = this.scanner.tokenStart + 1; pos < this.scanner.tokenEnd; pos++) {
                var code = this.scanner.source.charCodeAt(pos);

                // break on fullstop or hyperminus/plussign after exponent
                if (code === FULLSTOP$4 || code === HYPHENMINUS$5 || code === PLUSSIGN$5) {
                    // break token, exclude symbol
                    this.scanner.tokenStart = pos;
                    break scan;
                }
            }

            // number contains digits only, go to next token
            this.scanner.next();

            // if next token is identifier add it to result
            // TODO: consume hex only
            if (this.scanner.tokenType === IDENTIFIER$9) {
                this.scanner.next();
            }

            break;

        case IDENTIFIER$9:
            // TODO: consume hex only
            this.scanner.next(); // add token to result
            break;

        default:
            this.scanner.error('Number or identifier is expected');
    }

    return {
        type: 'HexColor',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start + 1) // skip #
    };
};

var TYPE$17 = index$1.TYPE;
var IDENTIFIER$10 = TYPE$17.Identifier;

var Identifier = function Identifier() {
    return {
        type: 'Identifier',
        loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        name: this.scanner.consume(IDENTIFIER$10)
    };
};

var TYPE$18 = index$1.TYPE;
var IDENTIFIER$11 = TYPE$18.Identifier;
var NUMBERSIGN$2 = TYPE$18.NumberSign;

// '#' ident
var IdSelector = function IdSelector() {
    this.scanner.eat(NUMBERSIGN$2);

    return {
        type: 'IdSelector',
        loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
        name: this.scanner.consume(IDENTIFIER$11)
    };
};

var TYPE$19 = index$1.TYPE;

var IDENTIFIER$12 = TYPE$19.Identifier;
var NUMBER$6 = TYPE$19.Number;
var LEFTPARENTHESIS$2 = TYPE$19.LeftParenthesis;
var RIGHTPARENTHESIS$2 = TYPE$19.RightParenthesis;
var COLON$3 = TYPE$19.Colon;
var SOLIDUS$4 = TYPE$19.Solidus;

var MediaFeature = function MediaFeature() {
    var start = this.scanner.tokenStart;
    var name;
    var value = null;

    this.scanner.eat(LEFTPARENTHESIS$2);
    this.readSC();

    name = this.scanner.consume(IDENTIFIER$12);
    this.readSC();

    if (this.scanner.tokenType !== RIGHTPARENTHESIS$2) {
        this.scanner.eat(COLON$3);
        this.readSC();

        switch (this.scanner.tokenType) {
            case NUMBER$6:
                if (this.scanner.lookupType(1) === IDENTIFIER$12) {
                    value = this.Dimension();
                } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$4) {
                    value = this.Ratio();
                } else {
                    value = this.Number();
                }

                break;

            case IDENTIFIER$12:
                value = this.Identifier();

                break;

            default:
                this.scanner.error('Number, dimension, ratio or identifier is expected');
        }

        this.readSC();
    }

    this.scanner.eat(RIGHTPARENTHESIS$2);

    return {
        type: 'MediaFeature',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        value: value
    };
};

var List$5 = list;
var TYPE$20 = index$1.TYPE;

var WHITESPACE$6 = TYPE$20.Whitespace;
var COMMENT$6 = TYPE$20.Comment;
var IDENTIFIER$13 = TYPE$20.Identifier;
var LEFTPARENTHESIS$3 = TYPE$20.LeftParenthesis;

var MediaQuery = function MediaQuery() {
    this.readSC();

    var children = new List$5();
    var child = null;
    var space = null;

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT$6:
                this.scanner.next();
                continue;

            case WHITESPACE$6:
                space = this.WhiteSpace();
                continue;

            case IDENTIFIER$13:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS$3:
                child = this.MediaFeature();
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.appendData(space);
            space = null;
        }

        children.appendData(child);
    }

    if (child === null) {
        this.scanner.error('Identifier or parenthesis is expected');
    }

    return {
        type: 'MediaQuery',
        loc: this.getLocationFromList(children),
        children: children
    };
};

var List$6 = list;
var COMMA$1 = index$1.TYPE.Comma;

var MediaQueryList = function MediaQueryList(relative) {
    var children = new List$6();

    this.readSC();

    while (!this.scanner.eof) {
        children.appendData(this.MediaQuery(relative));

        if (this.scanner.tokenType !== COMMA$1) {
            break;
        }

        this.scanner.next();
    }

    return {
        type: 'MediaQueryList',
        loc: this.getLocationFromList(children),
        children: children
    };
};

// https://drafts.csswg.org/css-syntax-3/#the-anb-type
var Nth = function Nth(allowOfClause) {
    this.readSC();

    var start = this.scanner.tokenStart;
    var end = start;
    var selector = null;
    var query;

    if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
        query = this.Identifier();
    } else {
        query = this.AnPlusB();
    }

    this.readSC();

    if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
        this.scanner.next();

        selector = this.SelectorList();

        if (this.needPositions) {
            end = selector.children.last().loc.end.offset;
        }
    } else {
        if (this.needPositions) {
            end = query.loc.end.offset;
        }
    }

    return {
        type: 'Nth',
        loc: this.getLocation(start, end),
        nth: query,
        selector: selector
    };
};

var NUMBER$7 = index$1.TYPE.Number;

var _Number = function Number() {
    return {
        type: 'Number',
        loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        value: this.scanner.consume(NUMBER$7)
    };
};

// '/' | '*' | ',' | ':' | '+' | '-'
var Operator = function Operator() {
    var start = this.scanner.tokenStart;

    this.scanner.next();

    return {
        type: 'Operator',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start)
    };
};

var TYPE$21 = index$1.TYPE;
var LEFTPARENTHESIS$4 = TYPE$21.LeftParenthesis;
var RIGHTPARENTHESIS$3 = TYPE$21.RightParenthesis;

var Parentheses = function Parentheses(readSequence) {
    var start = this.scanner.tokenStart;
    var children = null;

    this.scanner.eat(LEFTPARENTHESIS$4);
    children = readSequence.call(this);
    this.scanner.eat(RIGHTPARENTHESIS$3);

    return {
        type: 'Parentheses',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
    };
};

var TYPE$22 = index$1.TYPE;

var NUMBER$8 = TYPE$22.Number;
var PERCENTSIGN$1 = TYPE$22.PercentSign;

var Percentage = function Percentage() {
    var start = this.scanner.tokenStart;
    var number = this.scanner.consume(NUMBER$8);

    this.scanner.eat(PERCENTSIGN$1);

    return {
        type: 'Percentage',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: number
    };
};

var List$7 = list;
var TYPE$23 = index$1.TYPE;

var IDENTIFIER$14 = TYPE$23.Identifier;
var COLON$4 = TYPE$23.Colon;
var LEFTPARENTHESIS$5 = TYPE$23.LeftParenthesis;
var RIGHTPARENTHESIS$4 = TYPE$23.RightParenthesis;
var BALANCED$2 = true;

// : ident [ '(' .. ')' ]?
var PseudoClassSelector = function PseudoClassSelector() {
    var start = this.scanner.tokenStart;
    var name;
    var children = null;

    this.scanner.eat(COLON$4);

    name = this.scanner.consume(IDENTIFIER$14);

    if (this.scanner.tokenType === LEFTPARENTHESIS$5) {
        var nameLowerCase = name.toLowerCase();

        this.scanner.next();

        if (this.pseudo.hasOwnProperty(nameLowerCase)) {
            this.readSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.readSC();
        } else {
            children = new List$7().appendData(this.Raw(BALANCED$2, 0, 0));
        }

        this.scanner.eat(RIGHTPARENTHESIS$4);
    }

    return {
        type: 'PseudoClassSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        children: children
    };
};

var List$8 = list;
var TYPE$24 = index$1.TYPE;

var IDENTIFIER$15 = TYPE$24.Identifier;
var COLON$5 = TYPE$24.Colon;
var LEFTPARENTHESIS$6 = TYPE$24.LeftParenthesis;
var RIGHTPARENTHESIS$5 = TYPE$24.RightParenthesis;
var BALANCED$3 = true;

// :: ident [ '(' .. ')' ]?
var PseudoElementSelector = function PseudoElementSelector() {
    var start = this.scanner.tokenStart;
    var name;
    var children = null;

    this.scanner.eat(COLON$5);
    this.scanner.eat(COLON$5);

    name = this.scanner.consume(IDENTIFIER$15);

    if (this.scanner.tokenType === LEFTPARENTHESIS$6) {
        var nameLowerCase = name.toLowerCase();

        this.scanner.next();

        if (this.pseudo.hasOwnProperty(nameLowerCase)) {
            this.readSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.readSC();
        } else {
            children = new List$8().appendData(this.Raw(BALANCED$3, 0, 0));
        }

        this.scanner.eat(RIGHTPARENTHESIS$5);
    }

    return {
        type: 'PseudoElementSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: name,
        children: children
    };
};

var isNumber$4 = index$1.isNumber;
var TYPE$25 = index$1.TYPE;
var NUMBER$9 = TYPE$25.Number;
var SOLIDUS$5 = TYPE$25.Solidus;

function readPositiveInteger(scanner) {
    var value = scanner.consumeNonWS(NUMBER$9);

    for (var i = 0; i < value.length; i++) {
        if (!isNumber$4(value.charCodeAt(i))) {
            scanner.error('Positive integer is expected', scanner.tokenStart - value.length + i);
        }
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
var Ratio = function Ratio() {
    var start = this.scanner.tokenStart;
    var left = readPositiveInteger(this.scanner);
    var right;

    this.scanner.eatNonWS(SOLIDUS$5);
    right = readPositiveInteger(this.scanner);

    return {
        type: 'Ratio',
        loc: this.getLocation(start, this.scanner.tokenStart),
        left: left,
        right: right
    };
};

var TYPE$26 = index$1.TYPE;

var WHITESPACE$7 = TYPE$26.Whitespace;
var LEFTPARENTHESIS$7 = TYPE$26.LeftParenthesis;
var RIGHTPARENTHESIS$6 = TYPE$26.RightParenthesis;
var LEFTCURLYBRACKET$2 = TYPE$26.LeftCurlyBracket;
var RIGHTCURLYBRACKET$3 = TYPE$26.RightCurlyBracket;
var LEFTSQUAREBRACKET$3 = TYPE$26.LeftSquareBracket;
var RIGHTSQUAREBRACKET$2 = TYPE$26.RightSquareBracket;

var Raw = function Raw(balanced, endTokenType1, endTokenType2) {
    var start = this.scanner.tokenStart;
    var stack = [];
    var popType = 0;
    var type = 0;

    if (balanced) {
        scan:
        for (var i = 0; type = this.scanner.lookupType(i); i++) {
            if (popType === 0) {
                if (type === endTokenType1 ||
                    type === endTokenType2) {
                    break scan;
                }
            }

            switch (type) {
                case popType:
                    popType = stack.pop();
                    break;

                case RIGHTPARENTHESIS$6:
                case RIGHTCURLYBRACKET$3:
                case RIGHTSQUAREBRACKET$2:
                    if (popType !== 0) {
                        this.scanner.skip(i);
                        this.scanner.error();
                    }
                    break scan;

                case LEFTPARENTHESIS$7:
                    stack.push(popType);
                    popType = RIGHTPARENTHESIS$6;
                    break;

                case LEFTCURLYBRACKET$2:
                    stack.push(popType);
                    popType = RIGHTCURLYBRACKET$3;
                    break;

                case LEFTSQUAREBRACKET$3:
                    stack.push(popType);
                    popType = RIGHTSQUAREBRACKET$2;
                    break;
            }
        }
    } else {
        for (var i = 0; type = this.scanner.lookupType(i); i++) {
            if (type === WHITESPACE$7 ||
                type === endTokenType1 ||
                type === endTokenType2) {
                break;
            }
        }
    }

    this.scanner.skip(i);

    if (popType !== 0) {
        this.scanner.eat(popType);
    }

    return {
        type: 'Raw',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start)
    };
};

var TYPE$27 = index$1.TYPE;
var LEFTCURLYBRACKET$3 = TYPE$27.LeftCurlyBracket;
var BALANCED$4 = true;

var Rule = function Rule() {
    var start = this.scanner.tokenStart;
    var selector = this.parseSelector ? this.SelectorList() : this.Raw(BALANCED$4, LEFTCURLYBRACKET$3, 0);
    var block = this.Block(this.Declaration);

    return {
        type: 'Rule',
        loc: this.getLocation(start, this.scanner.tokenStart),
        selector: selector,
        block: block
    };
};

var Selector = function Selector() {
    var children = this.readSelectorSequence();

    return {
        type: 'Selector',
        loc: this.getLocationFromList(children),
        children: children
    };
};

var List$9 = list;
var TYPE$28 = index$1.TYPE;

var COMMA$2 = TYPE$28.Comma;
var LEFTCURLYBRACKET$4 = TYPE$28.LeftCurlyBracket;
var BALANCED$5 = true;

var SelectorList = function SelectorList() {
    var children = new List$9();

    while (!this.scanner.eof) {
        children.appendData(this.parseSelector
            ? this.Selector()
            : this.Raw(BALANCED$5, COMMA$2, LEFTCURLYBRACKET$4)
        );

        if (this.scanner.tokenType === COMMA$2) {
            this.scanner.next();
            continue;
        }

        break;
    }

    return {
        type: 'SelectorList',
        loc: this.getLocationFromList(children),
        children: children
    };
};

var STRING$4 = index$1.TYPE.String;

var _String = function String() {
    return {
        type: 'String',
        loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        value: this.scanner.consume(STRING$4)
    };
};

var List$10 = list;
var TYPE$29 = index$1.TYPE;

var WHITESPACE$8 = TYPE$29.Whitespace;
var COMMENT$7 = TYPE$29.Comment;
var EXCLAMATIONMARK$1 = TYPE$29.ExclamationMark;
var COMMERCIALAT$2 = TYPE$29.CommercialAt;

var StyleSheet = function StyleSheet() {
    var start = this.scanner.tokenStart;
    var children = new List$10();
    var child;

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE$8:
                this.scanner.next();
                continue;

            case COMMENT$7:
                // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$1) {
                    this.scanner.next();
                    continue;
                }

                child = this.Comment();
                break;

            case COMMERCIALAT$2:
                child = this.Atrule();
                break;

            default:
                child = this.Rule();
        }

        children.appendData(child);
    }

    return {
        type: 'StyleSheet',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
    };
};

var TYPE$30 = index$1.TYPE;

var IDENTIFIER$16 = TYPE$30.Identifier;
var ASTERISK$4 = TYPE$30.Asterisk;
var VERTICALLINE$2 = TYPE$30.VerticalLine;

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENTIFIER$16 &&
        this.scanner.tokenType !== ASTERISK$4) {
        this.scanner.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
var TypeSelector = function TypeSelector() {
    var start = this.scanner.tokenStart;

    if (this.scanner.tokenType === VERTICALLINE$2) {
        this.scanner.next();
        eatIdentifierOrAsterisk.call(this);
    } else {
        eatIdentifierOrAsterisk.call(this);

        if (this.scanner.tokenType === VERTICALLINE$2) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        }
    }

    return {
        type: 'TypeSelector',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
};

var isHex$1 = index$1.isHex;
var TYPE$31 = index$1.TYPE;

var IDENTIFIER$17 = TYPE$31.Identifier;
var NUMBER$10 = TYPE$31.Number;
var PLUSSIGN$6 = TYPE$31.PlusSign;
var HYPHENMINUS$6 = TYPE$31.HyphenMinus;
var FULLSTOP$5 = TYPE$31.FullStop;
var QUESTIONMARK = TYPE$31.QuestionMark;

function scanUnicodeNumber(scanner) {
    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on fullstop or hyperminus/plussign after exponent
        if (code === FULLSTOP$5 || code === PLUSSIGN$6) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return false;
        }
    }

    return true;
}

// https://drafts.csswg.org/css-syntax-3/#urange
function scanUnicodeRange(scanner) {
    var hexStart = scanner.tokenStart + 1; // skip +
    var hexLength = 0;

    scan: {
        if (scanner.tokenType === NUMBER$10) {
            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$5 && scanUnicodeNumber(scanner)) {
                scanner.next();
            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$6) {
                break scan;
            }
        } else {
            scanner.next(); // PLUSSIGN
        }

        if (scanner.tokenType === HYPHENMINUS$6) {
            scanner.next();
        }

        if (scanner.tokenType === NUMBER$10) {
            scanner.next();
        }

        if (scanner.tokenType === IDENTIFIER$17) {
            scanner.next();
        }

        if (scanner.tokenStart === hexStart) {
            scanner.error('Unexpected input', hexStart);
        }
    }

    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
    // where x is [0-9a-fA-F]
    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
        var code = scanner.source.charCodeAt(i);

        if (isHex$1(code) === false && (code !== HYPHENMINUS$6 || wasHyphenMinus)) {
            scanner.error('Unexpected input', i);
        }

        if (code === HYPHENMINUS$6) {
            // hex sequence shouldn't be an empty
            if (hexLength === 0) {
                scanner.error('Unexpected input', i);
            }

            wasHyphenMinus = true;
            hexLength = 0;
        } else {
            hexLength++;

            // too long hex sequence
            if (hexLength > 6) {
                scanner.error('Too long hex sequence', i);
            }
        }

    }

    // check we have a non-zero sequence
    if (hexLength === 0) {
        scanner.error('Unexpected input', i - 1);
    }

    // U+abc???
    if (!wasHyphenMinus) {
        // consume as many U+003F QUESTION MARK (?) code points as possible
        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
            if (scanner.tokenType !== QUESTIONMARK) {
                break;
            }

            hexLength++;
        }
    }
}

var UnicodeRange = function UnicodeRange() {
    var start = this.scanner.tokenStart;

    this.scanner.next(); // U or u
    scanUnicodeRange(this.scanner);

    return {
        type: 'UnicodeRange',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: this.scanner.substrToCursor(start)
    };
};

var TYPE$32 = index$1.TYPE;

var STRING$5 = TYPE$32.String;
var LEFTPARENTHESIS$8 = TYPE$32.LeftParenthesis;
var RIGHTPARENTHESIS$7 = TYPE$32.RightParenthesis;
var NONBALANCED = false;

// url '(' S* (string | raw) S* ')'
var Url = function Url() {
    var start = this.scanner.tokenStart;
    var value;

    this.scanner.expectIdentifier('url');
    this.scanner.eat(LEFTPARENTHESIS$8);
    this.readSC();

    if (this.scanner.tokenType === STRING$5) {
        value = this.String();
    } else {
        value = this.Raw(NONBALANCED, LEFTPARENTHESIS$8, RIGHTPARENTHESIS$7);
    }

    this.readSC();
    this.scanner.eat(RIGHTPARENTHESIS$7);

    return {
        type: 'Url',
        loc: this.getLocation(start, this.scanner.tokenStart),
        value: value
    };
};

var endsWith$1 = index$1.endsWith;
var TYPE$33 = index$1.TYPE;

var WHITESPACE$9 = TYPE$33.Whitespace;
var COMMENT$8 = TYPE$33.Comment;
var LEFTPARENTHESIS$9 = TYPE$33.LeftParenthesis;
var COLON$6 = TYPE$33.Colon;
var SEMICOLON$4 = TYPE$33.Semicolon;
var EXCLAMATIONMARK$2 = TYPE$33.ExclamationMark;
var BALANCED$6 = true;

var Value = function Value(property) {
    // special parser for filter property since it can contains non-standart syntax for old IE
    if (property !== null && endsWith$1(property, 'filter') && checkProgid(this.scanner)) {
        this.readSC();
        return this.Raw(BALANCED$6, SEMICOLON$4, EXCLAMATIONMARK$2);
    }

    var start = this.scanner.tokenStart;
    var children = this.readSequence(this.scopeValue);

    return {
        type: 'Value',
        loc: this.getLocation(start, this.scanner.tokenStart),
        children: children
    };
};

// 'progid:' ws* 'DXImageTransform.Microsoft.' ident ws* '(' .* ')'
function checkProgid(scanner) {
    var offset = 0;

    for (var type; type = scanner.lookupType(offset); offset++) {
        if (type !== WHITESPACE$9 && type !== COMMENT$8) {
            break;
        }
    }

    if (scanner.lookupValue(offset, 'alpha') ||
        scanner.lookupValue(offset, 'dropshadow')) {
        if (scanner.lookupType(offset + 1) !== LEFTPARENTHESIS$9) {
            return false;
        }
    } else {
        if (scanner.lookupValue(offset, 'progid') === false ||
            scanner.lookupType(offset + 1) !== COLON$6) {
            return false;
        }
    }

    return true;
}

var WHITESPACE$10 = index$1.TYPE.Whitespace;
var SPACE$2 = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

var WhiteSpace = function WhiteSpace() {
    this.scanner.eat(WHITESPACE$10);
    return SPACE$2;

    // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
    //     value: this.scanner.consume(WHITESPACE)
    // };
};

var List$11 = list;

// https://drafts.csswg.org/css-images-4/#element-notation
// https://developer.mozilla.org/en-US/docs/Web/CSS/element
var element = function() {
    this.readSC();

    var id = this.IdSelector();

    this.readSC();

    return new List$11().appendData(
        id
    );
};

var List$12 = list;
var BALANCED$7 = true;

// legacy IE function
// expression '(' raw ')'
var expression = function getOldIEExpression() {
    return new List$12().appendData(
        this.Raw(BALANCED$7, 0, 0)
    );
};

var List$13 = list;
var TYPE$34 = index$1.TYPE;

var IDENTIFIER$18 = TYPE$34.Identifier;
var COMMA$3 = TYPE$34.Comma;
var HYPHENMINUS$7 = TYPE$34.HyphenMinus;
var EXCLAMATIONMARK$3 = TYPE$34.ExclamationMark;
var BALANCED$8 = true;

// var '(' ident (',' <value>? )? ')'
var _var = function getVarFunction() {
    var children = new List$13();

    this.readSC();

    var identStart = this.scanner.tokenStart;

    this.scanner.eat(HYPHENMINUS$7);
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$7) {
        this.scanner.error('HyphenMinus is expected');
    }
    this.scanner.eat(IDENTIFIER$18);

    children.appendData({
        type: 'Identifier',
        loc: this.getLocation(identStart, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(identStart)
    });

    this.readSC();

    if (this.scanner.tokenType === COMMA$3) {
        children.appendData(this.Operator());
        children.appendData(this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(BALANCED$8, HYPHENMINUS$7, EXCLAMATIONMARK$3)
        );
    }

    return children;
};

var List$14 = list;
var TYPE$35 = index$1.TYPE;

var STRING$6 = TYPE$35.String;
var IDENTIFIER$19 = TYPE$35.Identifier;
var LEFTPARENTHESIS$10 = TYPE$35.LeftParenthesis;

var _import = {
    expression: function() {
        var children = new List$14();

        this.readSC();

        switch (this.scanner.tokenType) {
            case STRING$6:
                children.appendData(this.String());
                break;

            case IDENTIFIER$19:
                children.appendData(this.Url());
                break;

            default:
                this.scanner.error('String or url() is expected');
        }

        if (this.scanner.lookupNonWSType(0) === IDENTIFIER$19 ||
            this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$10) {
            children.appendData(this.WhiteSpace());
            children.appendData(this.MediaQueryList());
        }

        return children;
    },
    block: false
};

var media = {
    expression: function() {
        return this.MediaQueryList();
    },
    block: function() {
        return this.Block(this.Rule);
    }
};

var TYPE$36 = index$1.TYPE;
var LEFTCURLYBRACKET$5 = TYPE$36.LeftCurlyBracket;

var page = {
    expression: function() {
        if (this.scanner.lookupNonWSType(0) === LEFTCURLYBRACKET$5) {
            return null;
        }

        return this.SelectorList();
    },
    block: function() {
        return this.Block(this.Declaration);
    }
};

var List$15 = list;
var TYPE$37 = index$1.TYPE;

var WHITESPACE$11 = TYPE$37.Whitespace;
var COMMENT$9 = TYPE$37.Comment;
var IDENTIFIER$20 = TYPE$37.Identifier;
var LEFTPARENTHESIS$11 = TYPE$37.LeftParenthesis;
var HYPHENMINUS$8 = TYPE$37.HyphenMinus;
var COLON$7 = TYPE$37.Colon;
var BALANCED$9 = true;

function readRaw() {
    return new List$15().appendData(
        this.Raw(BALANCED$9, 0, 0)
    );
}

function parentheses() {
    var index = 0;

    this.readSC();

    // TODO: make it simplier
    if (this.scanner.tokenType === IDENTIFIER$20) {
        index = 1;
    } else if (this.scanner.tokenType === HYPHENMINUS$8 &&
               this.scanner.lookupType(1) === IDENTIFIER$20) {
        index = 2;
    }

    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$7) {
        return new List$15().appendData(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = new List$15();
    var space = null;
    var child;

    this.readSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE$11:
                space = this.WhiteSpace();
                continue;

            case COMMENT$9:
                this.scanner.next();
                continue;

            case IDENTIFIER$20:
                if (this.scanner.lookupType(1) === LEFTPARENTHESIS$11) {
                    child = this.Function(this.scopeAtruleExpression, readRaw);
                } else {
                    child = this.Identifier();
                }

                break;

            case LEFTPARENTHESIS$11:
                child = this.Parentheses(parentheses);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.appendData(space);
            space = null;
        }

        children.appendData(child);
    }

    return children;
}

var supports = {
    expression: function() {
        var children = readSequence.call(this);

        if (children.isEmpty()) {
            this.scanner.error('Condition is expected');
        }

        return children;
    },
    block: function() {
        return this.Block(this.Rule);
    }
};

var Tokenizer = index$1;

var TYPE = Tokenizer.TYPE;
var WHITESPACE = TYPE.Whitespace;
var COMMENT = TYPE.Comment;

var sequence = sequence$1;
var getAnPlusB = AnPlusB;
var getAtrule = Atrule;
var getAtruleExpression = AtruleExpression;
var getAttributeSelector = AttributeSelector;
var getBlock = Block;
var getBrackets = Brackets;
var getClassSelector = ClassSelector;
var getCombinator = Combinator;
var getComment = Comment;
var getDeclaration = Declaration;
var getDeclarationList = DeclarationList;
var getDimension = Dimention;
var getFunction = _Function;
var getHexColor = HexColor;
var getIdentifier = Identifier;
var getIdSelector = IdSelector;
var getMediaFeature = MediaFeature;
var getMediaQuery = MediaQuery;
var getMediaQueryList = MediaQueryList;
var getNth = Nth;
var getNumber = _Number;
var getOperator = Operator;
var getParentheses = Parentheses;
var getPercentage = Percentage;
var getPseudoClassSelector = PseudoClassSelector;
var getPseudoElementSelector = PseudoElementSelector;
var getRatio = Ratio;
var getRaw = Raw;
var getRule = Rule;
var getSelector = Selector;
var getSelectorList = SelectorList;
var getString = _String;
var getStyleSheet = StyleSheet;
var getTypeSelector = TypeSelector;
var getUnicodeRange = UnicodeRange;
var getUrl = Url;
var getValue = Value;
var getWhiteSpace = WhiteSpace;

function readSC() {
    while (this.scanner.tokenType === WHITESPACE || this.scanner.tokenType === COMMENT) {
        this.scanner.next();
    }
}

var Parser$2 = function() {
    this.scanner = new Tokenizer();
    this.filename = '<unknown>';
    this.needPositions = false;
};

Parser$2.prototype = {
    scanner: null,
    filename: '<unknown>',
    needPositions: false,
    parseAtruleExpression: true,
    parseSelector: true,
    parseValue: true,
    parseCustomProperty: false,

    scopeAtruleExpression: {},
    scopeValue: {
        '-moz-element': element,
        'element': element,
        'expression': expression,
        'var': _var
    },
    atrule: {
        'import': _import,
        'media': media,
        'page': page,
        'supports': supports
    },
    pseudo: {
        'lang': sequence.singleIdentifier,
        'dir': sequence.singleIdentifier,
        'not': sequence.selectorList,
        'matches': sequence.selectorList,
        'has': sequence.selectorList,
        'nth-child': sequence.nthWithOfClause,
        'nth-last-child': sequence.nthWithOfClause,
        'nth-of-type': sequence.nth,
        'nth-last-of-type': sequence.nth,
        'slotted': sequence.compoundSelector
    },
    context: {
        stylesheet: getStyleSheet,
        atrule: getAtrule,
        atruleExpression: getAtruleExpression,
        rule: getRule,
        selectorList: getSelectorList,
        selector: getSelector,
        block: getBlock,
        declarationList: getDeclarationList,
        declaration: getDeclaration,
        value: getValue
    },

    // consumers
    AnPlusB: getAnPlusB,
    Atrule: getAtrule,
    AtruleExpression: getAtruleExpression,
    AttributeSelector: getAttributeSelector,
    Block: getBlock,
    Brackets: getBrackets,
    ClassSelector: getClassSelector,
    Combinator: getCombinator,
    Comment: getComment,
    Declaration: getDeclaration,
    DeclarationList: getDeclarationList,
    Dimension: getDimension,
    Function: getFunction,
    HexColor: getHexColor,
    Identifier: getIdentifier,
    IdSelector: getIdSelector,
    MediaFeature: getMediaFeature,
    MediaQuery: getMediaQuery,
    MediaQueryList: getMediaQueryList,
    Nth: getNth,
    Number: getNumber,
    Operator: getOperator,
    Parentheses: getParentheses,
    Percentage: getPercentage,
    PseudoClassSelector: getPseudoClassSelector,
    PseudoElementSelector: getPseudoElementSelector,
    Ratio: getRatio,
    Raw: getRaw,
    Rule: getRule,
    Selector: getSelector,
    SelectorList: getSelectorList,
    String: getString,
    StyleSheet: getStyleSheet,
    TypeSelector: getTypeSelector,
    UnicodeRange: getUnicodeRange,
    Url: getUrl,
    Value: getValue,
    WhiteSpace: getWhiteSpace,

    readSC: readSC,
    readSelectorSequence: sequence.selector,
    readSelectorSequenceFallback: null,
    readSequence: sequence.default,
    readSequenceFallback: null,

    getLocation: function(start, end) {
        if (this.needPositions) {
            return this.scanner.getLocationRange(
                start,
                end,
                this.filename
            );
        }

        return null;
    },
    getLocationFromList: function(list) {
        if (this.needPositions) {
            return this.scanner.getLocationRange(
                list.head !== null ? list.first().loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
                list.head !== null ? list.last().loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
                this.filename
            );
        }

        return null;
    },

    parse: function(source, options) {
        options = options || {};

        var context = options.context || 'stylesheet';
        var ast;

        this.scanner.setSource(source, options.offset, options.line, options.column);
        this.filename = options.filename || '<unknown>';
        this.needPositions = Boolean(options.positions);
        this.parseAtruleExpression = 'parseAtruleExpression' in options ? Boolean(options.parseAtruleExpression) : true;
        this.parseSelector = 'parseSelector' in options ? Boolean(options.parseSelector) : true;
        this.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        this.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        switch (context) {
            case 'value':
                ast = this.Value(options.property ? String(options.property) : null);
                break;

            case 'atruleExpression':
                ast = this.AtruleExpression(options.atrule ? String(options.atrule) : null);
                break;

            default:
                if (!this.context.hasOwnProperty(context)) {
                    throw new Error('Unknown context `' + context + '`');
                }

                ast = this.context[context].call(this);
        }

        if (!this.scanner.eof) {
            this.scanner.error();
        }

        // console.log(JSON.stringify(ast, null, 4));
        return ast;
    }
};

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
new Parser$2().parse(
    'a.b#c:e:Not(a/**/):AFTER:Nth-child(2n+1)::g::slotted(a/**/),* b >c+d~e/deep/f,100%{' +
    'v:U+123 1 2em t a(2%, var(--a)) -b() url(..) -foo-bar !important}'
);

var Parser_1 = Parser$2;

var Parser$1 = Parser_1;
var parser = new Parser$1();

var index = parser.parse.bind(parser);

function walkRules(node, item, list) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.children.each(walkRules, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.block !== null) {
                walkRules.call(this, node.block);
            }

            this.fn(node, item, list);
            break;

        case 'Rule':
            this.fn(node, item, list);

            var oldRule = this.rule;
            this.rule = node;

            walkRules.call(this, node.block);

            this.rule = oldRule;
            break;

        case 'Block':
            var oldBlock = this.block;
            this.block = node;

            node.children.each(walkRules, this);

            this.block = oldBlock;
            break;
    }

}

function walkRulesRight(node, item, list) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.children.eachRight(walkRulesRight, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.block !== null) {
                walkRulesRight.call(this, node.block);
            }

            this.fn(node, item, list);
            break;

        case 'Rule':
            var oldRule = this.rule;
            this.rule = node;

            walkRulesRight.call(this, node.block);

            this.rule = oldRule;

            this.fn(node, item, list);
            break;

        case 'Block':
            var oldBlock = this.block;
            this.block = node;

            node.children.eachRight(walkRulesRight, this);

            this.block = oldBlock;
            break;
    }
}

function walkDeclarations(node) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.children.each(walkDeclarations, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.block !== null) {
                walkDeclarations.call(this, node.block);
            }
            break;

        case 'Rule':
            var oldRule = this.rule;
            this.rule = node;

            if (node.block !== null) {
                walkDeclarations.call(this, node.block);
            }

            this.rule = oldRule;
            break;

        case 'Block':
            node.children.each(function(node, item, list) {
                if (node.type === 'Declaration') {
                    this.fn(node, item, list);
                } else {
                    walkDeclarations.call(this, node);
                }
            }, this);
            break;
    }
}

function walkAll(node, item, list) {
    this.fn(node, item, list);
    walk.call(this, walkAll, node, item, list);
}

function walkAllUp(node, item, list) {
    walk.call(this, walkAllUp, node, item, list);
    this.fn(node, item, list);
}

function walk(walk, node) {
    switch (node.type) {
        case 'StyleSheet':
            var oldStylesheet = this.stylesheet;
            this.stylesheet = node;

            node.children.each(walk, this);

            this.stylesheet = oldStylesheet;
            break;

        case 'Atrule':
            if (node.expression !== null) {
                walk.call(this, node.expression);
            }
            if (node.block !== null) {
                walk.call(this, node.block);
            }
            break;

        case 'Rule':
            this.rule = node;

            if (node.selector !== null) {
                walk.call(this, node.selector);
            }
            walk.call(this, node.block);

            this.rule = null;
            break;

        case 'SelectorList':
            var oldSelector = this.selector;
            this.selector = node;

            node.children.each(walk, this);

            this.selector = oldSelector;
            break;

        case 'Selector':
            node.children.each(walk, this);
            break;

        case 'Nth':
            walk.call(this, node.nth);
            if (node.selector !== null) {
                walk.call(this, node.selector);
            }
            break;

        case 'Block':
            var oldBlock = this.block;
            this.block = node;

            node.children.each(walk, this);

            this.block = oldBlock;
            break;

        case 'DeclarationList':
            node.children.each(walk, this);
            break;

        case 'Declaration':
            this.declaration = node;

            walk.call(this, node.value);

            this.declaration = null;
            break;

        case 'AttributeSelector':
            walk.call(this, node.name);
            if (node.value !== null) {
                walk.call(this, node.value);
            }
            break;

        case 'PseudoClassSelector':
            if (node.children !== null) {
                this['function'] = node;

                node.children.each(walk, this);

                this['function'] = null;
            }
            break;

        case 'PseudoElementSelector':
            if (node.children !== null) {
                this['function'] = node;

                node.children.each(walk, this);

                this['function'] = null;
            }
            break;

        case 'Function':
            this['function'] = node;

            node.children.each(walk, this);

            this['function'] = null;
            break;

        case 'AtruleExpression':
            this.atruleExpression = node;

            node.children.each(walk, this);

            this.atruleExpression = null;
            break;

        case 'MediaQueryList':
            node.children.each(walk, this);
            break;

        case 'MediaQuery':
            node.children.each(walk, this);
            break;

        case 'MediaFeature':
            if (node.value !== null) {
                walk.call(this, node.value);
            }
            break;

        case 'Value':
            node.children.each(walk, this);
            break;

        case 'Parentheses':
            node.children.each(walk, this);
            break;

        case 'Brackets':
            node.children.each(walk, this);
            break;

        case 'Url':
            walk.call(this, node.value);
            break;
    }
}

function createContext(root, fn) {
    var context = {
        fn: fn,
        root: root,
        stylesheet: null,
        atruleExpression: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
    };

    return context;
}

var walk_1 = {
    all: function(root, fn) {
        walkAll.call(createContext(root, fn), root);
    },
    allUp: function(root, fn) {
        walkAllUp.call(createContext(root, fn), root);
    },
    rules: function(root, fn) {
        walkRules.call(createContext(root, fn), root);
    },
    rulesRight: function(root, fn) {
        walkRulesRight.call(createContext(root, fn), root);
    },
    declarations: function(root, fn) {
        walkDeclarations.call(createContext(root, fn), root);
    }
};

function readStyle ( parser, start, attributes ) {
	const contentStart = parser.index;
	const styles = parser.readUntil( /<\/style>/ );
	const contentEnd = parser.index;

	let ast;

	try {
		ast = index( styles, {
			positions: true,
			offset: contentStart
		});
	} catch ( err ) {
		if ( err.name === 'CssSyntaxError' ) {
			parser.error( err.message, err.offset );
		} else {
			throw err;
		}
	}

	// tidy up AST
	walk_1.all( ast, node => {
		if ( node.loc ) {
			node.start = node.loc.start.offset;
			node.end = node.loc.end.offset;
			delete node.loc;
		}
	});

	parser.eat( '</style>', true );
	const end = parser.index;

	return {
		start,
		end,
		attributes,
		children: JSON.parse( JSON.stringify( ast.children ) ),
		content: {
			start: contentStart,
			end: contentEnd,
			styles
		}
	};
}

function readExpression$1 ( parser, start, quoteMark ) {
	let str = '';
	let escaped = false;

	for ( let i = start; i < parser.template.length; i += 1 ) {
		const char = parser.template[i];

		if ( quoteMark ) {
			if ( char === quoteMark ) {
				if ( escaped ) {
					str += quoteMark;
				} else {
					break;
				}
			} else if ( escaped ) {
				str += '\\' + char;
				escaped = false;
			} else if ( char === '\\' ) {
				escaped = true;
			} else {
				str += char;
			}
		}

		else if ( /\s/.test( char ) ) {
			break;
		}

		else {
			str += char;
		}
	}

	const expression = parseExpressionAt( spaces( start ) + str, start );
	parser.index = expression.end;

	parser.allowWhitespace();
	if ( quoteMark ) { parser.eat( quoteMark, true ); }

	return expression;
}

function readEventHandlerDirective ( parser, start, name ) {
	const quoteMark = (
		parser.eat( `'` ) ? `'` :
		parser.eat( `"` ) ? `"` :
		null
	);

	const expressionStart = parser.index;

	const expression = readExpression$1( parser, expressionStart, quoteMark );

	if ( expression.type !== 'CallExpression' ) {
		parser.error( `Expected call expression`, expressionStart );
	}

	return {
		start,
		end: parser.index,
		type: 'EventHandler',
		name,
		expression
	};
}

function readBindingDirective ( parser, start, name ) {
	let value;

	if ( parser.eat( '=' ) ) {
		const quoteMark = (
			parser.eat( `'` ) ? `'` :
			parser.eat( `"` ) ? `"` :
			null
		);

		const a = parser.index;

		if ( parser.eat( '{{' ) ) {
			let message = 'bound values should not be wrapped';
			const b = parser.template.indexOf( '}}', a );
			if ( b !== -1 ) {
				const value = parser.template.slice( parser.index, b );
				message += ` — use '${value}', not '{{${value}}}'`;
			}

			parser.error( message, a );
		}

		// this is a bit of a hack so that we can give Acorn something parseable
		let b;
		if ( quoteMark ) {
			b = parser.index = parser.template.indexOf( quoteMark, parser.index );
		} else {
			parser.readUntil( /[\s\r\n\/>]/ );
			b = parser.index;
		}

		const source = spaces( a ) + parser.template.slice( a, b );
		value = parseExpressionAt( source, a );

		if ( value.type !== 'Identifier' && value.type !== 'MemberExpression' ) {
			parser.error( `Expected valid property name` );
		}

		parser.allowWhitespace();

		if ( quoteMark ) {
			parser.eat( quoteMark, true );
		}
	} else {
		// shorthand – bind:foo equivalent to bind:foo='foo'
		value = {
			type: 'Identifier',
			start: start + 5,
			end: parser.index,
			name
		};
	}

	return {
		start,
		end: parser.index,
		type: 'Binding',
		name,
		value
	};
}

function readTransitionDirective ( parser, start, name, type ) {
	let expression = null;

	if ( parser.eat( '=' ) ) {
		const quoteMark = (
			parser.eat( `'` ) ? `'` :
			parser.eat( `"` ) ? `"` :
			null
		);

		const expressionStart = parser.index;

		expression = readExpression$1( parser, expressionStart, quoteMark );

		if ( expression.type !== 'ObjectExpression' ) {
			parser.error( `Expected object expression`, expressionStart );
		}
	}

	return {
		start,
		end: parser.index,
		type: 'Transition',
		name,
		intro: type === 'in' || type === 'transition',
		outro: type === 'out' || type === 'transition',
		expression
	};
}

const whitespace = /[ \t\r\n]/;

function trimStart ( str ) {
	let i = 0;
	while ( whitespace.test( str[i] ) ) { i += 1; }

	return str.slice( i );
}

function trimEnd ( str ) {
	let i = str.length;
	while ( whitespace.test( str[ i - 1 ] ) ) { i -= 1; }

	return str.slice( 0, i );
}

// https://dev.w3.org/html5/html-author/charref
var htmlEntities = {
	CounterClockwiseContourIntegral: 8755,
	ClockwiseContourIntegral: 8754,
	DoubleLongLeftRightArrow: 10234,
	DiacriticalDoubleAcute: 733,
	NotSquareSupersetEqual: 8931,
	CloseCurlyDoubleQuote: 8221,
	DoubleContourIntegral: 8751,
	FilledVerySmallSquare: 9642,
	NegativeVeryThinSpace: 8203,
	NotPrecedesSlantEqual: 8928,
	NotRightTriangleEqual: 8941,
	NotSucceedsSlantEqual: 8929,
	CapitalDifferentialD: 8517,
	DoubleLeftRightArrow: 8660,
	DoubleLongRightArrow: 10233,
	EmptyVerySmallSquare: 9643,
	NestedGreaterGreater: 8811,
	NotDoubleVerticalBar: 8742,
	NotLeftTriangleEqual: 8940,
	NotSquareSubsetEqual: 8930,
	OpenCurlyDoubleQuote: 8220,
	ReverseUpEquilibrium: 10607,
	DoubleLongLeftArrow: 10232,
	DownLeftRightVector: 10576,
	LeftArrowRightArrow: 8646,
	NegativeMediumSpace: 8203,
	RightArrowLeftArrow: 8644,
	SquareSupersetEqual: 8850,
	leftrightsquigarrow: 8621,
	DownRightTeeVector: 10591,
	DownRightVectorBar: 10583,
	LongLeftRightArrow: 10231,
	Longleftrightarrow: 10234,
	NegativeThickSpace: 8203,
	PrecedesSlantEqual: 8828,
	ReverseEquilibrium: 8651,
	RightDoubleBracket: 10215,
	RightDownTeeVector: 10589,
	RightDownVectorBar: 10581,
	RightTriangleEqual: 8885,
	SquareIntersection: 8851,
	SucceedsSlantEqual: 8829,
	blacktriangleright: 9656,
	longleftrightarrow: 10231,
	DoubleUpDownArrow: 8661,
	DoubleVerticalBar: 8741,
	DownLeftTeeVector: 10590,
	DownLeftVectorBar: 10582,
	FilledSmallSquare: 9724,
	GreaterSlantEqual: 10878,
	LeftDoubleBracket: 10214,
	LeftDownTeeVector: 10593,
	LeftDownVectorBar: 10585,
	LeftTriangleEqual: 8884,
	NegativeThinSpace: 8203,
	NotReverseElement: 8716,
	NotTildeFullEqual: 8775,
	RightAngleBracket: 10217,
	RightUpDownVector: 10575,
	SquareSubsetEqual: 8849,
	VerticalSeparator: 10072,
	blacktriangledown: 9662,
	blacktriangleleft: 9666,
	leftrightharpoons: 8651,
	rightleftharpoons: 8652,
	twoheadrightarrow: 8608,
	DiacriticalAcute: 180,
	DiacriticalGrave: 96,
	DiacriticalTilde: 732,
	DoubleRightArrow: 8658,
	DownArrowUpArrow: 8693,
	EmptySmallSquare: 9723,
	GreaterEqualLess: 8923,
	GreaterFullEqual: 8807,
	LeftAngleBracket: 10216,
	LeftUpDownVector: 10577,
	LessEqualGreater: 8922,
	NonBreakingSpace: 160,
	NotRightTriangle: 8939,
	NotSupersetEqual: 8841,
	RightTriangleBar: 10704,
	RightUpTeeVector: 10588,
	RightUpVectorBar: 10580,
	UnderParenthesis: 9181,
	UpArrowDownArrow: 8645,
	circlearrowright: 8635,
	downharpoonright: 8642,
	ntrianglerighteq: 8941,
	rightharpoondown: 8641,
	rightrightarrows: 8649,
	twoheadleftarrow: 8606,
	vartriangleright: 8883,
	CloseCurlyQuote: 8217,
	ContourIntegral: 8750,
	DoubleDownArrow: 8659,
	DoubleLeftArrow: 8656,
	DownRightVector: 8641,
	LeftRightVector: 10574,
	LeftTriangleBar: 10703,
	LeftUpTeeVector: 10592,
	LeftUpVectorBar: 10584,
	LowerRightArrow: 8600,
	NotGreaterEqual: 8817,
	NotGreaterTilde: 8821,
	NotLeftTriangle: 8938,
	OverParenthesis: 9180,
	RightDownVector: 8642,
	ShortRightArrow: 8594,
	UpperRightArrow: 8599,
	bigtriangledown: 9661,
	circlearrowleft: 8634,
	curvearrowright: 8631,
	downharpoonleft: 8643,
	leftharpoondown: 8637,
	leftrightarrows: 8646,
	nLeftrightarrow: 8654,
	nleftrightarrow: 8622,
	ntrianglelefteq: 8940,
	rightleftarrows: 8644,
	rightsquigarrow: 8605,
	rightthreetimes: 8908,
	straightepsilon: 1013,
	trianglerighteq: 8885,
	vartriangleleft: 8882,
	DiacriticalDot: 729,
	DoubleRightTee: 8872,
	DownLeftVector: 8637,
	GreaterGreater: 10914,
	HorizontalLine: 9472,
	InvisibleComma: 8291,
	InvisibleTimes: 8290,
	LeftDownVector: 8643,
	LeftRightArrow: 8596,
	Leftrightarrow: 8660,
	LessSlantEqual: 10877,
	LongRightArrow: 10230,
	Longrightarrow: 10233,
	LowerLeftArrow: 8601,
	NestedLessLess: 8810,
	NotGreaterLess: 8825,
	NotLessGreater: 8824,
	NotSubsetEqual: 8840,
	NotVerticalBar: 8740,
	OpenCurlyQuote: 8216,
	ReverseElement: 8715,
	RightTeeVector: 10587,
	RightVectorBar: 10579,
	ShortDownArrow: 8595,
	ShortLeftArrow: 8592,
	SquareSuperset: 8848,
	TildeFullEqual: 8773,
	UpperLeftArrow: 8598,
	ZeroWidthSpace: 8203,
	curvearrowleft: 8630,
	doublebarwedge: 8966,
	downdownarrows: 8650,
	hookrightarrow: 8618,
	leftleftarrows: 8647,
	leftrightarrow: 8596,
	leftthreetimes: 8907,
	longrightarrow: 10230,
	looparrowright: 8620,
	nshortparallel: 8742,
	ntriangleright: 8939,
	rightarrowtail: 8611,
	rightharpoonup: 8640,
	trianglelefteq: 8884,
	upharpoonright: 8638,
	ApplyFunction: 8289,
	DifferentialD: 8518,
	DoubleLeftTee: 10980,
	DoubleUpArrow: 8657,
	LeftTeeVector: 10586,
	LeftVectorBar: 10578,
	LessFullEqual: 8806,
	LongLeftArrow: 10229,
	Longleftarrow: 10232,
	NotTildeEqual: 8772,
	NotTildeTilde: 8777,
	Poincareplane: 8460,
	PrecedesEqual: 10927,
	PrecedesTilde: 8830,
	RightArrowBar: 8677,
	RightTeeArrow: 8614,
	RightTriangle: 8883,
	RightUpVector: 8638,
	SucceedsEqual: 10928,
	SucceedsTilde: 8831,
	SupersetEqual: 8839,
	UpEquilibrium: 10606,
	VerticalTilde: 8768,
	VeryThinSpace: 8202,
	bigtriangleup: 9651,
	blacktriangle: 9652,
	divideontimes: 8903,
	fallingdotseq: 8786,
	hookleftarrow: 8617,
	leftarrowtail: 8610,
	leftharpoonup: 8636,
	longleftarrow: 10229,
	looparrowleft: 8619,
	measuredangle: 8737,
	ntriangleleft: 8938,
	shortparallel: 8741,
	smallsetminus: 8726,
	triangleright: 9657,
	upharpoonleft: 8639,
	DownArrowBar: 10515,
	DownTeeArrow: 8615,
	ExponentialE: 8519,
	GreaterEqual: 8805,
	GreaterTilde: 8819,
	HilbertSpace: 8459,
	HumpDownHump: 8782,
	Intersection: 8898,
	LeftArrowBar: 8676,
	LeftTeeArrow: 8612,
	LeftTriangle: 8882,
	LeftUpVector: 8639,
	NotCongruent: 8802,
	NotLessEqual: 8816,
	NotLessTilde: 8820,
	Proportional: 8733,
	RightCeiling: 8969,
	RoundImplies: 10608,
	ShortUpArrow: 8593,
	SquareSubset: 8847,
	UnderBracket: 9141,
	VerticalLine: 124,
	blacklozenge: 10731,
	exponentiale: 8519,
	risingdotseq: 8787,
	triangledown: 9663,
	triangleleft: 9667,
	CircleMinus: 8854,
	CircleTimes: 8855,
	Equilibrium: 8652,
	GreaterLess: 8823,
	LeftCeiling: 8968,
	LessGreater: 8822,
	MediumSpace: 8287,
	NotPrecedes: 8832,
	NotSucceeds: 8833,
	OverBracket: 9140,
	RightVector: 8640,
	Rrightarrow: 8667,
	RuleDelayed: 10740,
	SmallCircle: 8728,
	SquareUnion: 8852,
	SubsetEqual: 8838,
	UpDownArrow: 8597,
	Updownarrow: 8661,
	VerticalBar: 8739,
	backepsilon: 1014,
	blacksquare: 9642,
	circledcirc: 8858,
	circleddash: 8861,
	curlyeqprec: 8926,
	curlyeqsucc: 8927,
	diamondsuit: 9830,
	eqslantless: 10901,
	expectation: 8496,
	nRightarrow: 8655,
	nrightarrow: 8603,
	preccurlyeq: 8828,
	precnapprox: 10937,
	quaternions: 8461,
	straightphi: 981,
	succcurlyeq: 8829,
	succnapprox: 10938,
	thickapprox: 8776,
	updownarrow: 8597,
	Bernoullis: 8492,
	CirclePlus: 8853,
	EqualTilde: 8770,
	Fouriertrf: 8497,
	ImaginaryI: 8520,
	Laplacetrf: 8466,
	LeftVector: 8636,
	Lleftarrow: 8666,
	NotElement: 8713,
	NotGreater: 8815,
	Proportion: 8759,
	RightArrow: 8594,
	RightFloor: 8971,
	Rightarrow: 8658,
	TildeEqual: 8771,
	TildeTilde: 8776,
	UnderBrace: 9183,
	UpArrowBar: 10514,
	UpTeeArrow: 8613,
	circledast: 8859,
	complement: 8705,
	curlywedge: 8911,
	eqslantgtr: 10902,
	gtreqqless: 10892,
	lessapprox: 10885,
	lesseqqgtr: 10891,
	lmoustache: 9136,
	longmapsto: 10236,
	mapstodown: 8615,
	mapstoleft: 8612,
	nLeftarrow: 8653,
	nleftarrow: 8602,
	precapprox: 10935,
	rightarrow: 8594,
	rmoustache: 9137,
	sqsubseteq: 8849,
	sqsupseteq: 8850,
	subsetneqq: 10955,
	succapprox: 10936,
	supsetneqq: 10956,
	upuparrows: 8648,
	varepsilon: 949,
	varnothing: 8709,
	Backslash: 8726,
	CenterDot: 183,
	CircleDot: 8857,
	Congruent: 8801,
	Coproduct: 8720,
	DoubleDot: 168,
	DownArrow: 8595,
	DownBreve: 785,
	Downarrow: 8659,
	HumpEqual: 8783,
	LeftArrow: 8592,
	LeftFloor: 8970,
	Leftarrow: 8656,
	LessTilde: 8818,
	Mellintrf: 8499,
	MinusPlus: 8723,
	NotCupCap: 8813,
	NotExists: 8708,
	OverBrace: 9182,
	PlusMinus: 177,
	Therefore: 8756,
	ThinSpace: 8201,
	TripleDot: 8411,
	UnionPlus: 8846,
	backprime: 8245,
	backsimeq: 8909,
	bigotimes: 10754,
	centerdot: 183,
	checkmark: 10003,
	complexes: 8450,
	dotsquare: 8865,
	downarrow: 8595,
	gtrapprox: 10886,
	gtreqless: 8923,
	heartsuit: 9829,
	leftarrow: 8592,
	lesseqgtr: 8922,
	nparallel: 8742,
	nshortmid: 8740,
	nsubseteq: 8840,
	nsupseteq: 8841,
	pitchfork: 8916,
	rationals: 8474,
	spadesuit: 9824,
	subseteqq: 10949,
	subsetneq: 8842,
	supseteqq: 10950,
	supsetneq: 8843,
	therefore: 8756,
	triangleq: 8796,
	varpropto: 8733,
	DDotrahd: 10513,
	DotEqual: 8784,
	Integral: 8747,
	LessLess: 10913,
	NotEqual: 8800,
	NotTilde: 8769,
	PartialD: 8706,
	Precedes: 8826,
	RightTee: 8866,
	Succeeds: 8827,
	SuchThat: 8715,
	Superset: 8835,
	Uarrocir: 10569,
	UnderBar: 818,
	andslope: 10840,
	angmsdaa: 10664,
	angmsdab: 10665,
	angmsdac: 10666,
	angmsdad: 10667,
	angmsdae: 10668,
	angmsdaf: 10669,
	angmsdag: 10670,
	angmsdah: 10671,
	angrtvbd: 10653,
	approxeq: 8778,
	awconint: 8755,
	backcong: 8780,
	barwedge: 8965,
	bbrktbrk: 9142,
	bigoplus: 10753,
	bigsqcup: 10758,
	biguplus: 10756,
	bigwedge: 8896,
	boxminus: 8863,
	boxtimes: 8864,
	capbrcup: 10825,
	circledR: 174,
	circledS: 9416,
	cirfnint: 10768,
	clubsuit: 9827,
	cupbrcap: 10824,
	curlyvee: 8910,
	cwconint: 8754,
	doteqdot: 8785,
	dotminus: 8760,
	drbkarow: 10512,
	dzigrarr: 10239,
	elinters: 9191,
	emptyset: 8709,
	eqvparsl: 10725,
	fpartint: 10765,
	geqslant: 10878,
	gesdotol: 10884,
	gnapprox: 10890,
	hksearow: 10533,
	hkswarow: 10534,
	imagline: 8464,
	imagpart: 8465,
	infintie: 10717,
	integers: 8484,
	intercal: 8890,
	intlarhk: 10775,
	laemptyv: 10676,
	ldrushar: 10571,
	leqslant: 10877,
	lesdotor: 10883,
	llcorner: 8990,
	lnapprox: 10889,
	lrcorner: 8991,
	lurdshar: 10570,
	mapstoup: 8613,
	multimap: 8888,
	naturals: 8469,
	otimesas: 10806,
	parallel: 8741,
	plusacir: 10787,
	pointint: 10773,
	precneqq: 10933,
	precnsim: 8936,
	profalar: 9006,
	profline: 8978,
	profsurf: 8979,
	raemptyv: 10675,
	realpart: 8476,
	rppolint: 10770,
	rtriltri: 10702,
	scpolint: 10771,
	setminus: 8726,
	shortmid: 8739,
	smeparsl: 10724,
	sqsubset: 8847,
	sqsupset: 8848,
	subseteq: 8838,
	succneqq: 10934,
	succnsim: 8937,
	supseteq: 8839,
	thetasym: 977,
	thicksim: 8764,
	timesbar: 10801,
	triangle: 9653,
	triminus: 10810,
	trpezium: 9186,
	ulcorner: 8988,
	urcorner: 8989,
	varkappa: 1008,
	varsigma: 962,
	vartheta: 977,
	Because: 8757,
	Cayleys: 8493,
	Cconint: 8752,
	Cedilla: 184,
	Diamond: 8900,
	DownTee: 8868,
	Element: 8712,
	Epsilon: 917,
	Implies: 8658,
	LeftTee: 8867,
	NewLine: 10,
	NoBreak: 8288,
	NotLess: 8814,
	Omicron: 927,
	OverBar: 175,
	Product: 8719,
	UpArrow: 8593,
	Uparrow: 8657,
	Upsilon: 933,
	alefsym: 8501,
	angrtvb: 8894,
	angzarr: 9084,
	asympeq: 8781,
	backsim: 8765,
	because: 8757,
	bemptyv: 10672,
	between: 8812,
	bigcirc: 9711,
	bigodot: 10752,
	bigstar: 9733,
	boxplus: 8862,
	ccupssm: 10832,
	cemptyv: 10674,
	cirscir: 10690,
	coloneq: 8788,
	congdot: 10861,
	cudarrl: 10552,
	cudarrr: 10549,
	cularrp: 10557,
	curarrm: 10556,
	dbkarow: 10511,
	ddagger: 8225,
	ddotseq: 10871,
	demptyv: 10673,
	diamond: 8900,
	digamma: 989,
	dotplus: 8724,
	dwangle: 10662,
	epsilon: 949,
	eqcolon: 8789,
	equivDD: 10872,
	gesdoto: 10882,
	gtquest: 10876,
	gtrless: 8823,
	harrcir: 10568,
	intprod: 10812,
	isindot: 8949,
	larrbfs: 10527,
	larrsim: 10611,
	lbrksld: 10639,
	lbrkslu: 10637,
	ldrdhar: 10599,
	lesdoto: 10881,
	lessdot: 8918,
	lessgtr: 8822,
	lesssim: 8818,
	lotimes: 10804,
	lozenge: 9674,
	ltquest: 10875,
	luruhar: 10598,
	maltese: 10016,
	minusdu: 10794,
	napprox: 8777,
	natural: 9838,
	nearrow: 8599,
	nexists: 8708,
	notinva: 8713,
	notinvb: 8951,
	notinvc: 8950,
	notniva: 8716,
	notnivb: 8958,
	notnivc: 8957,
	npolint: 10772,
	nsqsube: 8930,
	nsqsupe: 8931,
	nvinfin: 10718,
	nwarrow: 8598,
	olcross: 10683,
	omicron: 959,
	orderof: 8500,
	orslope: 10839,
	pertenk: 8241,
	planckh: 8462,
	pluscir: 10786,
	plussim: 10790,
	plustwo: 10791,
	precsim: 8830,
	quatint: 10774,
	questeq: 8799,
	rarrbfs: 10528,
	rarrsim: 10612,
	rbrksld: 10638,
	rbrkslu: 10640,
	rdldhar: 10601,
	realine: 8475,
	rotimes: 10805,
	ruluhar: 10600,
	searrow: 8600,
	simplus: 10788,
	simrarr: 10610,
	subedot: 10947,
	submult: 10945,
	subplus: 10943,
	subrarr: 10617,
	succsim: 8831,
	supdsub: 10968,
	supedot: 10948,
	suphsub: 10967,
	suplarr: 10619,
	supmult: 10946,
	supplus: 10944,
	swarrow: 8601,
	topfork: 10970,
	triplus: 10809,
	tritime: 10811,
	uparrow: 8593,
	upsilon: 965,
	uwangle: 10663,
	vzigzag: 10650,
	zigrarr: 8669,
	Aacute: 193,
	Abreve: 258,
	Agrave: 192,
	Assign: 8788,
	Atilde: 195,
	Barwed: 8966,
	Bumpeq: 8782,
	Cacute: 262,
	Ccaron: 268,
	Ccedil: 199,
	Colone: 10868,
	Conint: 8751,
	CupCap: 8781,
	Dagger: 8225,
	Dcaron: 270,
	DotDot: 8412,
	Dstrok: 272,
	Eacute: 201,
	Ecaron: 282,
	Egrave: 200,
	Exists: 8707,
	ForAll: 8704,
	Gammad: 988,
	Gbreve: 286,
	Gcedil: 290,
	HARDcy: 1066,
	Hstrok: 294,
	Iacute: 205,
	Igrave: 204,
	Itilde: 296,
	Jsercy: 1032,
	Kcedil: 310,
	Lacute: 313,
	Lambda: 923,
	Lcaron: 317,
	Lcedil: 315,
	Lmidot: 319,
	Lstrok: 321,
	Nacute: 323,
	Ncaron: 327,
	Ncedil: 325,
	Ntilde: 209,
	Oacute: 211,
	Odblac: 336,
	Ograve: 210,
	Oslash: 216,
	Otilde: 213,
	Otimes: 10807,
	Racute: 340,
	Rarrtl: 10518,
	Rcaron: 344,
	Rcedil: 342,
	SHCHcy: 1065,
	SOFTcy: 1068,
	Sacute: 346,
	Scaron: 352,
	Scedil: 350,
	Square: 9633,
	Subset: 8912,
	Supset: 8913,
	Tcaron: 356,
	Tcedil: 354,
	Tstrok: 358,
	Uacute: 218,
	Ubreve: 364,
	Udblac: 368,
	Ugrave: 217,
	Utilde: 360,
	Vdashl: 10982,
	Verbar: 8214,
	Vvdash: 8874,
	Yacute: 221,
	Zacute: 377,
	Zcaron: 381,
	aacute: 225,
	abreve: 259,
	agrave: 224,
	andand: 10837,
	angmsd: 8737,
	angsph: 8738,
	apacir: 10863,
	approx: 8776,
	atilde: 227,
	barvee: 8893,
	barwed: 8965,
	becaus: 8757,
	bernou: 8492,
	bigcap: 8898,
	bigcup: 8899,
	bigvee: 8897,
	bkarow: 10509,
	bottom: 8869,
	bowtie: 8904,
	boxbox: 10697,
	bprime: 8245,
	brvbar: 166,
	bullet: 8226,
	bumpeq: 8783,
	cacute: 263,
	capand: 10820,
	capcap: 10827,
	capcup: 10823,
	capdot: 10816,
	ccaron: 269,
	ccedil: 231,
	circeq: 8791,
	cirmid: 10991,
	colone: 8788,
	commat: 64,
	compfn: 8728,
	conint: 8750,
	coprod: 8720,
	copysr: 8471,
	cularr: 8630,
	cupcap: 10822,
	cupcup: 10826,
	cupdot: 8845,
	curarr: 8631,
	curren: 164,
	cylcty: 9005,
	dagger: 8224,
	daleth: 8504,
	dcaron: 271,
	dfisht: 10623,
	divide: 247,
	divonx: 8903,
	dlcorn: 8990,
	dlcrop: 8973,
	dollar: 36,
	drcorn: 8991,
	drcrop: 8972,
	dstrok: 273,
	eacute: 233,
	easter: 10862,
	ecaron: 283,
	ecolon: 8789,
	egrave: 232,
	egsdot: 10904,
	elsdot: 10903,
	emptyv: 8709,
	emsp13: 8196,
	emsp14: 8197,
	eparsl: 10723,
	eqcirc: 8790,
	equals: 61,
	equest: 8799,
	female: 9792,
	ffilig: 64259,
	ffllig: 64260,
	forall: 8704,
	frac12: 189,
	frac13: 8531,
	frac14: 188,
	frac15: 8533,
	frac16: 8537,
	frac18: 8539,
	frac23: 8532,
	frac25: 8534,
	frac34: 190,
	frac35: 8535,
	frac38: 8540,
	frac45: 8536,
	frac56: 8538,
	frac58: 8541,
	frac78: 8542,
	gacute: 501,
	gammad: 989,
	gbreve: 287,
	gesdot: 10880,
	gesles: 10900,
	gtlPar: 10645,
	gtrarr: 10616,
	gtrdot: 8919,
	gtrsim: 8819,
	hairsp: 8202,
	hamilt: 8459,
	hardcy: 1098,
	hearts: 9829,
	hellip: 8230,
	hercon: 8889,
	homtht: 8763,
	horbar: 8213,
	hslash: 8463,
	hstrok: 295,
	hybull: 8259,
	hyphen: 8208,
	iacute: 237,
	igrave: 236,
	iiiint: 10764,
	iinfin: 10716,
	incare: 8453,
	inodot: 305,
	intcal: 8890,
	iquest: 191,
	isinsv: 8947,
	itilde: 297,
	jsercy: 1112,
	kappav: 1008,
	kcedil: 311,
	kgreen: 312,
	lAtail: 10523,
	lacute: 314,
	lagran: 8466,
	lambda: 955,
	langle: 10216,
	larrfs: 10525,
	larrhk: 8617,
	larrlp: 8619,
	larrpl: 10553,
	larrtl: 8610,
	latail: 10521,
	lbrace: 123,
	lbrack: 91,
	lcaron: 318,
	lcedil: 316,
	ldquor: 8222,
	lesdot: 10879,
	lesges: 10899,
	lfisht: 10620,
	lfloor: 8970,
	lharul: 10602,
	llhard: 10603,
	lmidot: 320,
	lmoust: 9136,
	loplus: 10797,
	lowast: 8727,
	lowbar: 95,
	lparlt: 10643,
	lrhard: 10605,
	lsaquo: 8249,
	lsquor: 8218,
	lstrok: 322,
	lthree: 8907,
	ltimes: 8905,
	ltlarr: 10614,
	ltrPar: 10646,
	mapsto: 8614,
	marker: 9646,
	mcomma: 10793,
	midast: 42,
	midcir: 10992,
	middot: 183,
	minusb: 8863,
	minusd: 8760,
	mnplus: 8723,
	models: 8871,
	mstpos: 8766,
	nVDash: 8879,
	nVdash: 8878,
	nacute: 324,
	ncaron: 328,
	ncedil: 326,
	nearhk: 10532,
	nequiv: 8802,
	nesear: 10536,
	nexist: 8708,
	nltrie: 8940,
	nprcue: 8928,
	nrtrie: 8941,
	nsccue: 8929,
	nsimeq: 8772,
	ntilde: 241,
	numero: 8470,
	nvDash: 8877,
	nvHarr: 10500,
	nvdash: 8876,
	nvlArr: 10498,
	nvrArr: 10499,
	nwarhk: 10531,
	nwnear: 10535,
	oacute: 243,
	odblac: 337,
	odsold: 10684,
	ograve: 242,
	ominus: 8854,
	origof: 8886,
	oslash: 248,
	otilde: 245,
	otimes: 8855,
	parsim: 10995,
	percnt: 37,
	period: 46,
	permil: 8240,
	phmmat: 8499,
	planck: 8463,
	plankv: 8463,
	plusdo: 8724,
	plusdu: 10789,
	plusmn: 177,
	preceq: 10927,
	primes: 8473,
	prnsim: 8936,
	propto: 8733,
	prurel: 8880,
	puncsp: 8200,
	qprime: 8279,
	rAtail: 10524,
	racute: 341,
	rangle: 10217,
	rarrap: 10613,
	rarrfs: 10526,
	rarrhk: 8618,
	rarrlp: 8620,
	rarrpl: 10565,
	rarrtl: 8611,
	ratail: 10522,
	rbrace: 125,
	rbrack: 93,
	rcaron: 345,
	rcedil: 343,
	rdquor: 8221,
	rfisht: 10621,
	rfloor: 8971,
	rharul: 10604,
	rmoust: 9137,
	roplus: 10798,
	rpargt: 10644,
	rsaquo: 8250,
	rsquor: 8217,
	rthree: 8908,
	rtimes: 8906,
	sacute: 347,
	scaron: 353,
	scedil: 351,
	scnsim: 8937,
	searhk: 10533,
	seswar: 10537,
	sfrown: 8994,
	shchcy: 1097,
	sigmaf: 962,
	sigmav: 962,
	simdot: 10858,
	smashp: 10803,
	softcy: 1100,
	solbar: 9023,
	spades: 9824,
	sqsube: 8849,
	sqsupe: 8850,
	square: 9633,
	squarf: 9642,
	ssetmn: 8726,
	ssmile: 8995,
	sstarf: 8902,
	subdot: 10941,
	subset: 8834,
	subsim: 10951,
	subsub: 10965,
	subsup: 10963,
	succeq: 10928,
	supdot: 10942,
	supset: 8835,
	supsim: 10952,
	supsub: 10964,
	supsup: 10966,
	swarhk: 10534,
	swnwar: 10538,
	target: 8982,
	tcaron: 357,
	tcedil: 355,
	telrec: 8981,
	there4: 8756,
	thetav: 977,
	thinsp: 8201,
	thksim: 8764,
	timesb: 8864,
	timesd: 10800,
	topbot: 9014,
	topcir: 10993,
	tprime: 8244,
	tridot: 9708,
	tstrok: 359,
	uacute: 250,
	ubreve: 365,
	udblac: 369,
	ufisht: 10622,
	ugrave: 249,
	ulcorn: 8988,
	ulcrop: 8975,
	urcorn: 8989,
	urcrop: 8974,
	utilde: 361,
	vangrt: 10652,
	varphi: 966,
	varrho: 1009,
	veebar: 8891,
	vellip: 8942,
	verbar: 124,
	wedbar: 10847,
	wedgeq: 8793,
	weierp: 8472,
	wreath: 8768,
	xoplus: 10753,
	xotime: 10754,
	xsqcup: 10758,
	xuplus: 10756,
	xwedge: 8896,
	yacute: 253,
	zacute: 378,
	zcaron: 382,
	zeetrf: 8488,
	AElig: 198,
	Acirc: 194,
	Alpha: 913,
	Amacr: 256,
	Aogon: 260,
	Aring: 197,
	Breve: 728,
	Ccirc: 264,
	Colon: 8759,
	Cross: 10799,
	Dashv: 10980,
	Delta: 916,
	Ecirc: 202,
	Emacr: 274,
	Eogon: 280,
	Equal: 10869,
	Gamma: 915,
	Gcirc: 284,
	Hacek: 711,
	Hcirc: 292,
	IJlig: 306,
	Icirc: 206,
	Imacr: 298,
	Iogon: 302,
	Iukcy: 1030,
	Jcirc: 308,
	Jukcy: 1028,
	Kappa: 922,
	OElig: 338,
	Ocirc: 212,
	Omacr: 332,
	Omega: 937,
	Prime: 8243,
	RBarr: 10512,
	Scirc: 348,
	Sigma: 931,
	THORN: 222,
	TRADE: 8482,
	TSHcy: 1035,
	Theta: 920,
	Tilde: 8764,
	Ubrcy: 1038,
	Ucirc: 219,
	Umacr: 362,
	Union: 8899,
	Uogon: 370,
	UpTee: 8869,
	Uring: 366,
	VDash: 8875,
	Vdash: 8873,
	Wcirc: 372,
	Wedge: 8896,
	Ycirc: 374,
	acirc: 226,
	acute: 180,
	aelig: 230,
	aleph: 8501,
	alpha: 945,
	amacr: 257,
	amalg: 10815,
	angle: 8736,
	angrt: 8735,
	angst: 8491,
	aogon: 261,
	aring: 229,
	asymp: 8776,
	awint: 10769,
	bcong: 8780,
	bdquo: 8222,
	bepsi: 1014,
	blank: 9251,
	blk12: 9618,
	blk14: 9617,
	blk34: 9619,
	block: 9608,
	boxDL: 9559,
	boxDR: 9556,
	boxDl: 9558,
	boxDr: 9555,
	boxHD: 9574,
	boxHU: 9577,
	boxHd: 9572,
	boxHu: 9575,
	boxUL: 9565,
	boxUR: 9562,
	boxUl: 9564,
	boxUr: 9561,
	boxVH: 9580,
	boxVL: 9571,
	boxVR: 9568,
	boxVh: 9579,
	boxVl: 9570,
	boxVr: 9567,
	boxdL: 9557,
	boxdR: 9554,
	boxdl: 9488,
	boxdr: 9484,
	boxhD: 9573,
	boxhU: 9576,
	boxhd: 9516,
	boxhu: 9524,
	boxuL: 9563,
	boxuR: 9560,
	boxul: 9496,
	boxur: 9492,
	boxvH: 9578,
	boxvL: 9569,
	boxvR: 9566,
	boxvh: 9532,
	boxvl: 9508,
	boxvr: 9500,
	breve: 728,
	bsemi: 8271,
	bsime: 8909,
	bsolb: 10693,
	bumpE: 10926,
	bumpe: 8783,
	caret: 8257,
	caron: 711,
	ccaps: 10829,
	ccirc: 265,
	ccups: 10828,
	cedil: 184,
	check: 10003,
	clubs: 9827,
	colon: 58,
	comma: 44,
	crarr: 8629,
	cross: 10007,
	csube: 10961,
	csupe: 10962,
	ctdot: 8943,
	cuepr: 8926,
	cuesc: 8927,
	cupor: 10821,
	cuvee: 8910,
	cuwed: 8911,
	cwint: 8753,
	dashv: 8867,
	dblac: 733,
	ddarr: 8650,
	delta: 948,
	dharl: 8643,
	dharr: 8642,
	diams: 9830,
	disin: 8946,
	doteq: 8784,
	dtdot: 8945,
	dtrif: 9662,
	duarr: 8693,
	duhar: 10607,
	eDDot: 10871,
	ecirc: 234,
	efDot: 8786,
	emacr: 275,
	empty: 8709,
	eogon: 281,
	eplus: 10865,
	epsiv: 949,
	eqsim: 8770,
	equiv: 8801,
	erDot: 8787,
	erarr: 10609,
	esdot: 8784,
	exist: 8707,
	fflig: 64256,
	filig: 64257,
	fllig: 64258,
	fltns: 9649,
	forkv: 10969,
	frasl: 8260,
	frown: 8994,
	gamma: 947,
	gcirc: 285,
	gescc: 10921,
	gimel: 8503,
	gneqq: 8809,
	gnsim: 8935,
	grave: 96,
	gsime: 10894,
	gsiml: 10896,
	gtcir: 10874,
	gtdot: 8919,
	harrw: 8621,
	hcirc: 293,
	hoarr: 8703,
	icirc: 238,
	iexcl: 161,
	iiint: 8749,
	iiota: 8489,
	ijlig: 307,
	imacr: 299,
	image: 8465,
	imath: 305,
	imped: 437,
	infin: 8734,
	iogon: 303,
	iprod: 10812,
	isinE: 8953,
	isins: 8948,
	isinv: 8712,
	iukcy: 1110,
	jcirc: 309,
	jmath: 567,
	jukcy: 1108,
	kappa: 954,
	lAarr: 8666,
	lBarr: 10510,
	langd: 10641,
	laquo: 171,
	larrb: 8676,
	lbarr: 10508,
	lbbrk: 10098,
	lbrke: 10635,
	lceil: 8968,
	ldquo: 8220,
	lescc: 10920,
	lhard: 8637,
	lharu: 8636,
	lhblk: 9604,
	llarr: 8647,
	lltri: 9722,
	lneqq: 8808,
	lnsim: 8934,
	loang: 10220,
	loarr: 8701,
	lobrk: 10214,
	lopar: 10629,
	lrarr: 8646,
	lrhar: 8651,
	lrtri: 8895,
	lsime: 10893,
	lsimg: 10895,
	lsquo: 8216,
	ltcir: 10873,
	ltdot: 8918,
	ltrie: 8884,
	ltrif: 9666,
	mDDot: 8762,
	mdash: 8212,
	micro: 181,
	minus: 8722,
	mumap: 8888,
	nabla: 8711,
	napos: 329,
	natur: 9838,
	ncong: 8775,
	ndash: 8211,
	neArr: 8663,
	nearr: 8599,
	ngsim: 8821,
	nhArr: 8654,
	nharr: 8622,
	nhpar: 10994,
	nlArr: 8653,
	nlarr: 8602,
	nless: 8814,
	nlsim: 8820,
	nltri: 8938,
	notin: 8713,
	notni: 8716,
	nprec: 8832,
	nrArr: 8655,
	nrarr: 8603,
	nrtri: 8939,
	nsime: 8772,
	nsmid: 8740,
	nspar: 8742,
	nsube: 8840,
	nsucc: 8833,
	nsupe: 8841,
	numsp: 8199,
	nwArr: 8662,
	nwarr: 8598,
	ocirc: 244,
	odash: 8861,
	oelig: 339,
	ofcir: 10687,
	ohbar: 10677,
	olarr: 8634,
	olcir: 10686,
	oline: 8254,
	omacr: 333,
	omega: 969,
	operp: 10681,
	oplus: 8853,
	orarr: 8635,
	order: 8500,
	ovbar: 9021,
	parsl: 11005,
	phone: 9742,
	plusb: 8862,
	pluse: 10866,
	pound: 163,
	prcue: 8828,
	prime: 8242,
	prnap: 10937,
	prsim: 8830,
	quest: 63,
	rAarr: 8667,
	rBarr: 10511,
	radic: 8730,
	rangd: 10642,
	range: 10661,
	raquo: 187,
	rarrb: 8677,
	rarrc: 10547,
	rarrw: 8605,
	ratio: 8758,
	rbarr: 10509,
	rbbrk: 10099,
	rbrke: 10636,
	rceil: 8969,
	rdquo: 8221,
	reals: 8477,
	rhard: 8641,
	rharu: 8640,
	rlarr: 8644,
	rlhar: 8652,
	rnmid: 10990,
	roang: 10221,
	roarr: 8702,
	robrk: 10215,
	ropar: 10630,
	rrarr: 8649,
	rsquo: 8217,
	rtrie: 8885,
	rtrif: 9656,
	sbquo: 8218,
	sccue: 8829,
	scirc: 349,
	scnap: 10938,
	scsim: 8831,
	sdotb: 8865,
	sdote: 10854,
	seArr: 8664,
	searr: 8600,
	setmn: 8726,
	sharp: 9839,
	sigma: 963,
	simeq: 8771,
	simgE: 10912,
	simlE: 10911,
	simne: 8774,
	slarr: 8592,
	smile: 8995,
	sqcap: 8851,
	sqcup: 8852,
	sqsub: 8847,
	sqsup: 8848,
	srarr: 8594,
	starf: 9733,
	strns: 175,
	subnE: 10955,
	subne: 8842,
	supnE: 10956,
	supne: 8843,
	swArr: 8665,
	swarr: 8601,
	szlig: 223,
	theta: 952,
	thkap: 8776,
	thorn: 254,
	tilde: 732,
	times: 215,
	trade: 8482,
	trisb: 10701,
	tshcy: 1115,
	twixt: 8812,
	ubrcy: 1118,
	ucirc: 251,
	udarr: 8645,
	udhar: 10606,
	uharl: 8639,
	uharr: 8638,
	uhblk: 9600,
	ultri: 9720,
	umacr: 363,
	uogon: 371,
	uplus: 8846,
	upsih: 978,
	uring: 367,
	urtri: 9721,
	utdot: 8944,
	utrif: 9652,
	uuarr: 8648,
	vBarv: 10985,
	vDash: 8872,
	varpi: 982,
	vdash: 8866,
	veeeq: 8794,
	vltri: 8882,
	vprop: 8733,
	vrtri: 8883,
	wcirc: 373,
	wedge: 8743,
	xcirc: 9711,
	xdtri: 9661,
	xhArr: 10234,
	xharr: 10231,
	xlArr: 10232,
	xlarr: 10229,
	xodot: 10752,
	xrArr: 10233,
	xrarr: 10230,
	xutri: 9651,
	ycirc: 375,
	Aopf: 120120,
	Ascr: 119964,
	Auml: 196,
	Barv: 10983,
	Beta: 914,
	Bopf: 120121,
	Bscr: 8492,
	CHcy: 1063,
	COPY: 169,
	Cdot: 266,
	Copf: 8450,
	Cscr: 119966,
	DJcy: 1026,
	DScy: 1029,
	DZcy: 1039,
	Darr: 8609,
	Dopf: 120123,
	Dscr: 119967,
	Edot: 278,
	Eopf: 120124,
	Escr: 8496,
	Esim: 10867,
	Euml: 203,
	Fopf: 120125,
	Fscr: 8497,
	GJcy: 1027,
	Gdot: 288,
	Gopf: 120126,
	Gscr: 119970,
	Hopf: 8461,
	Hscr: 8459,
	IEcy: 1045,
	IOcy: 1025,
	Idot: 304,
	Iopf: 120128,
	Iota: 921,
	Iscr: 8464,
	Iuml: 207,
	Jopf: 120129,
	Jscr: 119973,
	KHcy: 1061,
	KJcy: 1036,
	Kopf: 120130,
	Kscr: 119974,
	LJcy: 1033,
	Lang: 10218,
	Larr: 8606,
	Lopf: 120131,
	Lscr: 8466,
	Mopf: 120132,
	Mscr: 8499,
	NJcy: 1034,
	Nopf: 8469,
	Nscr: 119977,
	Oopf: 120134,
	Oscr: 119978,
	Ouml: 214,
	Popf: 8473,
	Pscr: 119979,
	QUOT: 34,
	Qopf: 8474,
	Qscr: 119980,
	Rang: 10219,
	Rarr: 8608,
	Ropf: 8477,
	Rscr: 8475,
	SHcy: 1064,
	Sopf: 120138,
	Sqrt: 8730,
	Sscr: 119982,
	Star: 8902,
	TScy: 1062,
	Topf: 120139,
	Tscr: 119983,
	Uarr: 8607,
	Uopf: 120140,
	Upsi: 978,
	Uscr: 119984,
	Uuml: 220,
	Vbar: 10987,
	Vert: 8214,
	Vopf: 120141,
	Vscr: 119985,
	Wopf: 120142,
	Wscr: 119986,
	Xopf: 120143,
	Xscr: 119987,
	YAcy: 1071,
	YIcy: 1031,
	YUcy: 1070,
	Yopf: 120144,
	Yscr: 119988,
	Yuml: 376,
	ZHcy: 1046,
	Zdot: 379,
	Zeta: 918,
	Zopf: 8484,
	Zscr: 119989,
	andd: 10844,
	andv: 10842,
	ange: 10660,
	aopf: 120146,
	apid: 8779,
	apos: 39,
	ascr: 119990,
	auml: 228,
	bNot: 10989,
	bbrk: 9141,
	beta: 946,
	beth: 8502,
	bnot: 8976,
	bopf: 120147,
	boxH: 9552,
	boxV: 9553,
	boxh: 9472,
	boxv: 9474,
	bscr: 119991,
	bsim: 8765,
	bsol: 92,
	bull: 8226,
	bump: 8782,
	cdot: 267,
	cent: 162,
	chcy: 1095,
	cirE: 10691,
	circ: 710,
	cire: 8791,
	comp: 8705,
	cong: 8773,
	copf: 120148,
	copy: 169,
	cscr: 119992,
	csub: 10959,
	csup: 10960,
	dArr: 8659,
	dHar: 10597,
	darr: 8595,
	dash: 8208,
	diam: 8900,
	djcy: 1106,
	dopf: 120149,
	dscr: 119993,
	dscy: 1109,
	dsol: 10742,
	dtri: 9663,
	dzcy: 1119,
	eDot: 8785,
	ecir: 8790,
	edot: 279,
	emsp: 8195,
	ensp: 8194,
	eopf: 120150,
	epar: 8917,
	epsi: 1013,
	escr: 8495,
	esim: 8770,
	euml: 235,
	euro: 8364,
	excl: 33,
	flat: 9837,
	fnof: 402,
	fopf: 120151,
	fork: 8916,
	fscr: 119995,
	gdot: 289,
	geqq: 8807,
	gjcy: 1107,
	gnap: 10890,
	gneq: 10888,
	gopf: 120152,
	gscr: 8458,
	gsim: 8819,
	gtcc: 10919,
	hArr: 8660,
	half: 189,
	harr: 8596,
	hbar: 8463,
	hopf: 120153,
	hscr: 119997,
	iecy: 1077,
	imof: 8887,
	iocy: 1105,
	iopf: 120154,
	iota: 953,
	iscr: 119998,
	isin: 8712,
	iuml: 239,
	jopf: 120155,
	jscr: 119999,
	khcy: 1093,
	kjcy: 1116,
	kopf: 120156,
	kscr: 120000,
	lArr: 8656,
	lHar: 10594,
	lang: 10216,
	larr: 8592,
	late: 10925,
	lcub: 123,
	ldca: 10550,
	ldsh: 8626,
	leqq: 8806,
	ljcy: 1113,
	lnap: 10889,
	lneq: 10887,
	lopf: 120157,
	lozf: 10731,
	lpar: 40,
	lscr: 120001,
	lsim: 8818,
	lsqb: 91,
	ltcc: 10918,
	ltri: 9667,
	macr: 175,
	male: 9794,
	malt: 10016,
	mlcp: 10971,
	mldr: 8230,
	mopf: 120158,
	mscr: 120002,
	nbsp: 160,
	ncap: 10819,
	ncup: 10818,
	ngeq: 8817,
	ngtr: 8815,
	nisd: 8954,
	njcy: 1114,
	nldr: 8229,
	nleq: 8816,
	nmid: 8740,
	nopf: 120159,
	npar: 8742,
	nscr: 120003,
	nsim: 8769,
	nsub: 8836,
	nsup: 8837,
	ntgl: 8825,
	ntlg: 8824,
	oast: 8859,
	ocir: 8858,
	odiv: 10808,
	odot: 8857,
	ogon: 731,
	oint: 8750,
	omid: 10678,
	oopf: 120160,
	opar: 10679,
	ordf: 170,
	ordm: 186,
	oror: 10838,
	oscr: 8500,
	osol: 8856,
	ouml: 246,
	para: 182,
	part: 8706,
	perp: 8869,
	phiv: 966,
	plus: 43,
	popf: 120161,
	prap: 10935,
	prec: 8826,
	prnE: 10933,
	prod: 8719,
	prop: 8733,
	pscr: 120005,
	qint: 10764,
	qopf: 120162,
	qscr: 120006,
	quot: 34,
	rArr: 8658,
	rHar: 10596,
	race: 10714,
	rang: 10217,
	rarr: 8594,
	rcub: 125,
	rdca: 10551,
	rdsh: 8627,
	real: 8476,
	rect: 9645,
	rhov: 1009,
	ring: 730,
	ropf: 120163,
	rpar: 41,
	rscr: 120007,
	rsqb: 93,
	rtri: 9657,
	scap: 10936,
	scnE: 10934,
	sdot: 8901,
	sect: 167,
	semi: 59,
	sext: 10038,
	shcy: 1096,
	sime: 8771,
	simg: 10910,
	siml: 10909,
	smid: 8739,
	smte: 10924,
	solb: 10692,
	sopf: 120164,
	spar: 8741,
	squf: 9642,
	sscr: 120008,
	star: 9734,
	subE: 10949,
	sube: 8838,
	succ: 8827,
	sung: 9834,
	sup1: 185,
	sup2: 178,
	sup3: 179,
	supE: 10950,
	supe: 8839,
	tbrk: 9140,
	tdot: 8411,
	tint: 8749,
	toea: 10536,
	topf: 120165,
	tosa: 10537,
	trie: 8796,
	tscr: 120009,
	tscy: 1094,
	uArr: 8657,
	uHar: 10595,
	uarr: 8593,
	uopf: 120166,
	upsi: 965,
	uscr: 120010,
	utri: 9653,
	uuml: 252,
	vArr: 8661,
	vBar: 10984,
	varr: 8597,
	vert: 124,
	vopf: 120167,
	vscr: 120011,
	wopf: 120168,
	wscr: 120012,
	xcap: 8898,
	xcup: 8899,
	xmap: 10236,
	xnis: 8955,
	xopf: 120169,
	xscr: 120013,
	xvee: 8897,
	yacy: 1103,
	yicy: 1111,
	yopf: 120170,
	yscr: 120014,
	yucy: 1102,
	yuml: 255,
	zdot: 380,
	zeta: 950,
	zhcy: 1078,
	zopf: 120171,
	zscr: 120015,
	zwnj: 8204,
	AMP: 38,
	Acy: 1040,
	Afr: 120068,
	And: 10835,
	Bcy: 1041,
	Bfr: 120069,
	Cap: 8914,
	Cfr: 8493,
	Chi: 935,
	Cup: 8915,
	Dcy: 1044,
	Del: 8711,
	Dfr: 120071,
	Dot: 168,
	ENG: 330,
	ETH: 208,
	Ecy: 1069,
	Efr: 120072,
	Eta: 919,
	Fcy: 1060,
	Ffr: 120073,
	Gcy: 1043,
	Gfr: 120074,
	Hat: 94,
	Hfr: 8460,
	Icy: 1048,
	Ifr: 8465,
	Int: 8748,
	Jcy: 1049,
	Jfr: 120077,
	Kcy: 1050,
	Kfr: 120078,
	Lcy: 1051,
	Lfr: 120079,
	Lsh: 8624,
	Map: 10501,
	Mcy: 1052,
	Mfr: 120080,
	Ncy: 1053,
	Nfr: 120081,
	Not: 10988,
	Ocy: 1054,
	Ofr: 120082,
	Pcy: 1055,
	Pfr: 120083,
	Phi: 934,
	Psi: 936,
	Qfr: 120084,
	REG: 174,
	Rcy: 1056,
	Rfr: 8476,
	Rho: 929,
	Rsh: 8625,
	Scy: 1057,
	Sfr: 120086,
	Sub: 8912,
	Sum: 8721,
	Sup: 8913,
	Tab: 9,
	Tau: 932,
	Tcy: 1058,
	Tfr: 120087,
	Ucy: 1059,
	Ufr: 120088,
	Vcy: 1042,
	Vee: 8897,
	Vfr: 120089,
	Wfr: 120090,
	Xfr: 120091,
	Ycy: 1067,
	Yfr: 120092,
	Zcy: 1047,
	Zfr: 8488,
	acd: 8767,
	acy: 1072,
	afr: 120094,
	amp: 38,
	and: 8743,
	ang: 8736,
	apE: 10864,
	ape: 8778,
	ast: 42,
	bcy: 1073,
	bfr: 120095,
	bot: 8869,
	cap: 8745,
	cfr: 120096,
	chi: 967,
	cir: 9675,
	cup: 8746,
	dcy: 1076,
	deg: 176,
	dfr: 120097,
	die: 168,
	div: 247,
	dot: 729,
	ecy: 1101,
	efr: 120098,
	egs: 10902,
	ell: 8467,
	els: 10901,
	eng: 331,
	eta: 951,
	eth: 240,
	fcy: 1092,
	ffr: 120099,
	gEl: 10892,
	gap: 10886,
	gcy: 1075,
	gel: 8923,
	geq: 8805,
	ges: 10878,
	gfr: 120100,
	ggg: 8921,
	glE: 10898,
	gla: 10917,
	glj: 10916,
	gnE: 8809,
	gne: 10888,
	hfr: 120101,
	icy: 1080,
	iff: 8660,
	ifr: 120102,
	int: 8747,
	jcy: 1081,
	jfr: 120103,
	kcy: 1082,
	kfr: 120104,
	lEg: 10891,
	lap: 10885,
	lat: 10923,
	lcy: 1083,
	leg: 8922,
	leq: 8804,
	les: 10877,
	lfr: 120105,
	lgE: 10897,
	lnE: 8808,
	lne: 10887,
	loz: 9674,
	lrm: 8206,
	lsh: 8624,
	map: 8614,
	mcy: 1084,
	mfr: 120106,
	mho: 8487,
	mid: 8739,
	nap: 8777,
	ncy: 1085,
	nfr: 120107,
	nge: 8817,
	ngt: 8815,
	nis: 8956,
	niv: 8715,
	nle: 8816,
	nlt: 8814,
	not: 172,
	npr: 8832,
	nsc: 8833,
	num: 35,
	ocy: 1086,
	ofr: 120108,
	ogt: 10689,
	ohm: 8486,
	olt: 10688,
	ord: 10845,
	orv: 10843,
	par: 8741,
	pcy: 1087,
	pfr: 120109,
	phi: 966,
	piv: 982,
	prE: 10931,
	pre: 10927,
	psi: 968,
	qfr: 120110,
	rcy: 1088,
	reg: 174,
	rfr: 120111,
	rho: 961,
	rlm: 8207,
	rsh: 8625,
	scE: 10932,
	sce: 10928,
	scy: 1089,
	sfr: 120112,
	shy: 173,
	sim: 8764,
	smt: 10922,
	sol: 47,
	squ: 9633,
	sub: 8834,
	sum: 8721,
	sup: 8835,
	tau: 964,
	tcy: 1090,
	tfr: 120113,
	top: 8868,
	ucy: 1091,
	ufr: 120114,
	uml: 168,
	vcy: 1074,
	vee: 8744,
	vfr: 120115,
	wfr: 120116,
	xfr: 120117,
	ycy: 1099,
	yen: 165,
	yfr: 120118,
	zcy: 1079,
	zfr: 120119,
	zwj: 8205,
	DD: 8517,
	GT: 62,
	Gg: 8921,
	Gt: 8811,
	Im: 8465,
	LT: 60,
	Ll: 8920,
	Lt: 8810,
	Mu: 924,
	Nu: 925,
	Or: 10836,
	Pi: 928,
	Pr: 10939,
	Re: 8476,
	Sc: 10940,
	Xi: 926,
	ac: 8766,
	af: 8289,
	ap: 8776,
	dd: 8518,
	ee: 8519,
	eg: 10906,
	el: 10905,
	gE: 8807,
	ge: 8805,
	gg: 8811,
	gl: 8823,
	gt: 62,
	ic: 8291,
	ii: 8520,
	in: 8712,
	it: 8290,
	lE: 8806,
	le: 8804,
	lg: 8822,
	ll: 8810,
	lt: 60,
	mp: 8723,
	mu: 956,
	ne: 8800,
	ni: 8715,
	nu: 957,
	oS: 9416,
	or: 8744,
	pi: 960,
	pm: 177,
	pr: 8826,
	rx: 8478,
	sc: 8827,
	wp: 8472,
	wr: 8768,
	xi: 958
};

const windows1252 = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];
const entityPattern = new RegExp( `&(#?(?:x[\\w\\d]+|\\d+|${Object.keys( htmlEntities ).join( '|' )}));?`, 'g' );

function decodeCharacterReferences ( html ) {
	return html.replace( entityPattern, ( match, entity ) => {
		let code;

		// Handle named entities
		if ( entity[0] !== '#' ) {
			code = htmlEntities[ entity ];
		} else if ( entity[1] === 'x' ) {
			code = parseInt( entity.substring( 2 ), 16 );
		} else {
			code = parseInt( entity.substring( 1 ), 10 );
		}

		if ( !code ) {
			return match;
		}

		return String.fromCodePoint( validateCode( code ) );
	});
}

const NUL = 0;

// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
// code points with alternatives in some cases - since we're bypassing that mechanism, we need
// to replace them ourselves
//
// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
function validateCode ( code ) {
	// line feed becomes generic whitespace
	if ( code === 10 ) {
		return 32;
	}

	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
	if ( code < 128 ) {
		return code;
	}

	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
	// to correct the mistake or we'll end up with missing € signs and so on
	if ( code <= 159 ) {
		return windows1252[ code - 128 ];
	}

	// basic multilingual plane
	if ( code < 55296 ) {
		return code;
	}

	// UTF-16 surrogate halves
	if ( code <= 57343 ) {
		return NUL;
	}

	// rest of the basic multilingual plane
	if ( code <= 65535 ) {
		return code;
	}

	// supplementary multilingual plane 0x10000 - 0x1ffff
	if ( code >= 65536 && code <= 131071 ) {
		return code;
	}

	// supplementary ideographic plane 0x20000 - 0x2ffff
	if ( code >= 131072 && code <= 196607 ) {
		return code;
	}

	return NUL;
}

const voidElementNames = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;

function isVoidElementName ( name ) {
	return voidElementNames.test( name ) || name.toLowerCase() === '!doctype';
}

const validTagName = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
const invalidUnquotedAttributeCharacters = /[\s"'=<>\/`]/;

const SELF = ':Self';

const metaTags = {
	':Window': true
};

const specials = new Map( [
	[ 'script', {
		read: readScript,
		property: 'js'
	} ],
	[ 'style', {
		read: readStyle,
		property: 'css'
	} ]
] );

// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
const disallowedContents = new Map( [
	[ 'li', new Set( [ 'li' ] ) ],
	[ 'dt', new Set( [ 'dt', 'dd' ] ) ],
	[ 'dd', new Set( [ 'dt', 'dd' ] ) ],
	[ 'p', new Set( 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ) ) ],
	[ 'rt', new Set( [ 'rt', 'rp' ] ) ],
	[ 'rp', new Set( [ 'rt', 'rp' ] ) ],
	[ 'optgroup', new Set( [ 'optgroup' ] ) ],
	[ 'option', new Set( [ 'option', 'optgroup' ] ) ],
	[ 'thead', new Set( [ 'tbody', 'tfoot' ] ) ],
	[ 'tbody', new Set( [ 'tbody', 'tfoot' ] ) ],
	[ 'tfoot', new Set( [ 'tbody' ] ) ],
	[ 'tr', new Set( [ 'tr', 'tbody' ] ) ],
	[ 'td', new Set( [ 'td', 'th', 'tr' ] ) ],
	[ 'th', new Set( [ 'td', 'th', 'tr' ] ) ] ] );

function stripWhitespace ( element ) {
	if ( element.children.length ) {
		const firstChild = element.children[0];
		const lastChild = element.children[ element.children.length - 1 ];

		if ( firstChild.type === 'Text' ) {
			firstChild.data = trimStart( firstChild.data );
			if ( !firstChild.data ) { element.children.shift(); }
		}

		if ( lastChild.type === 'Text' ) {
			lastChild.data = trimEnd( lastChild.data );
			if ( !lastChild.data ) { element.children.pop(); }
		}
	}
}

function tag ( parser ) {
	const start = parser.index++;

	let parent = parser.current();

	if ( parser.eat( '!--' ) ) {
		const data = parser.readUntil( /-->/ );
		parser.eat( '-->' );

		parser.current().children.push({
			start,
			end: parser.index,
			type: 'Comment',
			data
		});

		return null;
	}

	const isClosingTag = parser.eat( '/' );

	const name = readTagName( parser );

	if ( name in metaTags ) {
		if ( name in parser.metaTags ) {
			if ( isClosingTag && parser.current().children.length ) {
				parser.error( `<${name}> cannot have children`, parser.current().children[0].start );
			}

			parser.error( `A component can only have one <${name}> tag`, start );
		}

		parser.metaTags[ name ] = true;

		if ( parser.stack.length > 1 ) {
			parser.error( `<${name}> tags cannot be inside elements or blocks`, start );
		}
	}

	parser.allowWhitespace();

	if ( isClosingTag ) {
		if ( isVoidElementName( name ) ) {
			parser.error( `<${name}> is a void element and cannot have children, or a closing tag`, start );
		}

		if ( !parser.eat( '>' ) ) { parser.error( `Expected '>'` ); }

		// close any elements that don't have their own closing tags, e.g. <div><p></div>
		while ( parent.name !== name ) {
			if ( parent.type !== 'Element' ) { parser.error( `</${name}> attempted to close an element that was not open`, start ); }

			parent.end = start;
			parser.stack.pop();

			parent = parser.current();
		}

		// strip leading/trailing whitespace as necessary
		stripWhitespace( parent );

		parent.end = parser.index;
		parser.stack.pop();

		return null;
	} else if ( disallowedContents.has( parent.name ) ) {
		// can this be a child of the parent element, or does it implicitly
		// close it, like `<li>one<li>two`?
		if ( disallowedContents.get( parent.name ).has( name ) ) {
			stripWhitespace( parent );

			parent.end = start;
			parser.stack.pop();
		}
	}

	const attributes = [];
	const uniqueNames = new Set();

	let attribute;
	while ( attribute = readAttribute( parser, uniqueNames ) ) {
		attributes.push( attribute );
		parser.allowWhitespace();
	}

	parser.allowWhitespace();

	// special cases – top-level <script> and <style>
	if ( specials.has( name ) && parser.stack.length === 1 ) {
		const special = specials.get( name );

		if ( parser[ special.property ] ) {
			parser.index = start;
			parser.error( `You can only have one top-level <${name}> tag per component` );
		}

		parser.eat( '>', true );
		parser[ special.property ] = special.read( parser, start, attributes );
		return;
	}

	const element = {
		start,
		end: null, // filled in later
		type: 'Element',
		name,
		attributes,
		children: []
	};

	parser.current().children.push( element );

	const selfClosing = parser.eat( '/' ) || isVoidElementName( name );

	parser.eat( '>', true );

	if ( selfClosing ) {
		element.end = parser.index;
	} else {
		// don't push self-closing elements onto the stack
		parser.stack.push( element );
	}

	return null;
}

function readTagName ( parser ) {
	const start = parser.index;

	if ( parser.eat( SELF ) ) {
		// check we're inside a block, otherwise this
		// will cause infinite recursion
		let i = parser.stack.length;
		let legal = false;

		while ( i-- ) {
			const fragment = parser.stack[i];
			if ( fragment.type === 'IfBlock' || fragment.type === 'EachBlock' ) {
				legal = true;
				break;
			}
		}

		if ( !legal ) {
			parser.error( `<${SELF}> components can only exist inside if-blocks or each-blocks`, start );
		}

		return SELF;
	}

	const name = parser.readUntil( /(\s|\/|>)/ );

	if ( name in metaTags ) { return name; }

	if ( !validTagName.test( name ) ) {
		parser.error( `Expected valid tag name`, start );
	}

	return name;
}

function readAttribute ( parser, uniqueNames ) {
	const start = parser.index;

	let name = parser.readUntil( /(\s|=|\/|>)/ );
	if ( !name ) { return null; }
	if ( uniqueNames.has( name ) ) {
		parser.error( 'Attributes need to be unique', start );
	}

	uniqueNames.add( name );

	parser.allowWhitespace();

	if ( /^on:/.test( name ) ) {
		parser.eat( '=', true );
		return readEventHandlerDirective( parser, start, name.slice( 3 ) );
	}

	if ( /^bind:/.test( name ) ) {
		return readBindingDirective( parser, start, name.slice( 5 ) );
	}

	if ( /^ref:/.test( name ) ) {
		return {
			start,
			end: parser.index,
			type: 'Ref',
			name: name.slice( 4 )
		};
	}

	const match = /^(in|out|transition):/.exec( name );
	if ( match ) {
		return readTransitionDirective( parser, start, name.slice( match[0].length ), match[1] );
	}

	let value;

	// :foo is shorthand for foo='{{foo}}'
	if ( /^:\w+$/.test( name ) ) {
		name = name.slice( 1 );
		value = getShorthandValue( start + 1, name );
	} else {
		value = parser.eat( '=' ) ? readAttributeValue( parser ) : true;
	}

	return {
		start,
		end: parser.index,
		type: 'Attribute',
		name,
		value
	};
}

function readAttributeValue ( parser ) {
	let quoteMark;

	if ( parser.eat( `'` ) ) { quoteMark = `'`; }
	if ( parser.eat( `"` ) ) { quoteMark = `"`; }

	let currentChunk = {
		start: parser.index,
		end: null,
		type: 'Text',
		data: ''
	};

	const done = quoteMark ?
		char => char === quoteMark :
		char => invalidUnquotedAttributeCharacters.test( char );

	const chunks = [];

	while ( parser.index < parser.template.length ) {
		const index = parser.index;

		if ( parser.eat( '{{' ) ) {
			if ( currentChunk.data ) {
				currentChunk.end = index;
				chunks.push( currentChunk );
			}

			const expression = readExpression( parser );
			parser.allowWhitespace();
			if ( !parser.eat( '}}' ) ) {
				parser.error( `Expected }}` );
			}

			chunks.push({
				start: index,
				end: parser.index,
				type: 'MustacheTag',
				expression
			});

			currentChunk = {
				start: parser.index,
				end: null,
				type: 'Text',
				data: ''
			};
		}

		else if ( done( parser.template[ parser.index ] ) ) {
			currentChunk.end = parser.index;
			if ( quoteMark ) { parser.index += 1; }

			if ( currentChunk.data ) { chunks.push( currentChunk ); }

			chunks.forEach( chunk => {
				if ( chunk.type === 'Text' ) { chunk.data = decodeCharacterReferences( chunk.data ); }
			});

			return chunks;
		}

		else {
			currentChunk.data += parser.template[ parser.index++ ];
		}
	}

	parser.error( `Unexpected end of input` );
}

function getShorthandValue ( start, name ) {
	const end = start + name.length;

	return [{
		type: 'AttributeShorthand',
		start,
		end,
		expression: {
			type: 'Identifier',
			start,
			end,
			name
		}
	}];
}

const validIdentifier = /[a-zA-Z_$][a-zA-Z0-9_$]*/;

function trimWhitespace ( block, trimBefore, trimAfter ) {
	const firstChild = block.children[0];
	const lastChild = block.children[ block.children.length - 1 ];

	if ( firstChild.type === 'Text' && trimBefore ) {
		firstChild.data = trimStart( firstChild.data );
		if ( !firstChild.data ) { block.children.shift(); }
	}

	if ( lastChild.type === 'Text' && trimAfter ) {
		lastChild.data = trimEnd( lastChild.data );
		if ( !lastChild.data ) { block.children.pop(); }
	}

	if ( block.else ) {
		trimWhitespace( block.else, trimBefore, trimAfter );
	}

	if ( firstChild.elseif ) {
		trimWhitespace( firstChild, trimBefore, trimAfter );
	}
}

function mustache ( parser ) {
	const start = parser.index;
	parser.index += 2;

	parser.allowWhitespace();

	// {{/if}} or {{/each}}
	if ( parser.eat( '/' ) ) {
		let block = parser.current();
		let expected;

		if ( block.type === 'ElseBlock' ) {
			block.end = start;
			parser.stack.pop();
			block = parser.current();
		}

		if ( block.type === 'IfBlock' ) {
			expected = 'if';
		} else if ( block.type === 'EachBlock' ) {
			expected = 'each';
		} else {
			parser.error( `Unexpected block closing tag` );
		}

		parser.eat( expected, true );
		parser.allowWhitespace();
		parser.eat( '}}', true );

		while ( block.elseif ) {
			block.end = parser.index;
			parser.stack.pop();
			block = parser.current();

			if ( block.else ) {
				block.else.end = start;
			}
		}

		// strip leading/trailing whitespace as necessary
		if ( !block.children.length ) { parser.error( `Empty block`, block.start ); }

		const charBefore = parser.template[ block.start - 1 ];
		const charAfter = parser.template[ parser.index ];
		const trimBefore = !charBefore || whitespace.test( charBefore );
		const trimAfter = !charAfter || whitespace.test( charAfter );

		trimWhitespace( block, trimBefore, trimAfter );

		block.end = parser.index;
		parser.stack.pop();
	}

	else if ( parser.eat( 'elseif' ) ) {
		const block = parser.current();
		if ( block.type !== 'IfBlock' ) { parser.error( 'Cannot have an {{elseif ...}} block outside an {{#if ...}} block' ); }

		parser.requireWhitespace();

		const expression = readExpression( parser );

		parser.allowWhitespace();
		parser.eat( '}}', true );

		block.else = {
			start: parser.index,
			end: null,
			type: 'ElseBlock',
			children: [
				{
					start: parser.index,
					end: null,
					type: 'IfBlock',
					elseif: true,
					expression,
					children: []
				}
			]
		};

		parser.stack.push( block.else.children[0] );
	}

	else if ( parser.eat( 'else' ) ) {
		const block = parser.current();
		if ( block.type !== 'IfBlock' && block.type !== 'EachBlock' ) {
			parser.error( 'Cannot have an {{else}} block outside an {{#if ...}} or {{#each ...}} block' );
		}

		parser.allowWhitespace();
		parser.eat( '}}', true );

		block.else = {
			start: parser.index,
			end: null,
			type: 'ElseBlock',
			children: []
		};

		parser.stack.push( block.else );
	}

	// {{#if foo}} or {{#each foo}}
	else if ( parser.eat( '#' ) ) {
		let type;

		if ( parser.eat( 'if' ) ) {
			type = 'IfBlock';
		} else if ( parser.eat( 'each' ) ) {
			type = 'EachBlock';
		} else {
			parser.error( `Expected if or each` );
		}

		parser.requireWhitespace();

		const expression = readExpression( parser );

		const block = {
			start,
			end: null,
			type,
			expression,
			children: []
		};

		parser.allowWhitespace();

		// {{#each}} blocks must declare a context – {{#each list as item}}
		if ( type === 'EachBlock' ) {
			parser.eat( 'as', true );
			parser.requireWhitespace();

			block.context = parser.read( validIdentifier ); // TODO check it's not a keyword
			if ( !block.context ) { parser.error( `Expected name` ); }

			parser.allowWhitespace();

			if ( parser.eat( ',' ) ) {
				parser.allowWhitespace();
				block.index = parser.read( validIdentifier );
				if ( !block.index ) { parser.error( `Expected name` ); }
				parser.allowWhitespace();
			}

			if ( parser.eat( '@' ) ) {
				block.key = parser.read( validIdentifier );
				if ( !block.key ) { parser.error( `Expected name` ); }
				parser.allowWhitespace();
			}
		}

		parser.eat( '}}', true );

		parser.current().children.push( block );
		parser.stack.push( block );
	}

	// {{yield}}
	else if ( parser.eat( 'yield' ) ) {

		parser.allowWhitespace();
		parser.eat( '}}', true );

		parser.current().children.push({
			start,
			end: parser.index,
			type: 'YieldTag'
		});
	}

	// {{{raw}}} mustache
	else if ( parser.eat( '{' ) ) {
		const expression = readExpression( parser );

		parser.allowWhitespace();
		parser.eat( '}}}', true );

		parser.current().children.push({
			start,
			end: parser.index,
			type: 'RawMustacheTag',
			expression
		});
	}

	else {
		const expression = readExpression( parser );

		parser.allowWhitespace();
		parser.eat( '}}', true );

		parser.current().children.push({
			start,
			end: parser.index,
			type: 'MustacheTag',
			expression
		});
	}

	return null;
}

function text ( parser ) {
	const start = parser.index;

	let data = '';

	while ( parser.index < parser.template.length && !parser.match( '<' ) && !parser.match( '{{' ) ) {
		data += parser.template[ parser.index++ ];
	}

	parser.current().children.push({
		start,
		end: parser.index,
		type: 'Text',
		data: decodeCharacterReferences( data )
	});

	return null;
}

function fragment ( parser ) {
	if ( parser.match( '<' ) ) {
		return tag;
	}

	if ( parser.match( '{{' ) ) {
		return mustache;
	}

	return text;
}

function tabsToSpaces ( str ) {
	return str.replace( /^\t+/, match => match.split( '\t' ).join( '  ' ) );
}

function getCodeFrame ( source, line, column ) {
	const lines = source.split( '\n' );

	const frameStart = Math.max( 0, line - 2 );
	const frameEnd = Math.min( line + 3, lines.length );

	const digits = String( frameEnd + 1 ).length;

	return lines
		.slice( frameStart, frameEnd )
		.map( ( str, i ) => {
			const isErrorLine = frameStart + i === line;

			let lineNum = String( i + frameStart + 1 );
			while ( lineNum.length < digits ) { lineNum = ` ${lineNum}`; }

			if ( isErrorLine ) {
				const indicator = spaces( digits + 2 + tabsToSpaces( str.slice( 0, column ) ).length ) + '^';
				return `${lineNum}: ${tabsToSpaces( str )}\n${indicator}`;
			}

			return `${lineNum}: ${tabsToSpaces( str )}`;
		})
		.join( '\n' );
}

// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash ( str ) {
	let hash = 5381;
	let i = str.length;

	while ( i-- ) { hash = ( hash * 33 ) ^ str.charCodeAt( i ); }
	return hash >>> 0;
}

function ParseError ( message, template, index, filename ) {
	var ref = locate( template, index );
	var line = ref.line;
	var column = ref.column;

	this.name = 'ParseError';
	this.message = message;
	this.frame = getCodeFrame( template, line, column );

	this.loc = { line: line + 1, column };
	this.pos = index;
	this.filename = filename;
}

ParseError.prototype.toString = function () {
	return `${this.message} (${this.loc.line}:${this.loc.column})\n${this.frame}`;
};

function parse ( template, options ) {
	if ( options === void 0 ) options = {};

	if ( typeof template !== 'string' ) {
		throw new TypeError( 'Template must be a string' );
	}

	template = template.replace( /\s+$/, '' );

	const parser = {
		index: 0,
		template,
		stack: [],
		metaTags: {},

		current () {
			return this.stack[ this.stack.length - 1 ];
		},

		acornError ( err ) {
			parser.error( err.message.replace( / \(\d+:\d+\)$/, '' ), err.pos );
		},

		error ( message, index ) {
			if ( index === void 0 ) index = this.index;

			throw new ParseError( message, this.template, index, options.filename );
		},

		eat ( str, required ) {
			if ( this.match( str ) ) {
				this.index += str.length;
				return true;
			}

			if ( required ) {
				this.error( `Expected ${str}` );
			}
		},

		match ( str ) {
			return this.template.slice( this.index, this.index + str.length ) === str;
		},

		allowWhitespace () {
			while ( this.index < this.template.length && whitespace.test( this.template[ this.index ] ) ) {
				this.index++;
			}
		},

		read ( pattern ) {
			const match = pattern.exec( this.template.slice( this.index ) );
			if ( !match || match.index !== 0 ) { return null; }

			parser.index += match[0].length;

			return match[0];
		},

		readUntil ( pattern ) {
			if ( this.index >= this.template.length ) { parser.error( 'Unexpected end of input' ); }

			const start = this.index;
			const match = pattern.exec( this.template.slice( start ) );

			if ( match ) {
				const start = this.index;
				this.index = start + match.index;
				return this.template.slice( start, this.index );
			}

			this.index = this.template.length;
			return this.template.slice( start );
		},

		remaining () {
			return this.template.slice( this.index );
		},

		requireWhitespace () {
			if ( !whitespace.test( this.template[ this.index ] ) ) {
				this.error( `Expected whitespace` );
			}

			this.allowWhitespace();
		},

		html: {
			start: null,
			end: null,
			type: 'Fragment',
			children: []
		},

		css: null,

		js: null
	};

	parser.stack.push( parser.html );

	let state = fragment;

	while ( parser.index < parser.template.length ) {
		state = state( parser ) || fragment;
	}

	if ( parser.stack.length > 1 ) {
		const current = parser.current();

		const type = current.type === 'Element' ? `<${current.name}>` : 'Block';
		parser.error( `${type} was left open`, current.start );
	}

	if ( state !== fragment ) {
		parser.error( 'Unexpected end of input' );
	}

	// trim unnecessary whitespace
	while ( parser.html.children.length ) {
		const firstChild = parser.html.children[0];
		parser.html.start = firstChild.start;

		if ( firstChild.type !== 'Text' ) { break; }

		const length = firstChild.data.length;
		firstChild.data = trimStart( firstChild.data );

		if ( firstChild.data === '' ) {
			parser.html.children.shift();
		} else {
			parser.html.start += length - firstChild.data.length;
			break;
		}
	}

	while ( parser.html.children.length ) {
		const lastChild = parser.html.children[ parser.html.children.length - 1 ];
		parser.html.end = lastChild.end;

		if ( lastChild.type !== 'Text' ) { break; }

		const length = lastChild.data.length;
		lastChild.data = trimEnd( lastChild.data );

		if ( lastChild.data === '' ) {
			parser.html.children.pop();
		} else {
			parser.html.end -= length - lastChild.data.length;
			break;
		}
	}

	return {
		hash: hash( template ),
		html: parser.html,
		css: parser.css,
		js: parser.js
	};
}

const disallowed = new Set( [ 'Literal', 'ObjectExpression', 'ArrayExpression' ] );

function data ( validator, prop ) {
	while ( prop.type === 'ParenthesizedExpression' ) { prop = prop.expression; }

	// TODO should we disallow references and expressions as well?

	if ( disallowed.has( prop.value.type ) ) {
		validator.error( `'data' must be a function`, prop.value.start );
	}
}

function checkForDupes ( validator, properties ) {
	const seen = new Set();

	properties.forEach( prop => {
		if ( seen.has( prop.key.name ) ) {
			validator.error( `Duplicate property '${prop.key.name}'`, prop.start );
		}

		seen.add( prop.key.name );
	});
}

function checkForComputedKeys ( validator, properties ) {
	properties.forEach( prop => {
		if ( prop.key.computed ) {
			validator.error( `Cannot use computed keys`, prop.start );
		}
	});
}

const isFunctionExpression = new Set( [ 'FunctionExpression', 'ArrowFunctionExpression' ] );

function computed ( validator, prop ) {
	if ( prop.value.type !== 'ObjectExpression' ) {
		validator.error( `The 'computed' property must be an object literal`, prop.start );
		return;
	}

	checkForDupes( validator, prop.value.properties );
	checkForComputedKeys( validator, prop.value.properties );

	prop.value.properties.forEach( computation => {
		if ( !isFunctionExpression.has( computation.value.type ) ) {
			validator.error( `Computed properties can be function expressions or arrow function expressions`, computation.value.start );
			return;
		}

		const params = computation.value.params;

		if ( params.length === 0 ) {
			validator.error( `A computed value must depend on at least one property`, computation.value.start );
			return;
		}

		params.forEach( param => {
			const valid = param.type === 'Identifier' || param.type === 'AssignmentPattern' && param.left.type === 'Identifier';

			if ( !valid ) {
				validator.error( `Computed properties cannot use destructuring in function parameters`, param.start );
			}
		});
	});
}

function walk$2 ( ast, ref) {
	var enter = ref.enter;
	var leave = ref.leave;

	visit( ast, null, enter, leave );
}

var context = {
	skip: function () { return context.shouldSkip = true; },
	shouldSkip: false
};

var childKeys = {};

var toString = Object.prototype.toString;

function isArray$1 ( thing ) {
	return toString.call( thing ) === '[object Array]';
}

function visit ( node, parent, enter, leave, prop, index ) {
	if ( !node ) { return; }

	if ( enter ) {
		context.shouldSkip = false;
		enter.call( context, node, parent, prop, index );
		if ( context.shouldSkip ) { return; }
	}

	var keys = childKeys[ node.type ] || (
		childKeys[ node.type ] = Object.keys( node ).filter( function (key) { return typeof node[ key ] === 'object'; } )
	);

	for ( var i = 0; i < keys.length; i += 1 ) {
		var key = keys[i];
		var value = node[ key ];

		if ( isArray$1( value ) ) {
			for ( var j = 0; j < value.length; j += 1 ) {
				visit( value[j], node, enter, leave, key, j );
			}
		}

		else if ( value && value.type ) {
			visit( value, node, enter, leave, key, null );
		}
	}

	if ( leave ) {
		leave( node, parent, prop, index );
	}
}

function isReference ( node, parent ) {
	if ( node.type === 'MemberExpression' ) {
		return !node.computed && isReference( node.object, node );
	}

	if ( node.type === 'Identifier' ) {
		// the only time we could have an identifier node without a parent is
		// if it's the entire body of a function without a block statement –
		// i.e. an arrow function expression like `a => a`
		if ( !parent ) { return true; }

		// TODO is this right?
		if ( parent.type === 'MemberExpression' || parent.type === 'MethodDefinition' ) {
			return parent.computed || node === parent.object;
		}

		// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
		if ( parent.type === 'Property' ) { return parent.computed || node === parent.value; }

		// disregard the `bar` in `class Foo { bar () {...} }`
		if ( parent.type === 'MethodDefinition' ) { return false; }

		// disregard the `bar` in `export { foo as bar }`
		if ( parent.type === 'ExportSpecifier' && node !== parent.local ) { return; }

		return true;
	}
}

function usesThisOrArguments ( node ) {
	let result = false;

	walk$2( node, {
		enter ( node ) {
			if ( result || node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' ) {
				return this.skip();
			}

			if ( node.type === 'ThisExpression' ) {
				result = true;
			}

			if ( node.type === 'Identifier' && isReference( node ) && node.name === 'arguments' ) {
				result = true;
			}
		}
	});

	return result;
}

function oncreate ( validator, prop ) {
	if ( prop.value.type === 'ArrowFunctionExpression' ) {
		if ( usesThisOrArguments( prop.value.body ) ) {
			validator.error( `'oncreate' should be a function expression, not an arrow function expression`, prop.start );
		}
	}
}

function ondestroy ( validator, prop ) {
	if ( prop.value.type === 'ArrowFunctionExpression' ) {
		if ( usesThisOrArguments( prop.value.body ) ) {
			validator.error( `'ondestroy' should be a function expression, not an arrow function expression`, prop.start );
		}
	}
}

function onrender ( validator, prop ) {
	validator.warn( `'onrender' has been deprecated in favour of 'oncreate', and will cause an error in Svelte 2.x`, prop.start );
	oncreate( validator, prop );
}

function onteardown ( validator, prop ) {
	validator.warn( `'onteardown' has been deprecated in favour of 'ondestroy', and will cause an error in Svelte 2.x`, prop.start );
	ondestroy( validator, prop );
}

function helpers ( validator, prop ) {
	if ( prop.value.type !== 'ObjectExpression' ) {
		validator.error( `The 'helpers' property must be an object literal`, prop.start );
		return;
	}

	checkForDupes( validator, prop.value.properties );
	checkForComputedKeys( validator, prop.value.properties );

	prop.value.properties.forEach( prop => {
		if ( !/FunctionExpression/.test( prop.value.type ) ) { return; }

		let lexicalDepth = 0;
		let usesArguments = false;

		walk$2( prop.value.body, {
			enter ( node ) {
				if ( /^Function/.test( node.type ) ) {
					lexicalDepth += 1;
				}

				else if ( lexicalDepth === 0 ) {
					// handle special case that's caused some people confusion — using `this.get(...)` instead of passing argument
					// TODO do the same thing for computed values?
					if ( node.type === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.object.type === 'ThisExpression' && node.callee.property.name === 'get' && !node.callee.property.computed ) {
						validator.error( `Cannot use this.get(...) — it must be passed into the helper function as an argument`, node.start );
					}

					if ( node.type === 'ThisExpression' ) {
						validator.error( `Helpers should be pure functions — they do not have access to the component instance and cannot use 'this'. Did you mean to put this in 'methods'?`, node.start );
					}

					else if ( node.type === 'Identifier' && node.name === 'arguments' ) {
						usesArguments = true;
					}
				}
			},

			leave ( node ) {
				if ( /^Function/.test( node.type ) ) {
					lexicalDepth -= 1;
				}
			}
		});

		if ( prop.value.params.length === 0 && !usesArguments ) {
			validator.warn( `Helpers should be pure functions, with at least one argument`, prop.start );
		}
	});
}

function checkForAccessors ( validator, properties, label ) {
	properties.forEach( prop => {
		if ( prop.kind !== 'init' ) {
			validator.error( `${label} cannot use getters and setters`, prop.start );
		}
	});
}

const builtin = new Set( [ 'set', 'get', 'on', 'fire', 'observe', 'destroy' ] );

function methods ( validator, prop ) {
	if ( prop.value.type !== 'ObjectExpression' ) {
		validator.error( `The 'methods' property must be an object literal`, prop.start );
		return;
	}

	checkForAccessors( validator, prop.value.properties, 'Methods' );
	checkForDupes( validator, prop.value.properties );
	checkForComputedKeys( validator, prop.value.properties );

	prop.value.properties.forEach( prop => {
		if ( builtin.has( prop.key.name ) ) {
			validator.error( `Cannot overwrite built-in method '${prop.key.name}'` );
		}

		if ( prop.value.type === 'ArrowFunctionExpression' ) {
			if ( usesThisOrArguments( prop.value.body ) ) {
				validator.error( `Method '${prop.key.name}' should be a function expression, not an arrow function expression`, prop.start );
			}
		}
	});
}

function components ( validator, prop ) {
	if ( prop.value.type !== 'ObjectExpression' ) {
		validator.error( `The 'components' property must be an object literal`, prop.start );
		return;
	}

	checkForDupes( validator, prop.value.properties );
	checkForComputedKeys( validator, prop.value.properties );

	prop.value.properties.forEach( component => {
		if ( component.key.name === 'state' ) {
			validator.error( `Component constructors cannot be called 'state' due to technical limitations`, component.start );
		}

		if ( !/^[A-Z]/.test( component.key.name ) ) {
			validator.warn( `Component names should be capitalised`, component.start );
		}
	});
}

function events ( validator, prop ) {
	if ( prop.value.type !== 'ObjectExpression' ) {
		validator.error( `The 'events' property must be an object literal`, prop.start );
		return;
	}

	checkForDupes( validator, prop.value.properties );
	checkForComputedKeys( validator, prop.value.properties );
}

const html   = 'http://www.w3.org/1999/xhtml';
const mathml = 'http://www.w3.org/1998/Math/MathML';
const svg    = 'http://www.w3.org/2000/svg';
const xlink  = 'http://www.w3.org/1999/xlink';
const xml    = 'http://www.w3.org/XML/1998/namespace';
const xmlns  = 'http://www.w3.org/2000/xmlns';

const validNamespaces = [
	'html', 'mathml', 'svg', 'xlink', 'xml', 'xmlns',
	html, mathml, svg, xlink, xml, xmlns
];

var namespaces = { html, mathml, svg, xlink, xml, xmlns };

// adapted from https://github.com/Glench/this.js/blob/master/lib/this.js
// BSD Licensed

function FuzzySet (arr, useLevenshtein, gramSizeLower, gramSizeUpper) {
	// default options
	arr = arr || [];
	this.gramSizeLower = gramSizeLower || 2;
	this.gramSizeUpper = gramSizeUpper || 3;
	this.useLevenshtein = (typeof useLevenshtein !== 'boolean') ? true : useLevenshtein;

	// define all the object functions and attributes
	this.exactSet = {};
	this.matchDict = {};
	this.items = {};

	// helper functions
	function levenshtein ( str1, str2 ) {
		const current = [];
		let prev;
		let value;

		for (let i = 0; i <= str2.length; i++) {
			for (let j = 0; j <= str1.length; j++) {
				if (i && j) {
					if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
						value = prev;
					} else {
						value = Math.min(current[j], current[j - 1], prev) + 1;
					}
				} else {
					value = i + j;
				}

				prev = current[j];
				current[j] = value;
			}
		}

		return current.pop();
	}

	// return an edit distance from 0 to 1
	function _distance (str1, str2) {
		if (str1 === null && str2 === null) { throw 'Trying to compare two null values'; }
		if (str1 === null || str2 === null) { return 0; }
		str1 = String(str1); str2 = String(str2);

		const distance = levenshtein(str1, str2);
		if (str1.length > str2.length) {
			return 1 - distance / str1.length;
		} else {
			return 1 - distance / str2.length;
		}
	}

	const _nonWordRe = /[^\w, ]+/;

	function _iterateGrams (value, gramSize) {
		gramSize = gramSize || 2;
		const simplified = '-' + value.toLowerCase().replace(_nonWordRe, '') + '-';
		const lenDiff = gramSize - simplified.length;
		const results = [];

		if (lenDiff > 0) {
			for (let i = 0; i < lenDiff; ++i) {
				value += '-';
			}
		}
		for (let i = 0; i < simplified.length - gramSize + 1; ++i) {
			results.push(simplified.slice(i, i + gramSize));
		}
		return results;
	}

	function _gramCounter (value, gramSize) {
		// return an object where key=gram, value=number of occurrences
		gramSize = gramSize || 2;
		const result = {};
		const grams = _iterateGrams(value, gramSize);
		let i = 0;

		for (i; i < grams.length; ++i) {
			if (grams[i] in result) {
				result[grams[i]] += 1;
			} else {
				result[grams[i]] = 1;
			}
		}
		return result;
	}

	// the main functions
	this.get = function (value, defaultValue) {
		// check for value in set, returning defaultValue or null if none found
		const result = this._get(value);
		if (!result && typeof defaultValue !== 'undefined') {
			return defaultValue;
		}
		return result;
	};

	this._get = function (value) {
		const normalizedValue = this._normalizeStr(value);
		const result = this.exactSet[normalizedValue];

		if (result) {
			return [[1, result]];
		}

		let results = [];
		// start with high gram size and if there are no results, go to lower gram sizes
		for (let gramSize = this.gramSizeUpper; gramSize >= this.gramSizeLower; --gramSize) {
			results = this.__get(value, gramSize);
			if (results) {
				return results;
			}
		}
		return null;
	};

	this.__get = function (value, gramSize) {
		const normalizedValue = this._normalizeStr(value);
		const matches = {};
		const gramCounts = _gramCounter(normalizedValue, gramSize);
		const items = this.items[gramSize];
		let sumOfSquareGramCounts = 0;
		let gram;
		let gramCount;
		let i;
		let index;
		let otherGramCount;

		for (gram in gramCounts) {
			gramCount = gramCounts[gram];
			sumOfSquareGramCounts += Math.pow(gramCount, 2);
			if (gram in this.matchDict) {
				for (i = 0; i < this.matchDict[gram].length; ++i) {
					index = this.matchDict[gram][i][0];
					otherGramCount = this.matchDict[gram][i][1];
					if (index in matches) {
						matches[index] += gramCount * otherGramCount;
					} else {
						matches[index] = gramCount * otherGramCount;
					}
				}
			}
		}

		function isEmptyObject ( obj ) {
			for ( const prop in obj ) {
				if ( obj.hasOwnProperty( prop ) )
					{ return false; }
			}
			return true;
		}

		if (isEmptyObject(matches)) {
			return null;
		}

		const vectorNormal = Math.sqrt(sumOfSquareGramCounts);
		let results = [];
		let matchScore;

		// build a results list of [score, str]
		for (const matchIndex in matches) {
			matchScore = matches[matchIndex];
			results.push([matchScore / (vectorNormal * items[matchIndex][0]), items[matchIndex][1]]);
		}
		function sortDescending (a, b) {
			if (a[0] < b[0]) {
				return 1;
			} else if (a[0] > b[0]) {
				return -1;
			} else {
				return 0;
			}
		}

		results.sort(sortDescending);
		if (this.useLevenshtein) {
			const newResults = [];
			const endIndex = Math.min(50, results.length);
			// truncate somewhat arbitrarily to 50
			for (let i = 0; i < endIndex; ++i) {
				newResults.push([_distance(results[i][1], normalizedValue), results[i][1]]);
			}
			results = newResults;
			results.sort(sortDescending);
		}
		const newResults = [];
		for (let i = 0; i < results.length; ++i) {
			if (results[i][0] == results[0][0]) {
				newResults.push([results[i][0], this.exactSet[results[i][1]]]);
			}
		}
		return newResults;
	};

	this.add = function (value) {
		const normalizedValue = this._normalizeStr(value);
		if (normalizedValue in this.exactSet) {
			return false;
		}

		let i = this.gramSizeLower;
		for (i; i < this.gramSizeUpper + 1; ++i) {
			this._add(value, i);
		}
	};

	this._add = function (value, gramSize) {
		const normalizedValue = this._normalizeStr(value);
		const items = this.items[gramSize] || [];
		const index = items.length;

		items.push(0);
		const gramCounts = _gramCounter(normalizedValue, gramSize);
		let sumOfSquareGramCounts = 0;
		let gram;
		let gramCount;

		for (gram in gramCounts) {
			gramCount = gramCounts[gram];
			sumOfSquareGramCounts += Math.pow(gramCount, 2);
			if (gram in this.matchDict) {
				this.matchDict[gram].push([index, gramCount]);
			} else {
				this.matchDict[gram] = [[index, gramCount]];
			}
		}
		const vectorNormal = Math.sqrt(sumOfSquareGramCounts);
		items[index] = [vectorNormal, normalizedValue];
		this.items[gramSize] = items;
		this.exactSet[normalizedValue] = value;
	};

	this._normalizeStr = function (str) {
		if (Object.prototype.toString.call(str) !== '[object String]') { throw 'Must use a string as argument to FuzzySet functions'; }
		return str.toLowerCase();
	};

	// return length of items in set
	this.length = function () {
		let count = 0;
		let prop;

		for (prop in this.exactSet) {
			if (this.exactSet.hasOwnProperty(prop)) {
				count += 1;
			}
		}
		return count;
	};

	// return is set is empty
	this.isEmpty = function () {
		for (const prop in this.exactSet) {
			if (this.exactSet.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	// return list of values loaded into set
	this.values = function () {
		const values = [];

		for (const prop in this.exactSet) {
			if (this.exactSet.hasOwnProperty(prop)) {
				values.push(this.exactSet[prop]);
			}
		}
		return values;
	};


	// initialization
	let i = this.gramSizeLower;
	for (i; i < this.gramSizeUpper + 1; ++i) {
		this.items[i] = [];
	}
	// add all the items to the set
	for (i = 0; i < arr.length; ++i) {
		this.add(arr[i]);
	}

	return this;
}

function fuzzymatch ( name, names ) {
	const set = new FuzzySet( names );
	const matches = set.get( name );

	return matches && matches[0] && matches[0][0] > 0.7 ?
		matches[0][1] :
		null;
}

const valid = new Set( validNamespaces );

function namespace ( validator, prop ) {
	const ns = prop.value.value;

	if ( prop.value.type !== 'Literal' || typeof ns !== 'string' ) {
		validator.error( `The 'namespace' property must be a string literal representing a valid namespace`, prop.start );
	}

	if ( !valid.has( ns ) ) {
		const match = fuzzymatch( ns, validNamespaces );
		if ( match ) {
			validator.error( `Invalid namespace '${ns}' (did you mean '${match}'?)`, prop.start );
		} else {
			validator.error( `Invalid namespace '${ns}'`, prop.start );
		}
	}
}

function transitions ( validator, prop ) {
	if ( prop.value.type !== 'ObjectExpression' ) {
		validator.error( `The 'transitions' property must be an object literal`, prop.start );
		return;
	}

	checkForDupes( validator, prop.value.properties );
	checkForComputedKeys( validator, prop.value.properties );

	prop.value.properties.forEach( () => {
		// TODO probably some validation that can happen here...
		// checking for use of `this` etc?
	});
}

var propValidators = {
	data,
	computed,
	oncreate,
	ondestroy,
	onrender,
	onteardown,
	helpers,
	methods,
	components,
	events,
	namespace,
	transitions
};

const validPropList = Object.keys( propValidators );

function validateJs ( validator, js ) {
	js.content.body.forEach( node => {
		// check there are no named exports
		if ( node.type === 'ExportNamedDeclaration' ) {
			validator.error( `A component can only have a default export`, node.start );
		}

		if ( node.type === 'ExportDefaultDeclaration' ) {
			if ( node.declaration.type !== 'ObjectExpression' ) {
				return validator.error( `Default export must be an object literal`, node.declaration.start );
			}

			checkForComputedKeys( validator, node.declaration.properties );
			checkForDupes( validator, node.declaration.properties );

			const props = validator.properties;

			node.declaration.properties.forEach( prop => {
				props[ prop.key.name ] = prop;
			});

			// Remove these checks in version 2
			if ( props.oncreate && props.onrender ) {
				validator.error( 'Cannot have both oncreate and onrender', props.onrender.start );
			}

			if ( props.ondestroy && props.onteardown ) {
				validator.error( 'Cannot have both ondestroy and onteardown', props.onteardown.start );
			}

			// ensure all exported props are valid
			node.declaration.properties.forEach( prop => {
				const propValidator = propValidators[ prop.key.name ];

				if ( propValidator ) {
					propValidator( validator, prop );
				} else {
					const match = fuzzymatch( prop.key.name, validPropList );
					if ( match ) {
						validator.error( `Unexpected property '${prop.key.name}' (did you mean '${match}'?)`, prop.start );
					} else if ( /FunctionExpression/.test( prop.value.type ) ) {
						validator.error( `Unexpected property '${prop.key.name}' (did you mean to include it in 'methods'?)`, prop.start );
					} else {
						validator.error( `Unexpected property '${prop.key.name}'`, prop.start );
					}
				}
			});

			if ( props.namespace ) {
				const ns = props.namespace.value.value;
				validator.namespace = namespaces[ ns ] || ns;
			}

			validator.defaultExport = node;
		}
	});

	[ 'components', 'methods', 'helpers', 'transitions' ].forEach( key => {
		if ( validator.properties[ key ] ) {
			validator.properties[ key ].value.properties.forEach( prop => {
				validator[ key ].set( prop.key.name, prop.value );
			});
		}
	});
}

function flatten ( node ) {
	const parts = [];
	const propEnd = node.end;

	while ( node.type === 'MemberExpression' ) {
		if ( node.computed ) { return null; }
		parts.unshift( node.property.name );

		node = node.object;
	}

	const propStart = node.end;
	const name = node.type === 'Identifier' ? node.name : node.type === 'ThisExpression' ? 'this' : null;

	if ( !name ) { return null; }

	parts.unshift( name );
	return { name, parts, keypath: `${name}[✂${propStart}-${propEnd}✂]` };
}

function list$2 ( items, conjunction ) {
	if ( conjunction === void 0 ) conjunction = 'or';

	if ( items.length === 1 ) { return items[0]; }
	return `${items.slice( 0, -1 ).join( ', ' )} ${conjunction} ${items[ items.length - 1 ]}`;
}

const validBuiltins = new Set([
	'set',
	'fire',
	'destroy'
]);

function validateEventHandlerCallee ( validator, attribute ) {
	var ref = attribute.expression;
	var callee = ref.callee;
	var start = ref.start;
	var type = ref.type;

	if ( type !== 'CallExpression' ) {
		validator.error( `Expected a call expression`, start );
	}

	var ref$1 = flatten( callee );
	var name = ref$1.name;

	if ( name === 'this' || name === 'event' ) { return; }
	if ( callee.type === 'Identifier' && validBuiltins.has( callee.name ) || validator.methods.has( callee.name ) ) { return; }

	const validCallees = [ 'this.*', 'event.*' ]
		.concat(
			Array.from( validBuiltins ),
			Array.from( validator.methods.keys() )
		);

	let message = `'${validator.source.slice( callee.start, callee.end )}' is an invalid callee (should be one of ${list$2( validCallees )})`;

	if ( callee.type === 'Identifier' && validator.helpers.has( callee.name ) ) {
		message += `. '${callee.name}' exists on 'helpers', did you put it in the wrong place?`;
	}

	validator.error( message, start );
}

function validateElement ( validator, node ) {
	const isComponent = node.name === ':Self' || validator.components.has( node.name );

	let hasIntro;
	let hasOutro;
	let hasTransition;

	node.attributes.forEach( attribute => {
		if ( !isComponent && attribute.type === 'Binding' ) {
			var name = attribute.name;

			if ( name === 'value' ) {
				if ( node.name !== 'input' && node.name !== 'textarea' && node.name !== 'select' ) {
					validator.error( `'value' is not a valid binding on <${node.name}> elements`, attribute.start );
				}
			}

			else if ( name === 'checked' ) {
				if ( node.name !== 'input' ) {
					validator.error( `'checked' is not a valid binding on <${node.name}> elements`, attribute.start );
				}

				if ( getType( validator, node ) !== 'checkbox' ) {
					validator.error( `'checked' binding can only be used with <input type="checkbox">`, attribute.start );
				}
			}

			else if ( name === 'group' ) {
				if ( node.name !== 'input' ) {
					validator.error( `'group' is not a valid binding on <${node.name}> elements`, attribute.start );
				}

				const type = getType( validator, node );

				if ( type !== 'checkbox' && type !== 'radio' ) {
					validator.error( `'checked' binding can only be used with <input type="checkbox"> or <input type="radio">` );
				}
			}

			else if ( name === 'currentTime' || name === 'duration' || name === 'paused' ) {
				if ( node.name !== 'audio' && node.name !== 'video' ) {
					validator.error( `'${name}' binding can only be used with <audio> or <video>` );
				}
			}

			else {
				validator.error( `'${attribute.name}' is not a valid binding`, attribute.start );
			}
		}

		else if ( attribute.type === 'EventHandler' ) {
			validateEventHandlerCallee( validator, attribute );
		}

		else if ( attribute.type === 'Transition' ) {
			const bidi = attribute.intro && attribute.outro;

			if ( hasTransition ) {
				if ( bidi ) { validator.error( `An element can only have one 'transition' directive`, attribute.start ); }
				validator.error( `An element cannot have both a 'transition' directive and an '${attribute.intro ? 'in' : 'out'}' directive`, attribute.start );
			}

			if ( ( hasIntro && attribute.intro ) || ( hasOutro && attribute.outro ) ) {
				if ( bidi ) { validator.error( `An element cannot have both an '${hasIntro ? 'in' : 'out'}' directive and a 'transition' directive`, attribute.start ); }
				validator.error( `An element can only have one '${hasIntro ? 'in' : 'out'}' directive`, attribute.start );
			}

			if ( attribute.intro ) { hasIntro = true; }
			if ( attribute.outro ) { hasOutro = true; }
			if ( bidi ) { hasTransition = true; }

			if ( !validator.transitions.has( attribute.name ) ) {
				validator.error( `Missing transition '${attribute.name}'`, attribute.start );
			}
		}
	});
}

function getType ( validator, node ) {
	const attribute = node.attributes.find( attribute => attribute.name === 'type' );
	if ( !attribute ) { return null; }

	if ( attribute.value === true ) {
		validator.error( `'type' attribute must be specified`, attribute.start );
	}

	if ( attribute.value.length > 1 || attribute.value[0].type !== 'Text' ) {
		validator.error( `'type attribute cannot be dynamic`, attribute.start );
	}

	return attribute.value[0].data;
}

const validBindings = [
	'innerWidth',
	'innerHeight',
	'outerWidth',
	'outerHeight',
	'scrollX',
	'scrollY'
];

function validateWindow ( validator, node ) {
	node.attributes.forEach( attribute => {
		if ( attribute.type === 'Binding' ) {
			if ( attribute.value.type !== 'Identifier' ) {
				var ref = flatten( attribute.value );
				var parts = ref.parts;

				validator.error(
					`Bindings on <:Window/> must be to top-level properties, e.g. '${parts[ parts.length - 1 ]}' rather than '${parts.join( '.' )}'`,
					attribute.value.start
				);
			}

			if ( !~validBindings.indexOf( attribute.name ) ) {
				const match = (
					attribute.name === 'width' ? 'innerWidth' :
					attribute.name === 'height' ? 'innerHeight' :
					fuzzymatch( attribute.name, validBindings )
				);

				const message = `'${attribute.name}' is not a valid binding on <:Window>`;

				if ( match ) {
					validator.error( `${message} (did you mean '${match}'?)`, attribute.start );
				} else {
					validator.error( `${message} — valid bindings are ${list$2( validBindings )}`, attribute.start );
				}
			}
		}

		else if ( attribute.type === 'EventHandler' ) {
			validateEventHandlerCallee( validator, attribute );
		}
	});
}

const svg$1 = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|switch|symbol|text|textPath|title|tref|tspan|unknown|use|view|vkern)$/;

const meta = new Map([
	[ ':Window', validateWindow ]
]);

function validateHtml ( validator, html$$1 ) {
	let elementDepth = 0;

	function visit ( node ) {
		if ( node.type === 'Element' ) {
			if ( elementDepth === 0 && validator.namespace !== svg && svg$1.test( node.name ) ) {
				validator.warn( `<${node.name}> is an SVG element – did you forget to add { namespace: 'svg' } ?`, node.start );
			}

			if ( meta.has( node.name ) ) {
				return meta.get( node.name )( validator, node );
			}

			elementDepth += 1;

			validateElement( validator, node );
		}

		if ( node.children ) {
			node.children.forEach( visit );
		}

		if ( node.else ) {
			visit( node.else );
		}

		if ( node.type === 'Element' ) {
			elementDepth -= 1;
		}
	}

	html$$1.children.forEach( visit );
}

function validate ( parsed, source, ref ) {
	var onerror = ref.onerror;
	var onwarn = ref.onwarn;
	var name = ref.name;
	var filename = ref.filename;

	const locator = getLocator( source );

	const validator = {
		error: ( message, pos ) => {
			var ref = locator( pos );
			var line = ref.line;
			var column = ref.column;

			const error = new Error( message );
			error.frame = getCodeFrame( source, line, column );
			error.loc = { line: line + 1, column };
			error.pos = pos;
			error.filename = filename;

			error.toString = () => `${error.message} (${error.loc.line}:${error.loc.column})\n${error.frame}`;

			throw error;
		},

		warn: ( message, pos ) => {
			var ref = locator( pos );
			var line = ref.line;
			var column = ref.column;

			const frame = getCodeFrame( source, line, column );

			onwarn({
				message,
				frame,
				loc: { line: line + 1, column },
				pos,
				filename,
				toString: () => `${message} (${line + 1}:${column})\n${frame}`
			});
		},

		source,

		namespace: null,
		defaultExport: null,
		properties: {},
		components: new Map(),
		methods: new Map(),
		helpers: new Map(),
		transitions: new Map()
	};

	try {
		if ( name && !/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test( name ) ) {
			const error = new Error( `options.name must be a valid identifier` );
			throw error;
		}

		if ( name && !/^[A-Z]/.test( name ) ) {
			const message = `options.name should be capitalised`;
			onwarn({
				message,
				filename,
				toString: () => message
			});
		}

		if ( parsed.js ) {
			validateJs( validator, parsed.js );
		}

		if ( parsed.html ) {
			validateHtml( validator, parsed.html );
		}
	} catch ( err ) {
		if ( onerror ) {
			onerror( err );
		} else {
			throw err;
		}
	}
}

var charToInteger = {};
var integerToChar = {};

'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split( '' ).forEach( function ( char, i ) {
	charToInteger[ char ] = i;
	integerToChar[ i ] = char;
});



function encode ( value ) {
	var result;

	if ( typeof value === 'number' ) {
		result = encodeInteger( value );
	} else {
		result = '';
		for ( var i = 0; i < value.length; i += 1 ) {
			result += encodeInteger( value[i] );
		}
	}

	return result;
}

function encodeInteger ( num ) {
	var result = '';

	if ( num < 0 ) {
		num = ( -num << 1 ) | 1;
	} else {
		num <<= 1;
	}

	do {
		var clamped = num & 31;
		num >>= 5;

		if ( num > 0 ) {
			clamped |= 32;
		}

		result += integerToChar[ clamped ];
	} while ( num > 0 );

	return result;
}

function Chunk ( start, end, content ) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties( this, {
		previous: { writable: true, value: null },
		next: { writable: true, value: null }
	});
}

Chunk.prototype = {
	appendLeft: function appendLeft ( content ) {
		this.outro += content;
	},

	appendRight: function appendRight ( content ) {
		this.intro = this.intro + content;
	},

	clone: function clone () {
		var chunk = new Chunk( this.start, this.end, this.original );

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	},

	contains: function contains ( index ) {
		return this.start < index && index < this.end;
	},

	eachNext: function eachNext ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.next;
		}
	},

	eachPrevious: function eachPrevious ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.previous;
		}
	},

	edit: function edit ( content, storeName ) {
		this.content = content;
		this.intro = '';
		this.outro = '';
		this.storeName = storeName;

		this.edited = true;

		return this;
	},

	prependLeft: function prependLeft ( content ) {
		this.outro = content + this.outro;
	},

	prependRight: function prependRight ( content ) {
		this.intro = content + this.intro;
	},

	split: function split ( index ) {
		var sliceIndex = index - this.start;

		var originalBefore = this.original.slice( 0, sliceIndex );
		var originalAfter = this.original.slice( sliceIndex );

		this.original = originalBefore;

		var newChunk = new Chunk( index, this.end, originalAfter );
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if ( this.edited ) {
			// TODO is this block necessary?...
			newChunk.edit( '', false );
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if ( newChunk.next ) { newChunk.next.previous = newChunk; }
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	},

	toString: function toString () {
		return this.intro + this.content + this.outro;
	},

	trimEnd: function trimEnd ( rx ) {
		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.start + trimmed.length ).edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.intro = this.intro.replace( rx, '' );
			if ( this.intro.length ) { return true; }
		}
	},

	trimStart: function trimStart ( rx ) {
		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.end - trimmed.length );
				this.edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.outro = this.outro.replace( rx, '' );
			if ( this.outro.length ) { return true; }
		}
	}
};

var _btoa;

if ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {
	_btoa = window.btoa;
} else if ( typeof Buffer === 'function' ) {
	_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };
} else {
	_btoa = function () {
		throw new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );
	};
}

var btoa = _btoa;

function SourceMap ( properties ) {
	this.version = 3;

	this.file           = properties.file;
	this.sources        = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names          = properties.names;
	this.mappings       = properties.mappings;
}

SourceMap.prototype = {
	toString: function toString () {
		return JSON.stringify( this );
	},

	toUrl: function toUrl () {
		return 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );
	}
};

function guessIndent ( code ) {
	var lines = code.split( '\n' );

	var tabbed = lines.filter( function (line) { return /^\t+/.test( line ); } );
	var spaced = lines.filter( function (line) { return /^ {2,}/.test( line ); } );

	if ( tabbed.length === 0 && spaced.length === 0 ) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if ( tabbed.length >= spaced.length ) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce( function ( previous, current ) {
		var numSpaces = /^ +/.exec( current )[0].length;
		return Math.min( numSpaces, previous );
	}, Infinity );

	return new Array( min + 1 ).join( ' ' );
}

function getRelativePath ( from, to ) {
	var fromParts = from.split( /[\/\\]/ );
	var toParts = to.split( /[\/\\]/ );

	fromParts.pop(); // get dirname

	while ( fromParts[0] === toParts[0] ) {
		fromParts.shift();
		toParts.shift();
	}

	if ( fromParts.length ) {
		var i = fromParts.length;
		while ( i-- ) { fromParts[i] = '..'; }
	}

	return fromParts.concat( toParts ).join( '/' );
}

var toString$1 = Object.prototype.toString;

function isObject ( thing ) {
	return toString$1.call( thing ) === '[object Object]';
}

function getLocator$1 ( source ) {
	var originalLines = source.split( '\n' );

	var start = 0;
	var lineRanges = originalLines.map( function ( line, i ) {
		var end = start + line.length + 1;
		var range = { start: start, end: end, line: i };

		start = end;
		return range;
	});

	var i = 0;

	function rangeContains ( range, index ) {
		return range.start <= index && index < range.end;
	}

	function getLocation ( range, index ) {
		return { line: range.line, column: index - range.start };
	}

	return function locate ( index ) {
		var range = lineRanges[i];

		var d = index >= range.end ? 1 : -1;

		while ( range ) {
			if ( rangeContains( range, index ) ) { return getLocation( range, index ); }

			i += d;
			range = lineRanges[i];
		}
	};
}

function Mappings ( hires ) {
	var this$1 = this;

	var offsets = {
		generatedCodeColumn: 0,
		sourceIndex: 0,
		sourceCodeLine: 0,
		sourceCodeColumn: 0,
		sourceCodeName: 0
	};

	var generatedCodeLine = 0;
	var generatedCodeColumn = 0;

	this.raw = [];
	var rawSegments = this.raw[ generatedCodeLine ] = [];

	var pending = null;

	this.addEdit = function ( sourceIndex, content, original, loc, nameIndex ) {
		if ( content.length ) {
			rawSegments.push([
				generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column,
				nameIndex ]);
		} else if ( pending ) {
			rawSegments.push( pending );
		}

		this$1.advance( content );
		pending = null;
	};

	this.addUneditedChunk = function ( sourceIndex, chunk, original, loc, sourcemapLocations ) {
		var originalCharIndex = chunk.start;
		var first = true;

		while ( originalCharIndex < chunk.end ) {
			if ( hires || first || sourcemapLocations[ originalCharIndex ] ) {
				rawSegments.push([
					generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column,
					-1
				]);
			}

			if ( original[ originalCharIndex ] === '\n' ) {
				loc.line += 1;
				loc.column = 0;
				generatedCodeLine += 1;
				this$1.raw[ generatedCodeLine ] = rawSegments = [];
				generatedCodeColumn = 0;
			} else {
				loc.column += 1;
				generatedCodeColumn += 1;
			}

			originalCharIndex += 1;
			first = false;
		}

		pending = [
			generatedCodeColumn,
			sourceIndex,
			loc.line,
			loc.column,
			-1 ];
	};

	this.advance = function (str) {
		if ( !str ) { return; }

		var lines = str.split( '\n' );
		var lastLine = lines.pop();

		if ( lines.length ) {
			generatedCodeLine += lines.length;
			this$1.raw[ generatedCodeLine ] = rawSegments = [];
			generatedCodeColumn = lastLine.length;
		} else {
			generatedCodeColumn += lastLine.length;
		}
	};

	this.encode = function () {
		return this$1.raw.map( function (segments) {
			var generatedCodeColumn = 0;

			return segments.map( function (segment) {
				var arr = [
					segment[0] - generatedCodeColumn,
					segment[1] - offsets.sourceIndex,
					segment[2] - offsets.sourceCodeLine,
					segment[3] - offsets.sourceCodeColumn
				];

				generatedCodeColumn = segment[0];
				offsets.sourceIndex = segment[1];
				offsets.sourceCodeLine = segment[2];
				offsets.sourceCodeColumn = segment[3];

				if ( ~segment[4] ) {
					arr.push( segment[4] - offsets.sourceCodeName );
					offsets.sourceCodeName = segment[4];
				}

				return encode( arr );
			}).join( ',' );
		}).join( ';' );
	};
}

var Stats = function Stats () {
	Object.defineProperties( this, {
		startTimes: { value: {} }
	});
};

Stats.prototype.time = function time ( label ) {
	this.startTimes[ label ] = process.hrtime();
};

Stats.prototype.timeEnd = function timeEnd ( label ) {
	var elapsed = process.hrtime( this.startTimes[ label ] );

	if ( !this[ label ] ) { this[ label ] = 0; }
	this[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;
};

var warned = {
	insertLeft: false,
	insertRight: false
};

function MagicString$1 ( string, options ) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk( 0, string.length, string );

	Object.defineProperties( this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: {} },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent( string ) }
	});

	this.byStart[ 0 ] = chunk;
	this.byEnd[ string.length ] = chunk;
}

MagicString$1.prototype = {
	addSourcemapLocation: function addSourcemapLocation ( char ) {
		this.sourcemapLocations[ char ] = true;
	},

	append: function append ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.outro += content;
		return this;
	},

	appendLeft: function appendLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.appendLeft( content );
		} else {
			this.intro += content;
		}

		return this;
	},

	appendRight: function appendRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.appendRight( content );
		} else {
			this.outro += content;
		}

		return this;
	},

	clone: function clone () {
		var cloned = new MagicString$1( this.original, { filename: this.filename });

		var originalChunk = this.firstChunk;
		var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();

		while ( originalChunk ) {
			cloned.byStart[ clonedChunk.start ] = clonedChunk;
			cloned.byEnd[ clonedChunk.end ] = clonedChunk;

			var nextOriginalChunk = originalChunk.next;
			var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if ( nextClonedChunk ) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if ( this.indentExclusionRanges ) {
			cloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ?
				[ this.indentExclusionRanges[0], this.indentExclusionRanges[1] ] :
				this.indentExclusionRanges.map( function (range) { return [ range.start, range.end ]; } );
		}

		Object.keys( this.sourcemapLocations ).forEach( function (loc) {
			cloned.sourcemapLocations[ loc ] = true;
		});

		return cloned;
	},

	generateMap: function generateMap ( options ) {
		var this$1 = this;

		options = options || {};

		var sourceIndex = 0;
		var names = Object.keys( this.storedNames );
		var mappings = new Mappings( options.hires );

		var locate = getLocator$1( this.original );

		if ( this.intro ) {
			mappings.advance( this.intro );
		}

		this.firstChunk.eachNext( function (chunk) {
			var loc = locate( chunk.start );

			if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }

			if ( chunk.edited ) {
				mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
			} else {
				mappings.addUneditedChunk( sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations );
			}

			if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
		});

		var map = new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: [ options.source ? getRelativePath( options.file || '', options.source ) : null ],
			sourcesContent: options.includeContent ? [ this.original ] : [ null ],
			names: names,
			mappings: mappings.encode()
		});
		return map;
	},

	getIndentString: function getIndentString () {
		return this.indentStr === null ? '\t' : this.indentStr;
	},

	indent: function indent ( indentStr, options ) {
		var this$1 = this;

		var pattern = /^[^\r\n]/gm;

		if ( isObject( indentStr ) ) {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : ( this.indentStr || '\t' );

		if ( indentStr === '' ) { return this; } // noop

		options = options || {};

		// Process exclusion ranges
		var isExcluded = {};

		if ( options.exclude ) {
			var exclusions = typeof options.exclude[0] === 'number' ? [ options.exclude ] : options.exclude;
			exclusions.forEach( function (exclusion) {
				for ( var i = exclusion[0]; i < exclusion[1]; i += 1 ) {
					isExcluded[i] = true;
				}
			});
		}

		var shouldIndentNextCharacter = options.indentStart !== false;
		var replacer = function (match) {
			if ( shouldIndentNextCharacter ) { return ("" + indentStr + match); }
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace( pattern, replacer );

		var charIndex = 0;

		var chunk = this.firstChunk;

		while ( chunk ) {
			var end = chunk.end;

			if ( chunk.edited ) {
				if ( !isExcluded[ charIndex ] ) {
					chunk.content = chunk.content.replace( pattern, replacer );

					if ( chunk.content.length ) {
						shouldIndentNextCharacter = chunk.content[ chunk.content.length - 1 ] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while ( charIndex < end ) {
					if ( !isExcluded[ charIndex ] ) {
						var char = this$1.original[ charIndex ];

						if ( char === '\n' ) {
							shouldIndentNextCharacter = true;
						} else if ( char !== '\r' && shouldIndentNextCharacter ) {
							shouldIndentNextCharacter = false;

							if ( charIndex === chunk.start ) {
								chunk.prependRight( indentStr );
							} else {
								var rhs = chunk.split( charIndex );
								rhs.prependRight( indentStr );

								this$1.byStart[ charIndex ] = rhs;
								this$1.byEnd[ charIndex ] = chunk;

								chunk = rhs;
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace( pattern, replacer );

		return this;
	},

	insert: function insert () {
		throw new Error( 'magicString.insert(...) is deprecated. Use insertRight(...) or insertLeft(...)' );
	},

	insertLeft: function insertLeft ( index, content ) {
		if ( !warned.insertLeft ) {
			console.warn( 'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead' ); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft( index, content );
	},

	insertRight: function insertRight ( index, content ) {
		if ( !warned.insertRight ) {
			console.warn( 'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead' ); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight( index, content );
	},

	move: function move ( start, end, index ) {
		if ( index >= start && index <= end ) { throw new Error( 'Cannot move a selection inside itself' ); }

		this._split( start );
		this._split( end );
		this._split( index );

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		var oldLeft = first.previous;
		var oldRight = last.next;

		var newRight = this.byStart[ index ];
		if ( !newRight && last === this.lastChunk ) { return this; }
		var newLeft = newRight ? newRight.previous : this.lastChunk;

		if ( oldLeft ) { oldLeft.next = oldRight; }
		if ( oldRight ) { oldRight.previous = oldLeft; }

		if ( newLeft ) { newLeft.next = first; }
		if ( newRight ) { newRight.previous = last; }

		if ( !first.previous ) { this.firstChunk = last.next; }
		if ( !last.next ) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight;

		if ( !newLeft ) { this.firstChunk = first; }
		if ( !newRight ) { this.lastChunk = last; }

		return this;
	},

	overwrite: function overwrite ( start, end, content, storeName ) {
		var this$1 = this;

		if ( typeof content !== 'string' ) { throw new TypeError( 'replacement content must be a string' ); }

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( end > this.original.length ) { throw new Error( 'end is out of bounds' ); }
		if ( start === end ) { throw new Error( 'Cannot overwrite a zero-length range – use insertLeft or insertRight instead' ); }

		this._split( start );
		this._split( end );

		if ( storeName ) {
			var original = this.original.slice( start, end );
			this.storedNames[ original ] = true;
		}

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		if ( first ) {
			first.edit( content, storeName );

			if ( last ) {
				first.next = last.next;
			} else {
				first.next = null;
				this.lastChunk = first;
			}

			first.original = this.original.slice( start, end );
			first.end = end;
		}

		else {
			// must be inserting at the end
			var newChunk = new Chunk( start, end, '' ).edit( content, storeName );

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}

		return this;
	},

	prepend: function prepend ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.intro = content + this.intro;
		return this;
	},

	prependLeft: function prependLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.prependLeft( content );
		} else {
			this.intro = content + this.intro;
		}

		return this;
	},

	prependRight: function prependRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.prependRight( content );
		} else {
			this.outro = content + this.outro;
		}

		return this;
	},

	remove: function remove ( start, end ) {
		var this$1 = this;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( start === end ) { return this; }

		if ( start < 0 || end > this.original.length ) { throw new Error( 'Character is out of bounds' ); }
		if ( start > end ) { throw new Error( 'end must be greater than start' ); }

		return this.overwrite( start, end, '', false );
	},

	slice: function slice ( start, end ) {
		var this$1 = this;
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		var result = '';

		// find start chunk
		var chunk = this.firstChunk;
		while ( chunk && ( chunk.start > start || chunk.end <= start ) ) {

			// found end chunk before start
			if ( chunk.start < end && chunk.end >= end ) {
				return result;
			}

			chunk = chunk.next;
		}

		if ( chunk && chunk.edited && chunk.start !== start ) { throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

		var startChunk = chunk;
		while ( chunk ) {
			if ( chunk.intro && ( startChunk !== chunk || chunk.start === start ) ) {
				result += chunk.intro;
			}

			var containsEnd = chunk.start < end && chunk.end >= end;
			if ( containsEnd && chunk.edited && chunk.end !== end ) { throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

			var sliceStart = startChunk === chunk ? start - chunk.start : 0;
			var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice( sliceStart, sliceEnd );

			if ( chunk.outro && ( !containsEnd || chunk.end === end ) ) {
				result += chunk.outro;
			}

			if ( containsEnd ) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	},

	// TODO deprecate this? not really very useful
	snip: function snip ( start, end ) {
		var clone = this.clone();
		clone.remove( 0, start );
		clone.remove( end, clone.original.length );

		return clone;
	},

	_split: function _split ( index ) {
		var this$1 = this;

		if ( this.byStart[ index ] || this.byEnd[ index ] ) { return; }

		var chunk = this.lastSearchedChunk;
		var searchForward = index > chunk.end;

		while ( true ) {
			if ( chunk.contains( index ) ) { return this$1._splitChunk( chunk, index ); }

			chunk = searchForward ?
				this$1.byStart[ chunk.end ] :
				this$1.byEnd[ chunk.start ];
		}
	},

	_splitChunk: function _splitChunk ( chunk, index ) {
		if ( chunk.edited && chunk.content.length ) { // zero-length edited chunks are a special case (overlapping replacements)
			var loc = getLocator$1( this.original )( index );
			throw new Error( ("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")") );
		}

		var newChunk = chunk.split( index );

		this.byEnd[ index ] = chunk;
		this.byStart[ index ] = newChunk;
		this.byEnd[ newChunk.end ] = newChunk;

		if ( chunk === this.lastChunk ) { this.lastChunk = newChunk; }

		this.lastSearchedChunk = chunk;
		return true;
	},

	toString: function toString () {
		var str = this.intro;

		var chunk = this.firstChunk;
		while ( chunk ) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return this; }

		var chunk = this.lastChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimEnd( rx );

			// if chunk was trimmed, we have a new lastChunk
			if ( chunk.end !== end ) {
				this$1.lastChunk = chunk.next;

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.previous;
		} while ( chunk );

		return this;
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );

		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return this; }

		var chunk = this.firstChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimStart( rx );

			if ( chunk.end !== end ) {
				// special case...
				if ( chunk === this$1.lastChunk ) { this$1.lastChunk = chunk.next; }

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.next;
		} while ( chunk );

		return this;
	}
};

var hasOwnProp = Object.prototype.hasOwnProperty;

function Bundle ( options ) {
	if ( options === void 0 ) options = {};

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';

	this.sources = [];

	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
}

Bundle.prototype = {
	addSource: function addSource ( source ) {
		if ( source instanceof MagicString$1 ) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator
			});
		}

		if ( !isObject( source ) || !source.content ) {
			throw new Error( 'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`' );
		}

		[ 'filename', 'indentExclusionRanges', 'separator' ].forEach( function (option) {
			if ( !hasOwnProp.call( source, option ) ) { source[ option ] = source.content[ option ]; }
		});

		if ( source.separator === undefined ) { // TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if ( source.filename ) {
			if ( !hasOwnProp.call( this.uniqueSourceIndexByFilename, source.filename ) ) {
				this.uniqueSourceIndexByFilename[ source.filename ] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[ this.uniqueSourceIndexByFilename[ source.filename ] ];
				if ( source.content.original !== uniqueSource.content ) {
					throw new Error( ("Illegal source: same filename (" + (source.filename) + "), different contents") );
				}
			}
		}

		this.sources.push( source );
		return this;
	},

	append: function append ( str, options ) {
		this.addSource({
			content: new MagicString$1( str ),
			separator: ( options && options.separator ) || ''
		});

		return this;
	},

	clone: function clone () {
		var bundle = new Bundle({
			intro: this.intro,
			separator: this.separator
		});

		this.sources.forEach( function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator
			});
		});

		return bundle;
	},

	generateMap: function generateMap ( options ) {
		var this$1 = this;
		if ( options === void 0 ) options = {};

		var names = [];
		this.sources.forEach( function (source) {
			Object.keys( source.content.storedNames ).forEach( function (name) {
				if ( !~names.indexOf( name ) ) { names.push( name ); }
			});
		});

		var mappings = new Mappings( options.hires );

		if ( this.intro ) {
			mappings.advance( this.intro );
		}

		this.sources.forEach( function ( source, i ) {
			if ( i > 0 ) {
				mappings.advance( this$1.separator );
			}

			var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[ source.filename ] : -1;
			var magicString = source.content;
			var locate = getLocator$1( magicString.original );

			if ( magicString.intro ) {
				mappings.advance( magicString.intro );
			}

			magicString.firstChunk.eachNext( function (chunk) {
				var loc = locate( chunk.start );

				if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }

				if ( source.filename ) {
					if ( chunk.edited ) {
						mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
					} else {
						mappings.addUneditedChunk( sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations );
					}
				}

				else {
					mappings.advance( chunk.content );
				}

				if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
			});

			if ( magicString.outro ) {
				mappings.advance( magicString.outro );
			}
		});

		return new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: this.uniqueSources.map( function (source) {
				return options.file ? getRelativePath( options.file, source.filename ) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map( function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: mappings.encode()
		});
	},

	getIndentString: function getIndentString () {
		var indentStringCounts = {};

		this.sources.forEach( function (source) {
			var indentStr = source.content.indentStr;

			if ( indentStr === null ) { return; }

			if ( !indentStringCounts[ indentStr ] ) { indentStringCounts[ indentStr ] = 0; }
			indentStringCounts[ indentStr ] += 1;
		});

		return ( Object.keys( indentStringCounts ).sort( function ( a, b ) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] ) || '\t';
	},

	indent: function indent ( indentStr ) {
		var this$1 = this;

		if ( !arguments.length ) {
			indentStr = this.getIndentString();
		}

		if ( indentStr === '' ) { return this; } // noop

		var trailingNewline = !this.intro || this.intro.slice( -1 ) === '\n';

		this.sources.forEach( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var indentStart = trailingNewline || ( i > 0 && /\r?\n$/.test( separator ) );

			source.content.indent( indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			// TODO this is a very slow way to determine this
			trailingNewline = source.content.toString().slice( 0, -1 ) === '\n';
		});

		if ( this.intro ) {
			this.intro = indentStr + this.intro.replace( /^[^\n]/gm, function ( match, index ) {
				return index > 0 ? indentStr + match : match;
			});
		}

		return this;
	},

	prepend: function prepend ( str ) {
		this.intro = str + this.intro;
		return this;
	},

	toString: function toString () {
		var this$1 = this;

		var body = this.sources.map( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var str = ( i > 0 ? separator : '' ) + source.content.toString();

			return str;
		}).join( '' );

		return this.intro + body;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );
		this.intro = this.intro.replace( rx, '' );

		if ( !this.intro ) {
			var source;
			var i = 0;

			do {
				source = this$1.sources[i];

				if ( !source ) {
					break;
				}

				source.content.trimStart( charType );
				i += 1;
			} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?
		}

		return this;
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		var source;
		var i = this.sources.length - 1;

		do {
			source = this$1.sources[i];

			if ( !source ) {
				this$1.intro = this$1.intro.replace( rx, '' );
				break;
			}

			source.content.trimEnd( charType );
			i -= 1;
		} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?

		return this;
	}
};

function annotateWithScopes ( expression ) {
	let scope = new Scope( null, false );

	walk$2( expression, {
		enter ( node ) {
			if ( /Function/.test( node.type ) ) {
				if ( node.type === 'FunctionDeclaration' ) {
					scope.declarations.add( node.id.name );
				} else {
					node._scope = scope = new Scope( scope, false );
					if ( node.id ) { scope.declarations.add( node.id.name ); }
				}

				node.params.forEach( param => {
					extractNames( param ).forEach( name => {
						scope.declarations.add( name );
					});
				});
			}

			else if ( /For(?:In|Of)Statement/.test( node.type ) ) {
				node._scope = scope = new Scope( scope, true );
			}

			else if ( node.type === 'BlockStatement' ) {
				node._scope = scope = new Scope( scope, true );
			}

			else if ( /(Function|Class|Variable)Declaration/.test( node.type ) ) {
				scope.addDeclaration( node );
			}
		},

		leave ( node ) {
			if ( node._scope ) {
				scope = scope.parent;
			}
		}
	});

	return scope;
}

class Scope {
	constructor ( parent, block ) {
		this.parent = parent;
		this.block = block;
		this.declarations = new Set();
	}

	addDeclaration ( node ) {
		if ( node.kind === 'var' && !this.block && this.parent ) {
			this.parent.addDeclaration( node );
		} else if ( node.type === 'VariableDeclaration' ) {
			node.declarations.forEach( declarator => {
				extractNames( declarator.id ).forEach( name => {
					this.declarations.add( name );
				});
			});
		} else {
			this.declarations.add( node.id.name );
		}
	}

	has ( name ) {
		return this.declarations.has( name ) || this.parent && this.parent.has( name );
	}
}

function extractNames ( param ) {
	const names = [];
	extractors[ param.type ]( names, param );
	return names;
}

const extractors = {
	Identifier ( names, param ) {
		names.push( param.name );
	},

	ObjectPattern ( names, param ) {
		param.properties.forEach( prop => {
			extractors[ prop.value.type ]( names, prop.value );
		});
	},

	ArrayPattern ( names, param ) {
		param.elements.forEach( element => {
			if ( element ) { extractors[ element.type ]( names, element ); }
		});
	},

	RestElement ( names, param ) {
		extractors[ param.argument.type ]( names, param.argument );
	},

	AssignmentPattern ( names, param ) {
		extractors[ param.left.type ]( names, param.left );
	}
};

const start = /\n(\t+)/;

function deindent ( strings ) {
	var values = [], len = arguments.length - 1;
	while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

	const indentation = start.exec( strings[0] )[1];
	const pattern = new RegExp( `^${indentation}`, 'gm' );

	let result = strings[0].replace( start, '' ).replace( pattern, '' );

	let trailingIndentation = getTrailingIndentation( result );

	for ( let i = 1; i < strings.length; i += 1 ) {
		let expression = values[ i - 1 ];
		const string = strings[i].replace( pattern, '' );

		if ( Array.isArray( expression ) ) {
			expression = expression.length ? expression.join( '\n' ) : null;
		}

		if ( expression || expression === '' ) {
			const value = String( expression ).replace( /\n/g, `\n${trailingIndentation}` );
			result += value + string;
		}

		else {
			let c = result.length;
			while ( /\s/.test( result[ c - 1 ] ) ) { c -= 1; }
			result = result.slice( 0, c ) + string;
		}

		trailingIndentation = getTrailingIndentation( result );
	}

	return result.trim().replace( /\t+$/gm, '' );
}

function getTrailingIndentation ( str ) {
	let i = str.length;
	while ( str[ i - 1 ] === ' ' || str[ i - 1 ] === '\t' ) { i -= 1; }
	return str.slice( i, str.length );
}

const LINE = {};
const BLOCK = {};

class CodeBuilder {
	constructor ( str ) {
	if ( str === void 0 ) str = '';

		this.result = str;

		const initial = str ? ( /\n/.test( str ) ? BLOCK : LINE ) : null;
		this.first = initial;
		this.last = initial;

		this.lastCondition = null;
	}

	addConditionalLine ( condition, line ) {
		if ( condition === this.lastCondition ) {
			this.result += `\n\t${line}`;
		} else {
			if ( this.lastCondition ) {
				this.result += `\n}\n\n`;
			}

			this.result += `if ( ${condition} ) {\n\t${line}`;
			this.lastCondition = condition;
		}

		this.last = BLOCK;
	}

	addLine ( line ) {
		if ( this.lastCondition ) {
			this.result += `\n}`;
			this.lastCondition = null;
		}

		if ( this.last === BLOCK ) {
			this.result += `\n\n${line}`;
		} else if ( this.last === LINE ) {
			this.result += `\n${line}`;
		} else {
			this.result += line;
		}

		this.last = LINE;
		if ( !this.first ) { this.first = LINE; }
	}

	addLineAtStart ( line ) {
		if ( this.first === BLOCK ) {
			this.result = `${line}\n\n${this.result}`;
		} else if ( this.first === LINE ) {
			this.result = `${line}\n${this.result}`;
		} else {
			this.result += line;
		}

		this.first = LINE;
		if ( !this.last ) { this.last = LINE; }
	}

	addBlock ( block ) {
		if ( this.lastCondition ) {
			this.result += `\n}`;
			this.lastCondition = null;
		}

		if ( this.result ) {
			this.result += `\n\n${block}`;
		} else {
			this.result += block;
		}

		this.last = BLOCK;
		if ( !this.first ) { this.first = BLOCK; }
	}

	addBlockAtStart ( block ) {
		if ( this.result ) {
			this.result = `${block}\n\n${this.result}`;
		} else {
			this.result += block;
		}

		this.first = BLOCK;
		if ( !this.last ) { this.last = BLOCK; }
	}

	isEmpty () {
		return this.result === '';
	}

	toString () {
		return this.result.trim() + ( this.lastCondition ? `\n}` : `` );
	}
}

function visitEachBlock ( generator, block, state, node ) {
	const each_block = generator.getUniqueName( `each_block` );
	const create_each_block = node._block.name;
	const each_block_value = node._block.listName;
	const iterations = block.getUniqueName( `${each_block}_iterations` );
	const i = block.alias( `i` );
	const params = block.params.join( ', ' );
	const anchor = node.needsAnchor ? block.getUniqueName( `${each_block}_anchor` ) : ( node.next && node.next._state.name ) || 'null';

	const mountOrIntro = node._block.hasIntroMethod ? 'intro' : 'mount';
	const vars = { each_block, create_each_block, each_block_value, iterations, i, params, anchor, mountOrIntro };

	var ref = block.contextualise( node.expression );
	var snippet = ref.snippet;

	block.builders.create.addLine( `var ${each_block_value} = ${snippet};` );

	if ( node.key ) {
		keyed( generator, block, state, node, snippet, vars );
	} else {
		unkeyed( generator, block, state, node, snippet, vars );
	}

	const isToplevel = !state.parentNode;

	if ( node.needsAnchor ) {
		block.addElement( anchor, `${generator.helper( 'createComment' )}()`, state.parentNode, true );
	} else if ( node.next ) {
		node.next.usedAsAnchor = true;
	}

	if ( node.else ) {
		const each_block_else = generator.getUniqueName( `${each_block}_else` );

		block.builders.create.addLine( `var ${each_block_else} = null;` );

		// TODO neaten this up... will end up with an empty line in the block
		block.builders.create.addBlock( deindent`
			if ( !${each_block_value}.length ) {
				${each_block_else} = ${node.else._block.name}( ${params}, ${block.component} );
				${!isToplevel ? `${each_block_else}.${mountOrIntro}( ${state.parentNode}, null );` : ''}
			}
		` );

		block.builders.mount.addBlock( deindent`
			if ( ${each_block_else} ) {
				${each_block_else}.${mountOrIntro}( ${state.parentNode || block.target}, null );
			}
		` );

		const parentNode = state.parentNode || `${anchor}.parentNode`;

		if ( node.else._block.hasUpdateMethod ) {
			block.builders.update.addBlock( deindent`
				if ( !${each_block_value}.length && ${each_block_else} ) {
					${each_block_else}.update( changed, ${params} );
				} else if ( !${each_block_value}.length ) {
					${each_block_else} = ${node.else._block.name}( ${params}, ${block.component} );
					${each_block_else}.${mountOrIntro}( ${parentNode}, ${anchor} );
				} else if ( ${each_block_else} ) {
					${each_block_else}.destroy( true );
					${each_block_else} = null;
				}
			` );
		} else {
			block.builders.update.addBlock( deindent`
				if ( ${each_block_value}.length ) {
					if ( ${each_block_else} ) {
						${each_block_else}.destroy( true );
						${each_block_else} = null;
					}
				} else if ( !${each_block_else} ) {
					${each_block_else} = ${node.else._block.name}( ${params}, ${block.component} );
					${each_block_else}.${mountOrIntro}( ${parentNode}, ${anchor} );
				}
			` );
		}


		block.builders.destroy.addBlock( deindent`
			if ( ${each_block_else} ) {
				${each_block_else}.destroy( ${isToplevel ? 'detach' : 'false'} );
			}
		` );
	}

	node.children.forEach( child => {
		visit$1( generator, node._block, node._state, child );
	});

	if ( node.else ) {
		node.else.children.forEach( child => {
			visit$1( generator, node.else._block, node.else._state, child );
		});
	}
}

function keyed ( generator, block, state, node, snippet, ref ) {
	var each_block = ref.each_block;
	var create_each_block = ref.create_each_block;
	var each_block_value = ref.each_block_value;
	var i = ref.i;
	var params = ref.params;
	var anchor = ref.anchor;
	var mountOrIntro = ref.mountOrIntro;

	const key = block.getUniqueName( 'key' );
	const lookup = block.getUniqueName( `${each_block}_lookup` );
	const iteration = block.getUniqueName( `${each_block}_iteration` );
	const head = block.getUniqueName( `${each_block}_head` );
	const last = block.getUniqueName( `${each_block}_last` );
	const expected = block.getUniqueName( `${each_block}_expected` );

	if ( node.children[0] && node.children[0].type === 'Element' ) { // TODO or text/tag/raw
		node._block.first = node.children[0]._state.parentNode; // TODO this is highly confusing
	} else {
		node._block.first = node._block.getUniqueName( 'first' );
		node._block.addElement( node._block.first, `${generator.helper( 'createComment' )}()`, null, true );
	}

	block.builders.create.addBlock( deindent`
		var ${lookup} = Object.create( null );

		var ${head};
		var ${last};

		for ( var ${i} = 0; ${i} < ${each_block_value}.length; ${i} += 1 ) {
			var ${key} = ${each_block_value}[${i}].${node.key};
			var ${iteration} = ${lookup}[${key}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component}, ${key} );
			${state.parentNode && `${iteration}.${mountOrIntro}( ${state.parentNode}, null );`}

			if ( ${last} ) ${last}.next = ${iteration};
			${iteration}.last = ${last};
			${last} = ${iteration};

			if ( ${i} === 0 ) ${head} = ${iteration};
		}
	` );

	if ( !state.parentNode ) {
		block.builders.mount.addBlock( deindent`
			var ${iteration} = ${head};
			while ( ${iteration} ) {
				${iteration}.${mountOrIntro}( ${block.target}, null );
				${iteration} = ${iteration}.next;
			}
		` );
	}

	const dynamic = node._block.hasUpdateMethod;
	const parentNode = state.parentNode || `${anchor}.parentNode`;

	let destroy;
	if ( node._block.hasOutroMethod ) {
		const fn = block.getUniqueName( `${each_block}_outro` );
		block.builders.create.addBlock( deindent`
			function ${fn} ( iteration ) {
				iteration.outro( function () {
					iteration.destroy( true );
					if ( iteration.next ) iteration.next.last = iteration.last;
					if ( iteration.last ) iteration.last.next = iteration.next;
					${lookup}[iteration.key] = null;
				});
			}
		` );

		destroy = deindent`
			while ( ${expected} ) {
				${fn}( ${expected} );
				${expected} = ${expected}.next;
			}

			for ( ${i} = 0; ${i} < discard_pile.length; ${i} += 1 ) {
				if ( discard_pile[${i}].discard ) {
					${fn}( discard_pile[${i}] );
				}
			}
		`;
	} else {
		const fn = block.getUniqueName( `${each_block}_destroy` );
		block.builders.create.addBlock( deindent`
			function ${fn} ( iteration ) {
				iteration.destroy( true );
				if ( iteration.next && iteration.next.last === iteration ) iteration.next.last = iteration.last;
				if ( iteration.last && iteration.last.next === iteration ) iteration.last.next = iteration.next;
				${lookup}[iteration.key] = null;
			}
		` );

		destroy = deindent`
			while ( ${expected} ) {
				${fn}( ${expected} );
				${expected} = ${expected}.next;
			}

			for ( ${i} = 0; ${i} < discard_pile.length; ${i} += 1 ) {
				var ${iteration} = discard_pile[${i}];
				if ( ${iteration}.discard ) {
					${fn}( ${iteration} );
				}
			}
		`;
	}

	block.builders.update.addBlock( deindent`
		var ${each_block_value} = ${snippet};

		var ${expected} = ${head};
		var ${last};

		var discard_pile = [];

		for ( ${i} = 0; ${i} < ${each_block_value}.length; ${i} += 1 ) {
			var ${key} = ${each_block_value}[${i}].${node.key};
			var ${iteration} = ${lookup}[${key}];

			${dynamic && `if ( ${iteration} ) ${iteration}.update( changed, ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i} );`}

			if ( ${expected} ) {
				if ( ${key} === ${expected}.key ) {
					${expected} = ${expected}.next;
				} else {
					if ( ${iteration} ) {
						// probably a deletion
						do {
							${expected}.discard = true;
							discard_pile.push( ${expected} );
							${expected} = ${expected}.next;
						} while ( ${expected} && ${expected}.key !== ${key} );

						${expected} = ${expected} && ${expected}.next;
						${iteration}.discard = false;
						${iteration}.last = ${last};
						${iteration}.next = ${expected};

						${iteration}.mount( ${parentNode}, ${expected} ? ${expected}.first : ${anchor} );
					} else {
						// key is being inserted
						${iteration} = ${lookup}[${key}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component}, ${key} );
						${iteration}.${mountOrIntro}( ${parentNode}, ${expected}.first );

						if ( ${expected} ) ${expected}.last = ${iteration};
						${iteration}.next = ${expected};
					}
				}
			} else {
				// we're appending from this point forward
				if ( ${iteration} ) {
					${iteration}.discard = false;
					${iteration}.next = null;
					${iteration}.mount( ${parentNode}, ${anchor} );
				} else {
					${iteration} = ${lookup}[${key}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component}, ${key} );
					${iteration}.${mountOrIntro}( ${parentNode}, ${anchor} );
				}
			}

			if ( ${last} ) ${last}.next = ${iteration};
			${iteration}.last = ${last};
			${node._block.hasIntroMethod && `${iteration}.intro( ${parentNode}, ${anchor} );`}
			${last} = ${iteration};
		}

		if ( ${last} ) ${last}.next = null;

		${destroy}

		${head} = ${lookup}[${each_block_value}[0] && ${each_block_value}[0].${node.key}];
	` );

	block.builders.destroy.addBlock( deindent`
		var ${iteration} = ${head};
		while ( ${iteration} ) {
			${iteration}.destroy( ${state.parentNode ? 'false' : 'detach'} );
			${iteration} = ${iteration}.next;
		}
	` );
}

function unkeyed ( generator, block, state, node, snippet, ref ) {
	var create_each_block = ref.create_each_block;
	var each_block_value = ref.each_block_value;
	var iterations = ref.iterations;
	var i = ref.i;
	var params = ref.params;
	var anchor = ref.anchor;
	var mountOrIntro = ref.mountOrIntro;

	block.builders.create.addBlock( deindent`
		var ${iterations} = [];

		for ( var ${i} = 0; ${i} < ${each_block_value}.length; ${i} += 1 ) {
			${iterations}[${i}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component} );
			${state.parentNode && `${iterations}[${i}].${mountOrIntro}( ${state.parentNode}, null );`}
		}
	` );

	if ( !state.parentNode ) {
		block.builders.mount.addBlock( deindent`
			for ( var ${i} = 0; ${i} < ${iterations}.length; ${i} += 1 ) {
				${iterations}[${i}].${mountOrIntro}( ${block.target}, null );
			}
		` );
	}

	const dependencies = block.findDependencies( node.expression );
	const allDependencies = new Set( node._block.dependencies );
	dependencies.forEach( dependency => {
		allDependencies.add( dependency );
	});

	// TODO do this for keyed blocks as well
	const condition = Array.from( allDependencies )
		.map( dependency => `'${dependency}' in changed` )
		.join( ' || ' );

	const parentNode = state.parentNode || `${anchor}.parentNode`;

	if ( condition !== '' ) {
		const forLoopBody = node._block.hasUpdateMethod ?
			node._block.hasIntroMethod ?
				deindent`
					if ( ${iterations}[${i}] ) {
						${iterations}[${i}].update( changed, ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i} );
					} else {
						${iterations}[${i}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component} );
					}
					${iterations}[${i}].intro( ${parentNode}, ${anchor} );
				` :
				deindent`
					if ( ${iterations}[${i}] ) {
						${iterations}[${i}].update( changed, ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i} );
					} else {
						${iterations}[${i}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component} );
						${iterations}[${i}].mount( ${parentNode}, ${anchor} );
					}
				` :
			deindent`
				${iterations}[${i}] = ${create_each_block}( ${params}, ${each_block_value}, ${each_block_value}[${i}], ${i}, ${block.component} );
				${iterations}[${i}].${mountOrIntro}( ${parentNode}, ${anchor} );
			`;

		const start = node._block.hasUpdateMethod ? '0' : `${iterations}.length`;

		const outro = block.getUniqueName( 'outro' );
		const destroy = node._block.hasOutroMethod ?
			deindent`
				function ${outro} ( i ) {
					if ( ${iterations}[i] ) {
						${iterations}[i].outro( function () {
							${iterations}[i].destroy( true );
							${iterations}[i] = null;
						});
					}
				}

				for ( ; ${i} < ${iterations}.length; ${i} += 1 ) ${outro}( ${i} );
			` :
			deindent`
				${generator.helper( 'destroyEach' )}( ${iterations}, true, ${each_block_value}.length );
				${iterations}.length = ${each_block_value}.length;
			`;

		block.builders.update.addBlock( deindent`
			var ${each_block_value} = ${snippet};

			if ( ${condition} ) {
				for ( var ${i} = ${start}; ${i} < ${each_block_value}.length; ${i} += 1 ) {
					${forLoopBody}
				}

				${destroy}
			}
		` );
	}

	block.builders.destroy.addBlock(
		`${generator.helper( 'destroyEach' )}( ${iterations}, ${state.parentNode ? 'false' : 'detach'}, 0 );`
	);
}

function visitAttribute ( generator, block, state, node, attribute, local ) {
	if ( attribute.value === true ) {
		// attributes without values, e.g. <textarea readonly>
		local.staticAttributes.push({
			name: attribute.name,
			value: true
		});
	}

	else if ( attribute.value.length === 0 ) {
		local.staticAttributes.push({
			name: attribute.name,
			value: `''`
		});
	}

	else if ( attribute.value.length === 1 ) {
		const value = attribute.value[0];

		if ( value.type === 'Text' ) {
			// static attributes
			const result = isNaN( value.data ) ? JSON.stringify( value.data ) : value.data;
			local.staticAttributes.push({
				name: attribute.name,
				value: result
			});
		}

		else {
			// simple dynamic attributes
			var ref = block.contextualise( value.expression );
			var dependencies = ref.dependencies;
			var snippet = ref.snippet;

			// TODO only update attributes that have changed
			local.dynamicAttributes.push({
				name: attribute.name,
				value: snippet,
				dependencies
			});
		}
	}

	else {
		// complex dynamic attributes
		const allDependencies = [];

		const value = ( attribute.value[0].type === 'Text' ? '' : `"" + ` ) + (
			attribute.value.map( chunk => {
				if ( chunk.type === 'Text' ) {
					return JSON.stringify( chunk.data );
				} else {
					var ref = block.contextualise( chunk.expression );
					var dependencies = ref.dependencies;
					var snippet = ref.snippet;
					dependencies.forEach( dependency => {
						if ( !~allDependencies.indexOf( dependency ) ) { allDependencies.push( dependency ); }
					});

					return `( ${snippet} )`;
				}
			}).join( ' + ' )
		);

		local.dynamicAttributes.push({
			name: attribute.name,
			value,
			dependencies: allDependencies
		});
	}
}

function visitEventHandler ( generator, block, state, node, attribute, local ) {
	// TODO verify that it's a valid callee (i.e. built-in or declared method)
	generator.addSourcemapLocations( attribute.expression );
	generator.code.prependRight( attribute.expression.start, `${block.component}.` );

	const usedContexts = [];
	attribute.expression.arguments.forEach( arg => {
		var ref = block.contextualise( arg, null, true );
		var contexts = ref.contexts;

		contexts.forEach( context => {
			if ( !~usedContexts.indexOf( context ) ) { usedContexts.push( context ); }
			if ( !~local.allUsedContexts.indexOf( context ) ) { local.allUsedContexts.push( context ); }
		});
	});

	// TODO hoist event handlers? can do `this.__component.method(...)`
	const declarations = usedContexts.map( name => {
		if ( name === 'state' ) { return 'var state = this._context.state;'; }

		const listName = block.listNames.get( name );
		const indexName = block.indexNames.get( name );

		return `var ${listName} = this._context.${listName}, ${indexName} = this._context.${indexName}, ${name} = ${listName}[${indexName}]`;
	});

	const handlerBody = ( declarations.length ? declarations.join( '\n' ) + '\n\n' : '' ) + `[✂${attribute.expression.start}-${attribute.expression.end}✂];`;

	local.create.addBlock( deindent`
		${local.name}.on( '${attribute.name}', function ( event ) {
			${handlerBody}
		});
	` );
}

function getSetter (ref) {
	var block = ref.block;
	var name = ref.name;
	var context = ref.context;
	var attribute = ref.attribute;
	var dependencies = ref.dependencies;
	var value = ref.value;

	const tail = attribute.value.type === 'MemberExpression' ? getTailSnippet( attribute.value ) : '';

	if ( block.contexts.has( name ) ) {
		const prop = dependencies[0];

		return deindent`
			var list = this.${context}.${block.listNames.get( name )};
			var index = this.${context}.${block.indexNames.get( name )};
			list[index]${tail} = ${value};

			${block.component}._set({ ${prop}: ${block.component}.get( '${prop}' ) });
		`;
	}

	if ( attribute.value.type === 'MemberExpression' ) {
		const alias = block.alias( name );

		return deindent`
			var ${alias} = ${block.component}.get( '${name}' );
			${alias}${tail} = ${value};
			${block.component}._set({ ${name}: ${alias} });
		`;
	}

	return `${block.component}._set({ ${name}: ${value} });`;
}

function getTailSnippet ( node ) {
	const end = node.end;
	while ( node.type === 'MemberExpression' ) { node = node.object; }
	const start = node.end;

	return `[✂${start}-${end}✂]`;
}

function visitBinding ( generator, block, state, node, attribute, local ) {
	var ref = flatten( attribute.value );
	var name = ref.name;
	var ref$1 = block.contextualise( attribute.value );
	var snippet = ref$1.snippet;
	var contexts = ref$1.contexts;
	var dependencies = ref$1.dependencies;

	if ( dependencies.length > 1 ) { throw new Error( 'An unexpected situation arose. Please raise an issue at https://github.com/sveltejs/svelte/issues — thanks!' ); }

	contexts.forEach( context => {
		if ( !~local.allUsedContexts.indexOf( context ) ) { local.allUsedContexts.push( context ); }
	});

	const contextual = block.contexts.has( name );

	let obj;
	let prop;

	if ( contextual ) {
		obj = block.listNames.get( name );
		prop = block.indexNames.get( name );
	} else if ( attribute.value.type === 'MemberExpression' ) {
		prop = `'[✂${attribute.value.property.start}-${attribute.value.property.end}✂]'`;
		obj = `[✂${attribute.value.object.start}-${attribute.value.object.end}✂]`;
	} else {
		obj = 'state';
		prop = `'${name}'`;
	}

	local.bindings.push({
		name: attribute.name,
		value: snippet,
		obj,
		prop
	});

	const setter = getSetter({ block, name, context: '_context', attribute, dependencies, value: 'value' });

	generator.hasComplexBindings = true;

	const updating = block.getUniqueName( `${local.name}_updating` );
	block.addVariable( updating, 'false' );

	local.create.addBlock( deindent`
		${block.component}._bindings.push( function () {
			if ( ${local.name}._torndown ) return;
			${local.name}.observe( '${attribute.name}', function ( value ) {
				if ( ${updating} ) return;
				${updating} = true;
				${setter}
				${updating} = false;
			}, { init: ${generator.helper( 'differs' )}( ${local.name}.get( '${attribute.name}' ), ${snippet} ) });
		});
	` );

	local.update.addBlock( deindent`
		if ( !${updating} && ${dependencies.map( dependency => `'${dependency}' in changed` ).join( '||' )} ) {
			${updating} = true;
			${local.name}._set({ ${attribute.name}: ${snippet} });
			${updating} = false;
		}
	` );
}

function visitRef ( generator, block, state, node, attribute, local ) {
	generator.usesRefs = true;

	local.create.addLine(
		`${block.component}.refs.${attribute.name} = ${local.name};`
	);

	block.builders.destroy.addLine( deindent`
		if ( ${block.component}.refs.${attribute.name} === ${local.name} ) ${block.component}.refs.${attribute.name} = null;
	` );
}

function stringifyProps ( props ) {
	if ( !props.length ) { return '{}'; }

	const joined = props.join( ', ' );
	if ( joined.length > 40 ) {
		// make larger data objects readable
		return `{\n\t${props.join( ',\n\t' )}\n}`;
	}

	return `{ ${joined} }`;
}

const order$1 = {
	Attribute: 1,
	EventHandler: 2,
	Binding: 3,
	Ref: 4
};

const visitors$2 = {
	Attribute: visitAttribute,
	EventHandler: visitEventHandler,
	Binding: visitBinding,
	Ref: visitRef
};

function visitComponent ( generator, block, state, node ) {
	const hasChildren = node.children.length > 0;
	const name = block.getUniqueName( ( node.name === ':Self' ? generator.name : node.name ).toLowerCase() );

	const childState = node._state;

	const local = {
		name,
		namespace: state.namespace,
		isComponent: true,

		allUsedContexts: [],
		staticAttributes: [],
		dynamicAttributes: [],
		bindings: [],

		create: new CodeBuilder(),
		update: new CodeBuilder()
	};

	const isToplevel = !state.parentNode;

	generator.hasComponents = true;

	node.attributes
		.sort( ( a, b ) => order$1[ a.type ] - order$1[ b.type ] )
		.forEach( attribute => {
			visitors$2[ attribute.type ]( generator, block, childState, node, attribute, local );
		});

	if ( local.allUsedContexts.length ) {
		const initialProps = local.allUsedContexts.map( contextName => {
			if ( contextName === 'state' ) { return `state: state`; }

			const listName = block.listNames.get( contextName );
			const indexName = block.indexNames.get( contextName );

			return `${listName}: ${listName},\n${indexName}: ${indexName}`;
		}).join( ',\n' );

		const updates = local.allUsedContexts.map( contextName => {
			if ( contextName === 'state' ) { return `${name}._context.state = state;`; }

			const listName = block.listNames.get( contextName );
			const indexName = block.indexNames.get( contextName );

			return `${name}._context.${listName} = ${listName};\n${name}._context.${indexName} = ${indexName};`;
		}).join( '\n' );

		local.create.addBlock( deindent`
			${name}._context = {
				${initialProps}
			};
		` );

		local.update.addBlock( updates );
	}

	const componentInitProperties = [
		`target: ${!isToplevel ? state.parentNode: 'null'}`,
		`_root: ${block.component}._root`
	];

	// Component has children, put them in a separate {{yield}} block
	if ( hasChildren ) {
		const params = block.params.join( ', ' );

		const childBlock = node._block;

		node.children.forEach( child => {
			visit$1( generator, childBlock, childState, child );
		});

		const yieldFragment = block.getUniqueName( `${name}_yield_fragment` );

		block.builders.create.addLine(
			`var ${yieldFragment} = ${childBlock.name}( ${params}, ${block.component} );`
		);

		if ( childBlock.hasUpdateMethod ) {
			block.builders.update.addLine(
				`${yieldFragment}.update( changed, ${params} );`
			);
		}

		componentInitProperties.push( `_yield: ${yieldFragment}`);
	}

	const statements = [];

	if ( local.staticAttributes.length || local.dynamicAttributes.length || local.bindings.length ) {
		const initialProps = local.staticAttributes
			.concat( local.dynamicAttributes )
			.map( attribute => `${attribute.name}: ${attribute.value}` );

		const initialPropString = stringifyProps( initialProps );

		if ( local.bindings.length ) {
			const initialData = block.getUniqueName( `${name}_initial_data` );

			statements.push( `var ${initialData} = ${initialPropString};` );

			local.bindings.forEach( binding => {
				statements.push( `if ( ${binding.prop} in ${binding.obj} ) ${initialData}.${binding.name} = ${binding.value};` );
			});

			componentInitProperties.push( `data: ${initialData}` );
		} else if ( initialProps.length ) {
			componentInitProperties.push( `data: ${initialPropString}` );
		}
	}

	const expression = node.name === ':Self' ? generator.name : generator.importedComponents.get( node.name ) || `${generator.alias( 'template' )}.components.${node.name}`;

	local.create.addBlockAtStart( deindent`
		${statements.join( '\n' )}
		var ${name} = new ${expression}({
			${componentInitProperties.join(',\n')}
		});
	` );

	if ( isToplevel ) {
		block.builders.mount.addLine( `${name}._fragment.mount( ${block.target}, anchor );` );
	}

	if ( local.dynamicAttributes.length ) {
		const updates = local.dynamicAttributes.map( attribute => {
			if ( attribute.dependencies.length ) {
				return deindent`
					if ( ${attribute.dependencies.map( dependency => `'${dependency}' in changed` ).join( '||' )} ) ${name}_changes.${attribute.name} = ${attribute.value};
				`;
			}

			// TODO this is an odd situation to encounter – I *think* it should only happen with
			// each block indices, in which case it may be possible to optimise this
			return `${name}_changes.${attribute.name} = ${attribute.value};`;
		});

		local.update.addBlock( deindent`
			var ${name}_changes = {};

			${updates.join( '\n' )}

			if ( Object.keys( ${name}_changes ).length ) ${name}.set( ${name}_changes );
		` );
	}

	block.builders.destroy.addLine( `${name}.destroy( ${isToplevel ? 'detach' : 'false'} );` );

	block.builders.create.addBlock( local.create );
	if ( !local.update.isEmpty() ) { block.builders.update.addBlock( local.update ); }
}

const associatedEvents = {
	innerWidth: 'resize',
	innerHeight: 'resize',
	outerWidth: 'resize',
	outerHeight: 'resize',

	scrollX: 'scroll',
	scrollY: 'scroll'
};

const readonly = new Set([
	'innerWidth',
	'innerHeight',
	'outerWidth',
	'outerHeight',
	'online'
]);

function visitWindow ( generator, block, node ) {
	const events = {};
	const bindings = {};

	node.attributes.forEach( attribute => {
		if ( attribute.type === 'EventHandler' ) {
			// TODO verify that it's a valid callee (i.e. built-in or declared method)
			generator.addSourcemapLocations( attribute.expression );

			let usesState = false;

			attribute.expression.arguments.forEach( arg => {
				var ref = block.contextualise( arg, null, true );
				var contexts = ref.contexts;
				if ( contexts.length ) { usesState = true; }
			});

			const flattened = flatten( attribute.expression.callee );
			if ( flattened.name !== 'event' && flattened.name !== 'this' ) {
				// allow event.stopPropagation(), this.select() etc
				generator.code.prependRight( attribute.expression.start, `${block.component}.` );
			}

			const handlerName = block.getUniqueName( `onwindow${attribute.name}` );
			const handlerBody = deindent`
				${usesState && `var state = ${block.component}.get();`}
				[✂${attribute.expression.start}-${attribute.expression.end}✂];
			`;

			block.builders.create.addBlock( deindent`
				function ${handlerName} ( event ) {
					${handlerBody}
				};
				window.addEventListener( '${attribute.name}', ${handlerName} );
			` );

			block.builders.destroy.addBlock( deindent`
				window.removeEventListener( '${attribute.name}', ${handlerName} );
			` );
		}

		if ( attribute.type === 'Binding' ) {
			// in dev mode, throw if read-only values are written to
			if ( readonly.has( attribute.name ) ) {
				generator.readonly.add( attribute.value.name );
			}

			bindings[ attribute.name ] = attribute.value.name;

			// bind:online is a special case, we need to listen for two separate events
			if ( attribute.name === 'online' ) { return; }

			const associatedEvent = associatedEvents[ attribute.name ];

			if ( !associatedEvent ) {
				throw new Error( `Cannot bind to ${attribute.name} on <:Window>` );
			}

			if ( !events[ associatedEvent ] ) { events[ associatedEvent ] = []; }
			events[ associatedEvent ].push( `${attribute.value.name}: this.${attribute.name}` );

			// add initial value
			generator.metaBindings.push(
				`this._state.${attribute.value.name} = window.${attribute.name};`
			);
		}
	});

	const lock = block.getUniqueName( `window_updating` );

	Object.keys( events ).forEach( event => {
		const handlerName = block.getUniqueName( `onwindow${event}` );
		const props = events[ event ].join( ',\n' );

		if ( event === 'scroll' ) { // TODO other bidirectional bindings...
			block.addVariable( lock, 'false' );
		}

		const handlerBody = deindent`
			${event === 'scroll' && `${lock} = true;`}
			${generator.options.dev && `component._updatingReadonlyProperty = true;`}

			${block.component}.set({
				${props}
			});

			${generator.options.dev && `component._updatingReadonlyProperty = false;`}
			${event === 'scroll' && `${lock} = false;`}
		`;

		block.builders.create.addBlock( deindent`
			function ${handlerName} ( event ) {
				${handlerBody}
			};
			window.addEventListener( '${event}', ${handlerName} );
		` );

		block.builders.destroy.addBlock( deindent`
			window.removeEventListener( '${event}', ${handlerName} );
		` );
	});

	// special case... might need to abstract this out if we add more special cases
	if ( bindings.scrollX && bindings.scrollY ) {
		const observerCallback = block.getUniqueName( `scrollobserver` );

		block.builders.create.addBlock( deindent`
			function ${observerCallback} () {
				if ( ${lock} ) return;
				var x = ${bindings.scrollX ? `${block.component}.get( '${bindings.scrollX}' )` : `window.scrollX`};
				var y = ${bindings.scrollY ? `${block.component}.get( '${bindings.scrollY}' )` : `window.scrollY`};
				window.scrollTo( x, y );
			};
		` );

		if ( bindings.scrollX ) { block.builders.create.addLine( `${block.component}.observe( '${bindings.scrollX}', ${observerCallback} );` ); }
		if ( bindings.scrollY ) { block.builders.create.addLine( `${block.component}.observe( '${bindings.scrollY}', ${observerCallback} );` ); }
	} else if ( bindings.scrollX || bindings.scrollY ) {
		const isX = !!bindings.scrollX;

		block.builders.create.addBlock( deindent`
			${block.component}.observe( '${bindings.scrollX || bindings.scrollY}', function ( ${isX ? 'x' : 'y'} ) {
				if ( ${lock} ) return;
				window.scrollTo( ${isX ? 'x, window.scrollY' : 'window.scrollX, y' } );
			});
		` );
	}

	// another special case. (I'm starting to think these are all special cases.)
	if ( bindings.online ) {
		const handlerName = block.getUniqueName( `onlinestatuschanged` );
		block.builders.create.addBlock( deindent`
			function ${handlerName} ( event ) {
				${block.component}.set({ ${bindings.online}: navigator.onLine });
			};
			window.addEventListener( 'online', ${handlerName} );
			window.addEventListener( 'offline', ${handlerName} );
		` );

		// add initial value
		generator.metaBindings.push(
			`this._state.${bindings.online} = navigator.onLine;`
		);

		block.builders.destroy.addBlock( deindent`
			window.removeEventListener( 'online', ${handlerName} );
			window.removeEventListener( 'offline', ${handlerName} );
		` );
	}
}

// source: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
const lookup = {
	accept: { appliesTo: [ 'form', 'input' ] },
	'accept-charset': { propertyName: 'acceptCharset', appliesTo: [ 'form' ] },
	accesskey: { propertyName: 'accessKey' },
	action: { appliesTo: [ 'form' ] },
	align: { appliesTo: [ 'applet', 'caption', 'col', 'colgroup', 'hr', 'iframe', 'img', 'table', 'tbody', 'td', 'tfoot' , 'th', 'thead', 'tr' ] },
	allowfullscreen: { propertyName: 'allowFullscreen', appliesTo: [ 'iframe' ] },
	alt: { appliesTo: [ 'applet', 'area', 'img', 'input' ] },
	async: { appliesTo: [ 'script' ] },
	autocomplete: { appliesTo: [ 'form', 'input' ] },
	autofocus: { appliesTo: [ 'button', 'input', 'keygen', 'select', 'textarea' ] },
	autoplay: { appliesTo: [ 'audio', 'video' ] },
	autosave: { appliesTo: [ 'input' ] },
	bgcolor: { propertyName: 'bgColor', appliesTo: [ 'body', 'col', 'colgroup', 'marquee', 'table', 'tbody', 'tfoot', 'td', 'th', 'tr' ] },
	border: { appliesTo: [ 'img', 'object', 'table' ] },
	buffered: { appliesTo: [ 'audio', 'video' ] },
	challenge: { appliesTo: [ 'keygen' ] },
	charset: { appliesTo: [ 'meta', 'script' ] },
	checked: { appliesTo: [ 'command', 'input' ] },
	cite: { appliesTo: [ 'blockquote', 'del', 'ins', 'q' ] },
	class: { propertyName: 'className' },
	code: { appliesTo: [ 'applet' ] },
	codebase: { propertyName: 'codeBase', appliesTo: [ 'applet' ] },
	color: { appliesTo: [ 'basefont', 'font', 'hr' ] },
	cols: { appliesTo: [ 'textarea' ] },
	colspan: { propertyName: 'colSpan', appliesTo: [ 'td', 'th' ] },
	content: { appliesTo: [ 'meta' ] },
	contenteditable: { propertyName: 'contentEditable' },
	contextmenu: {},
	controls: { appliesTo: [ 'audio', 'video' ] },
	coords: { appliesTo: [ 'area' ] },
	data: { appliesTo: [ 'object' ] },
	datetime: { propertyName: 'dateTime', appliesTo: [ 'del', 'ins', 'time' ] },
	default: { appliesTo: [ 'track' ] },
	defer: { appliesTo: [ 'script' ] },
	dir: {},
	dirname: { propertyName: 'dirName', appliesTo: [ 'input', 'textarea' ] },
	disabled: { appliesTo: [ 'button', 'command', 'fieldset', 'input', 'keygen', 'optgroup', 'option', 'select', 'textarea' ] },
	download: { appliesTo: [ 'a', 'area' ] },
	draggable: {},
	dropzone: {},
	enctype: { appliesTo: [ 'form' ] },
	for: { propertyName: 'htmlFor', appliesTo: [ 'label', 'output' ] },
	form: { appliesTo: [ 'button', 'fieldset', 'input', 'keygen', 'label', 'meter', 'object', 'output', 'progress', 'select', 'textarea' ] },
	formaction: { appliesTo: [ 'input', 'button' ] },
	headers: { appliesTo: [ 'td', 'th' ] },
	height: { appliesTo: [ 'canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video' ] },
	hidden: {},
	high: { appliesTo: [ 'meter' ] },
	href: { appliesTo: [ 'a', 'area', 'base', 'link' ] },
	hreflang: { appliesTo: [ 'a', 'area', 'link' ] },
	'http-equiv': { propertyName: 'httpEquiv', appliesTo: [ 'meta' ] },
	icon: { appliesTo: [ 'command' ] },
	id: {},
	ismap: { propertyName: 'isMap', appliesTo: [ 'img' ] },
	itemprop: {},
	keytype: { appliesTo: [ 'keygen' ] },
	kind: { appliesTo: [ 'track' ] },
	label: { appliesTo: [ 'track' ] },
	lang: {},
	language: { appliesTo: [ 'script' ] },
	loop: { appliesTo: [ 'audio', 'bgsound', 'marquee', 'video' ] },
	low: { appliesTo: [ 'meter' ] },
	manifest: { appliesTo: [ 'html' ] },
	max: { appliesTo: [ 'input', 'meter', 'progress' ] },
	maxlength: { propertyName: 'maxLength', appliesTo: [ 'input', 'textarea' ] },
	media: { appliesTo: [ 'a', 'area', 'link', 'source', 'style' ] },
	method: { appliesTo: [ 'form' ] },
	min: { appliesTo: [ 'input', 'meter' ] },
	multiple: { appliesTo: [ 'input', 'select' ] },
	muted: { appliesTo: [ 'video' ] },
	name: { appliesTo: [ 'button', 'form', 'fieldset', 'iframe', 'input', 'keygen', 'object', 'output', 'select', 'textarea', 'map', 'meta', 'param' ] },
	novalidate: { propertyName: 'noValidate', appliesTo: [ 'form' ] },
	open: { appliesTo: [ 'details' ] },
	optimum: { appliesTo: [ 'meter' ] },
	pattern: { appliesTo: [ 'input' ] },
	ping: { appliesTo: [ 'a', 'area' ] },
	placeholder: { appliesTo: [ 'input', 'textarea' ] },
	poster: { appliesTo: [ 'video' ] },
	preload: { appliesTo: [ 'audio', 'video' ] },
	radiogroup: { appliesTo: [ 'command' ] },
	readonly: { propertyName: 'readOnly', appliesTo: [ 'input', 'textarea' ] },
	rel: { appliesTo: [ 'a', 'area', 'link' ] },
	required: { appliesTo: [ 'input', 'select', 'textarea' ] },
	reversed: { appliesTo: [ 'ol' ] },
	rows: { appliesTo: [ 'textarea' ] },
	rowspan: { propertyName: 'rowSpan', appliesTo: [ 'td', 'th' ] },
	sandbox: { appliesTo: [ 'iframe' ] },
	scope: { appliesTo: [ 'th' ] },
	scoped: { appliesTo: [ 'style' ] },
	seamless: { appliesTo: [ 'iframe' ] },
	selected: { appliesTo: [ 'option' ] },
	shape: { appliesTo: [ 'a', 'area' ] },
	size: { appliesTo: [ 'input', 'select' ] },
	sizes: { appliesTo: [ 'link', 'img', 'source' ] },
	span: { appliesTo: [ 'col', 'colgroup' ] },
	spellcheck: {},
	src: { appliesTo: [ 'audio', 'embed', 'iframe', 'img', 'input', 'script', 'source', 'track', 'video' ] },
	srcdoc: { appliesTo: [ 'iframe' ] },
	srclang: { appliesTo: [ 'track' ] },
	srcset: { appliesTo: [ 'img' ] },
	start: { appliesTo: [ 'ol' ] },
	step: { appliesTo: [ 'input' ] },
	style: { propertyName: 'style.cssText' },
	summary: { appliesTo: [ 'table' ] },
	tabindex: { propertyName: 'tabIndex' },
	target: { appliesTo: [ 'a', 'area', 'base', 'form' ] },
	title: {},
	type: { appliesTo: [ 'button', 'input', 'command', 'embed', 'object', 'script', 'source', 'style', 'menu' ] },
	usemap: { propertyName: 'useMap', appliesTo: [ 'img', 'input', 'object' ] },
	value: { appliesTo: [ 'button', 'option', 'input', 'li', 'meter', 'progress', 'param', 'select' ] },
	width: { appliesTo: [ 'canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video' ] },
	wrap: { appliesTo: [ 'textarea' ] }
};

Object.keys( lookup ).forEach( name => {
	const metadata = lookup[ name ];
	if ( !metadata.propertyName ) { metadata.propertyName = name; }
});

function getStaticAttributeValue ( node, name ) {
	const attribute = node.attributes.find( attr => attr.name.toLowerCase() === name );
	if ( !attribute ) { return null; }

	if ( attribute.value.length !== 1 || attribute.value[0].type !== 'Text' ) {
		// TODO catch this in validation phase, give a more useful error (with location etc)
		throw new Error( `'${name} must be a static attribute` );
	}

	return attribute.value[0].data;
}

function visitAttribute$1 ( generator, block, state, node, attribute ) {
	const name = attribute.name;

	let metadata = state.namespace ? null : lookup[ name ];
	if ( metadata && metadata.appliesTo && !~metadata.appliesTo.indexOf( node.name ) ) { metadata = null; }

	const isIndirectlyBoundValue = name === 'value' && (
		node.name === 'option' || // TODO check it's actually bound
		node.name === 'input' && /^(checkbox|radio)$/.test( getStaticAttributeValue( node, 'type' ) )
	);

	const propertyName = isIndirectlyBoundValue ? '__value' : metadata && metadata.propertyName;

	// xlink is a special case... we could maybe extend this to generic
	// namespaced attributes but I'm not sure that's applicable in
	// HTML5?
	const method = name.slice( 0, 6 ) === 'xlink:' ? 'setXlinkAttribute' : 'setAttribute';

	const isDynamic = attribute.value !== true && attribute.value.length > 1 || ( attribute.value.length === 1 && attribute.value[0].type !== 'Text' );

	if ( isDynamic ) {
		let value;

		if ( attribute.value.length === 1 ) {
			// single {{tag}} — may be a non-string
			var ref = block.contextualise( attribute.value[0].expression );
			var snippet = ref.snippet;
			value = snippet;
		} else {
			// '{{foo}} {{bar}}' — treat as string concatenation
			value = ( attribute.value[0].type === 'Text' ? '' : `"" + ` ) + (
				attribute.value.map( chunk => {
					if ( chunk.type === 'Text' ) {
						return JSON.stringify( chunk.data );
					} else {
						var ref = block.contextualise( chunk.expression );
						var snippet = ref.snippet;
						return `( ${snippet} )`;
					}
				}).join( ' + ' )
			);
		}

		const last = block.getUniqueName( `${state.parentNode}_${name.replace( /[^a-zA-Z_$]/g, '_')}_value` );
		block.addVariable( last );

		const isSelectValueAttribute = name === 'value' && state.parentNodeName === 'select';

		let updater;

		if ( isSelectValueAttribute ) {
			// annoying special case
			const isMultipleSelect = node.name === 'select' && node.attributes.find( attr => attr.name.toLowerCase() === 'multiple' ); // TODO use getStaticAttributeValue
			const i = block.getUniqueName( 'i' );
			const option = block.getUniqueName( 'option' );

			const ifStatement = isMultipleSelect ?
				deindent`
					${option}.selected = ~${last}.indexOf( ${option}.__value );` :
				deindent`
					if ( ${option}.__value === ${last} ) {
						${option}.selected = true;
						break;
					}`;

			updater = deindent`
				for ( var ${i} = 0; ${i} < ${state.parentNode}.options.length; ${i} += 1 ) {
					var ${option} = ${state.parentNode}.options[${i}];

					${ifStatement}
				}
			`;

			block.builders.create.addLine( deindent`
				${last} = ${value}
				${updater}
			` );
		} else if ( propertyName ) {
			block.builders.create.addLine( `${state.parentNode}.${propertyName} = ${last} = ${value};` );
			updater = `${state.parentNode}.${propertyName} = ${last};`;
		} else {
			block.builders.create.addLine( `${generator.helper( method )}( ${state.parentNode}, '${name}', ${last} = ${value} );` );
			updater = `${generator.helper( method )}( ${state.parentNode}, '${name}', ${last} );`;
		}

		block.builders.update.addBlock( deindent`
			if ( ${last} !== ( ${last} = ${value} ) ) {
				${updater}
			}
		` );
	}

	else {
		const value = attribute.value === true ? 'true' :
		              attribute.value.length === 0 ? `''` :
		              JSON.stringify( attribute.value[0].data );

		const statement = propertyName ?
			`${state.parentNode}.${propertyName} = ${value};` :
			`${generator.helper( method )}( ${state.parentNode}, '${name}', ${value} );`;


		block.builders.create.addLine( statement );

		// special case – autofocus. has to be handled in a bit of a weird way
		if ( attribute.value === true && name === 'autofocus' ) {
			block.autofocus = state.parentNode;
		}

		// special case — xmlns
		if ( name === 'xmlns' ) {
			// TODO this attribute must be static – enforce at compile time
			state.namespace = attribute.value[0].data;
		}
	}

	if ( isIndirectlyBoundValue ) {
		const updateValue = `${state.parentNode}.value = ${state.parentNode}.__value;`;

		block.builders.create.addLine( updateValue );
		if ( isDynamic ) { block.builders.update.addLine( updateValue ); }
	}
}

function visitEventHandler$1 ( generator, block, state, node, attribute ) {
	const name = attribute.name;
	const isCustomEvent = generator.events.has( name );
	const shouldHoist = !isCustomEvent && state.inEachBlock;

	generator.addSourcemapLocations( attribute.expression );

	const flattened = flatten( attribute.expression.callee );
	if ( flattened.name !== 'event' && flattened.name !== 'this' ) {
		// allow event.stopPropagation(), this.select() etc
		// TODO verify that it's a valid callee (i.e. built-in or declared method)
		generator.code.prependRight( attribute.expression.start, `${block.component}.` );
		if ( shouldHoist ) { state.usesComponent = true; } // this feels a bit hacky but it works!
	}

	const context = shouldHoist ? null : state.parentNode;
	const usedContexts = [];
	attribute.expression.arguments.forEach( arg => {
		var ref = block.contextualise( arg, context, true );
		var contexts = ref.contexts;

		contexts.forEach( context => {
			if ( !~usedContexts.indexOf( context ) ) { usedContexts.push( context ); }
			if ( !~state.allUsedContexts.indexOf( context ) ) { state.allUsedContexts.push( context ); }
		});
	});

	const _this = context || 'this';
	const declarations = usedContexts.map( name => {
		if ( name === 'state' ) {
			if ( shouldHoist ) { state.usesComponent = true; }
			return `var state = ${block.component}.get();`;
		}

		const listName = block.listNames.get( name );
		const indexName = block.indexNames.get( name );
		const contextName = block.contexts.get( name );

		return `var ${listName} = ${_this}._svelte.${listName}, ${indexName} = ${_this}._svelte.${indexName}, ${contextName} = ${listName}[${indexName}];`;
	});

	// get a name for the event handler that is globally unique
	// if hoisted, locally unique otherwise
	const handlerName = shouldHoist ?
		generator.getUniqueName( `${name}_handler` ) :
		block.getUniqueName( `${name}_handler` );

	// create the handler body
	const handlerBody = deindent`
		${state.usesComponent && `var ${block.component} = this._svelte.component;`}
		${declarations}
		[✂${attribute.expression.start}-${attribute.expression.end}✂];
	`;

	const handler = isCustomEvent ?
		deindent`
			var ${handlerName} = ${generator.alias( 'template' )}.events.${name}.call( ${block.component}, ${state.parentNode}, function ( event ) {
				${handlerBody}
			});
		` :
		deindent`
			function ${handlerName} ( event ) {
				${handlerBody}
			}
		`;

	if ( shouldHoist ) {
		generator.blocks.push({
			render: () => handler
		});
	} else {
		block.builders.create.addBlock( handler );
	}

	if ( isCustomEvent ) {
		block.builders.destroy.addLine( deindent`
			${handlerName}.teardown();
		` );
	} else {
		block.builders.create.addLine( deindent`
			${generator.helper( 'addEventListener' )}( ${state.parentNode}, '${name}', ${handlerName} );
		` );

		block.builders.destroy.addLine( deindent`
			${generator.helper( 'removeEventListener' )}( ${state.parentNode}, '${name}', ${handlerName} );
		` );
	}
}

function visitBinding$1 ( generator, block, state, node, attribute ) {
	var ref = flatten( attribute.value );
	var name = ref.name;
	var parts = ref.parts;
	var ref$1 = block.contextualise( attribute.value );
	var snippet = ref$1.snippet;
	var contexts = ref$1.contexts;
	var dependencies = ref$1.dependencies;

	if ( dependencies.length > 1 ) { throw new Error( 'An unexpected situation arose. Please raise an issue at https://github.com/sveltejs/svelte/issues — thanks!' ); }

	contexts.forEach( context => {
		if ( !~state.allUsedContexts.indexOf( context ) ) { state.allUsedContexts.push( context ); }
	});

	const eventName = getBindingEventName( node, attribute );
	const handler = block.getUniqueName( `${state.parentNode}_${eventName}_handler` );
	const isMultipleSelect = node.name === 'select' && node.attributes.find( attr => attr.name.toLowerCase() === 'multiple' ); // TODO use getStaticAttributeValue
	const type = getStaticAttributeValue( node, 'type' );
	const bindingGroup = attribute.name === 'group' ? getBindingGroup( generator, parts.join( '.' ) ) : null;
	const value = getBindingValue( generator, block, state, node, attribute, isMultipleSelect, bindingGroup, type );

	let setter = getSetter({ block, name, context: '_svelte', attribute, dependencies, value });
	let updateElement = `${state.parentNode}.${attribute.name} = ${snippet};`;
	const lock = block.alias( `${state.parentNode}_updating` );
	let updateCondition = `!${lock}`;

	block.addVariable( lock, 'false' );

	// <select> special case
	if ( node.name === 'select' ) {
		if ( !isMultipleSelect ) {
			setter = `var selectedOption = ${state.parentNode}.querySelector(':checked') || ${state.parentNode}.options[0];\n${setter}`;
		}

		const value = block.getUniqueName( 'value' );
		const i = block.alias( 'i' );
		const option = block.getUniqueName( 'option' );

		const ifStatement = isMultipleSelect ?
			deindent`
				${option}.selected = ~${value}.indexOf( ${option}.__value );` :
			deindent`
				if ( ${option}.__value === ${value} ) {
					${option}.selected = true;
					break;
				}`;

		updateElement = deindent`
			var ${value} = ${snippet};
			for ( var ${i} = 0; ${i} < ${state.parentNode}.options.length; ${i} += 1 ) {
				var ${option} = ${state.parentNode}.options[${i}];

				${ifStatement}
			}
		`;
	}

	// <input type='checkbox|radio' bind:group='selected'> special case
	else if ( attribute.name === 'group' ) {
		if ( type === 'radio' ) {
			setter = deindent`
				if ( !${state.parentNode}.checked ) return;
				${setter}
			`;
		}

		const condition = type === 'checkbox' ?
			`~${snippet}.indexOf( ${state.parentNode}.__value )` :
			`${state.parentNode}.__value === ${snippet}`;

		block.builders.create.addLine(
			`${block.component}._bindingGroups[${bindingGroup}].push( ${state.parentNode} );`
		);

		block.builders.destroy.addBlock(
			`${block.component}._bindingGroups[${bindingGroup}].splice( ${block.component}._bindingGroups[${bindingGroup}].indexOf( ${state.parentNode} ), 1 );`
		);

		updateElement = `${state.parentNode}.checked = ${condition};`;
	}

	else if ( node.name === 'audio' || node.name === 'video' ) {
		generator.hasComplexBindings = true;
		block.builders.create.addBlock( `${block.component}._bindings.push( ${handler} );` );

		if ( attribute.name === 'currentTime' ) {
			const frame = block.getUniqueName( `${state.parentNode}_animationframe` );
			block.addVariable( frame );
			setter = deindent`
				cancelAnimationFrame( ${frame} );
				if ( !${state.parentNode}.paused ) ${frame} = requestAnimationFrame( ${handler} );
				${setter}
			`;

			updateCondition += ` && !isNaN( ${snippet} )`;
		}

		else if ( attribute.name === 'duration' ) {
			updateCondition = null;
		}

		else if ( attribute.name === 'paused' ) {
			// this is necessary to prevent the audio restarting by itself
			const last = block.getUniqueName( `${state.parentNode}_paused_value` );
			block.addVariable( last, 'true' );

			updateCondition = `${last} !== ( ${last} = ${snippet} )`;
			updateElement = `${state.parentNode}[ ${last} ? 'pause' : 'play' ]();`;
		}
	}

	block.builders.create.addBlock( deindent`
		function ${handler} () {
			${lock} = true;
			${setter}
			${lock} = false;
		}

		${generator.helper( 'addEventListener' )}( ${state.parentNode}, '${eventName}', ${handler} );
	` );

	if ( node.name !== 'audio' && node.name !== 'video' ) { node.initialUpdate = updateElement; }

	if ( updateCondition !== null ) {
		// audio/video duration is read-only, it never updates
		block.builders.update.addBlock( deindent`
			if ( ${updateCondition} ) {
				${updateElement}
			}
		` );
	}

	block.builders.destroy.addLine( deindent`
		${generator.helper( 'removeEventListener' )}( ${state.parentNode}, '${eventName}', ${handler} );
	` );

	if ( attribute.name === 'paused' ) {
		block.builders.create.addLine( `${generator.helper( 'addEventListener' )}( ${state.parentNode}, 'play', ${handler} );` );
		block.builders.destroy.addLine( `${generator.helper( 'removeEventListener' )}( ${state.parentNode}, 'play', ${handler} );` );
	}
}

function getBindingEventName ( node, attribute ) {
	if ( node.name === 'input' ) {
		const typeAttribute = node.attributes.find( attr => attr.type === 'Attribute' && attr.name === 'type' );
		const type = typeAttribute ? typeAttribute.value[0].data : 'text'; // TODO in validation, should throw if type attribute is not static

		return type === 'checkbox' || type === 'radio' ? 'change' : 'input';
	}

	if ( node.name === 'textarea' ) { return 'input'; }
	if ( attribute.name === 'currentTime' ) { return 'timeupdate'; }
	if ( attribute.name === 'duration' ) { return 'durationchange'; }
	if ( attribute.name === 'paused' ) { return 'pause'; }

	return 'change';
}

function getBindingValue ( generator, block, state, node, attribute, isMultipleSelect, bindingGroup, type ) {
	// <select multiple bind:value='selected>
	if ( isMultipleSelect ) {
		return `[].map.call( ${state.parentNode}.querySelectorAll(':checked'), function ( option ) { return option.__value; })`;
	}

	// <select bind:value='selected>
	if ( node.name === 'select' ) {
		return 'selectedOption && selectedOption.__value';
	}

	// <input type='checkbox' bind:group='foo'>
	if ( attribute.name === 'group' ) {
		if ( type === 'checkbox' ) {
			return `${generator.helper( 'getBindingGroupValue' )}( ${block.component}._bindingGroups[${bindingGroup}] )`;
		}

		return `${state.parentNode}.__value`;
	}

	// <input type='range|number' bind:value>
	if ( type === 'range' || type === 'number' ) {
		return `+${state.parentNode}.${attribute.name}`;
	}

	// everything else
	return `${state.parentNode}.${attribute.name}`;
}

function getBindingGroup ( generator, keypath ) {
	// TODO handle contextual bindings — `keypath` should include unique ID of
	// each block that provides context
	let index = generator.bindingGroups.indexOf( keypath );
	if ( index === -1 ) {
		index = generator.bindingGroups.length;
		generator.bindingGroups.push( keypath );
	}

	return index;
}

function visitRef$1 ( generator, block, state, node, attribute ) {
	const name = attribute.name;

	block.builders.create.addLine(
		`${block.component}.refs.${name} = ${state.parentNode};`
	);

	block.builders.destroy.addLine( deindent`
		if ( ${block.component}.refs.${name} === ${state.parentNode} ) ${block.component}.refs.${name} = null;
	` );

	generator.usesRefs = true; // so this component.refs object is created
}

function addTransitions ( generator, block, state, node, intro, outro ) {
	const wrapTransition = generator.helper( 'wrapTransition' );

	if ( intro === outro ) {
		const name = block.getUniqueName( `${state.name}_transition` );
		const snippet = intro.expression ? block.contextualise( intro.expression ).snippet : '{}';

		block.addVariable( name );

		const fn = `${generator.alias( 'template' )}.transitions.${intro.name}`;

		block.builders.intro.addBlock( deindent`
			${block.component}._renderHooks.push( function () {
				if ( !${name} ) ${name} = ${wrapTransition}( ${state.name}, ${fn}, ${snippet}, true, null );
				${name}.run( true, function () {
					${block.component}.fire( 'intro.end', { node: ${state.name} });
				});
			});
		` );

		block.builders.outro.addBlock( deindent`
			${name}.run( false, function () {
				${block.component}.fire( 'outro.end', { node: ${state.name} });
				if ( --${block.alias( 'outros' )} === 0 ) ${block.alias( 'outrocallback' )}();
				${name} = null;
			});
		` );
	}

	else {
		const introName = intro && block.getUniqueName( `${state.name}_intro` );
		const outroName = outro && block.getUniqueName( `${state.name}_outro` );

		if ( intro ) {
			block.addVariable( introName );
			const snippet = intro.expression ? block.contextualise( intro.expression ).snippet : '{}';

			const fn = `${generator.alias( 'template' )}.transitions.${intro.name}`; // TODO add built-in transitions?

			if ( outro ) {
				block.builders.intro.addBlock( deindent`
					if ( ${introName} ) ${introName}.abort();
					if ( ${outroName} ) ${outroName}.abort();
				` );
			}

			block.builders.intro.addBlock( deindent`
				${block.component}._renderHooks.push( function () {
					${introName} = ${wrapTransition}( ${state.name}, ${fn}, ${snippet}, true, null );
					${introName}.run( true, function () {
						${block.component}.fire( 'intro.end', { node: ${state.name} });
					});
				});
			` );
		}

		if ( outro ) {
			block.addVariable( outroName );
			const snippet = outro.expression ? block.contextualise( outro.expression ).snippet : '{}';

			const fn = `${generator.alias( 'template' )}.transitions.${outro.name}`;

			// TODO hide elements that have outro'd (unless they belong to a still-outroing
			// group) prior to their removal from the DOM
			block.builders.outro.addBlock( deindent`
				${outroName} = ${wrapTransition}( ${state.name}, ${fn}, ${snippet}, false, null );
				${outroName}.run( false, function () {
					${block.component}.fire( 'outro.end', { node: ${state.name} });
					if ( --${block.alias( 'outros' )} === 0 ) ${block.alias( 'outrocallback' )}();
				});
			` );
		}
	}
}

const meta$1 = {
	':Window': visitWindow
};

const order = {
	Attribute: 1,
	Binding: 2,
	EventHandler: 3,
	Ref: 4
};

const visitors$1 = {
	Attribute: visitAttribute$1,
	EventHandler: visitEventHandler$1,
	Binding: visitBinding$1,
	Ref: visitRef$1
};

function visitElement ( generator, block, state, node ) {
	if ( node.name in meta$1 ) {
		return meta$1[ node.name ]( generator, block, node );
	}

	if ( generator.components.has( node.name ) || node.name === ':Self' ) {
		return visitComponent( generator, block, state, node );
	}

	const childState = node._state;
	const name = childState.parentNode;

	block.builders.create.addLine( `var ${name} = ${getRenderStatement( generator, childState.namespace, node.name )};` );
	block.mount( name, state.parentNode );

	// add CSS encapsulation attribute
	if ( generator.cssId && state.isTopLevel ) {
		block.builders.create.addLine( `${generator.helper( 'setAttribute' )}( ${name}, '${generator.cssId}', '' );` );
	}

	function visitAttributes () {
		let intro;
		let outro;

		node.attributes
			.sort( ( a, b ) => order[ a.type ] - order[ b.type ] )
			.forEach( attribute => {
				if ( attribute.type === 'Transition' ) {
					if ( attribute.intro ) { intro = attribute; }
					if ( attribute.outro ) { outro = attribute; }
					return;
				}

				visitors$1[ attribute.type ]( generator, block, childState, node, attribute );
			});

		if ( intro || outro ) { addTransitions( generator, block, childState, node, intro, outro ); }
	}

	if ( !state.parentNode ) {
		// TODO we eventually need to consider what happens to elements
		// that belong to the same outgroup as an outroing element...
		block.builders.detach.addLine( `${generator.helper( 'detachNode' )}( ${name} );` );
	}

	if ( node.name !== 'select' ) {
		// <select> value attributes are an annoying special case — it must be handled
		// *after* its children have been updated
		visitAttributes();
	}

	// special case – bound <option> without a value attribute
	if ( node.name === 'option' && !node.attributes.find( attribute => attribute.type === 'Attribute' && attribute.name === 'value' ) ) { 	// TODO check it's bound
		const statement = `${name}.__value = ${name}.textContent;`;
		node.initialUpdate = node.lateUpdate = statement;
	}

	if ( childState.allUsedContexts.length || childState.usesComponent ) {
		const initialProps = [];
		const updates = [];

		if ( childState.usesComponent ) {
			initialProps.push( `component: ${block.component}` );
		}

		childState.allUsedContexts.forEach( contextName => {
			if ( contextName === 'state' ) { return; }

			const listName = block.listNames.get( contextName );
			const indexName = block.indexNames.get( contextName );

			initialProps.push( `${listName}: ${listName},\n${indexName}: ${indexName}` );
			updates.push( `${name}._svelte.${listName} = ${listName};\n${name}._svelte.${indexName} = ${indexName};` );
		});

		if ( initialProps.length ) {
			block.builders.create.addBlock( deindent`
				${name}._svelte = {
					${initialProps.join( ',\n' )}
				};
			` );
		}

		if ( updates.length ) {
			block.builders.update.addBlock( updates.join( '\n' ) );
		}
	}

	node.children.forEach( child => {
		visit$1( generator, block, childState, child );
	});

	if ( node.lateUpdate ) {
		block.builders.update.addLine( node.lateUpdate );
	}

	if ( node.name === 'select' ) {
		visitAttributes();
	}

	if ( node.initialUpdate ) {
		block.builders.create.addBlock( node.initialUpdate );
	}
}

function getRenderStatement ( generator, namespace, name ) {
	if ( namespace === 'http://www.w3.org/2000/svg' ) {
		return `${generator.helper( 'createSvgElement' )}( '${name}' )`;
	}

	if ( namespace ) {
		return `document.createElementNS( '${namespace}', '${name}' )`;
	}

	return `${generator.helper( 'createElement' )}( '${name}' )`;
}

function isElseIf ( node ) {
	return node && node.children.length === 1 && node.children[0].type === 'IfBlock';
}

function isElseBranch ( branch ) {
	return branch.block && !branch.condition;
}

function getBranches ( generator, block, state, node ) {
	const branches = [{
		condition: block.contextualise( node.expression ).snippet,
		block: node._block.name,
		hasUpdateMethod: node._block.hasUpdateMethod,
		hasIntroMethod: node._block.hasIntroMethod,
		hasOutroMethod: node._block.hasOutroMethod
	}];

	visitChildren( generator, block, state, node );

	if ( isElseIf( node.else ) ) {
		branches.push.apply(
			branches, getBranches( generator, block, state, node.else.children[0] )
		);
	} else {
		branches.push({
			condition: null,
			block: node.else ? node.else._block.name : null,
			hasUpdateMethod: node.else ? node.else._block.hasUpdateMethod : false,
			hasIntroMethod: node.else ? node.else._block.hasIntroMethod : false,
			hasOutroMethod: node.else ? node.else._block.hasOutroMethod : false
		});

		if ( node.else ) {
			visitChildren( generator, block, state, node.else );
		}
	}

	return branches;
}

function visitChildren ( generator, block, state, node ) {
	node.children.forEach( child => {
		visit$1( generator, node._block, node._state, child );
	});
}

function visitIfBlock ( generator, block, state, node ) {
	const name = generator.getUniqueName( `if_block` );
	const anchor = node.needsAnchor ? block.getUniqueName( `${name}_anchor` ) : ( node.next && node.next._state.name ) || 'null';
	const params = block.params.join( ', ' );

	const branches = getBranches( generator, block, state, node );

	const hasElse = isElseBranch( branches[ branches.length - 1 ] );
	const if_name = hasElse ? '' : `if ( ${name} ) `;

	const dynamic = branches[0].hasUpdateMethod; // can use [0] as proxy for all, since they necessarily have the same value
	const hasOutros = branches[0].hasOutroMethod;

	const vars = { name, anchor, params, if_name, hasElse };

	if ( node.else ) {
		if ( hasOutros ) {
			compoundWithOutros( generator, block, state, node, branches, dynamic, vars );
		} else {
			compound( generator, block, state, node, branches, dynamic, vars );
		}
	} else {
		simple( generator, block, state, node, branches[0], dynamic, vars );
	}

	if ( node.needsAnchor ) {
		block.addElement( anchor, `${generator.helper( 'createComment' )}()`, state.parentNode, true );
	} else if ( node.next ) {
		node.next.usedAsAnchor = true;
	}
}

function simple ( generator, block, state, node, branch, dynamic, ref ) {
	var name = ref.name;
	var anchor = ref.anchor;
	var params = ref.params;
	var if_name = ref.if_name;

	block.builders.create.addBlock( deindent`
		var ${name} = (${branch.condition}) && ${branch.block}( ${params}, ${block.component} );
	` );

	const isTopLevel = !state.parentNode;
	const mountOrIntro = branch.hasIntroMethod ? 'intro' : 'mount';

	if ( isTopLevel ) {
		block.builders.mount.addLine( `if ( ${name} ) ${name}.${mountOrIntro}( ${block.target}, anchor );` );
	} else {
		block.builders.create.addLine( `if ( ${name} ) ${name}.${mountOrIntro}( ${state.parentNode}, null );` );
	}

	const parentNode = state.parentNode || `${anchor}.parentNode`;

	const enter = dynamic ?
		( branch.hasIntroMethod ?
			deindent`
				if ( ${name} ) {
					${name}.update( changed, ${params} );
				} else {
					${name} = ${branch.block}( ${params}, ${block.component} );
				}

				${name}.intro( ${parentNode}, ${anchor} );
			` :
			deindent`
				if ( ${name} ) {
					${name}.update( changed, ${params} );
				} else {
					${name} = ${branch.block}( ${params}, ${block.component} );
					${name}.mount( ${parentNode}, ${anchor} );
				}
			` ) :
		( branch.hasIntroMethod ?
			deindent`
				if ( !${name} ) ${name} = ${branch.block}( ${params}, ${block.component} );
				${name}.intro( ${parentNode}, ${anchor} );
			` :
			deindent`
				if ( !${name} ) {
					${name} = ${branch.block}( ${params}, ${block.component} );
					${name}.mount( ${parentNode}, ${anchor} );
				}
			` );

	// no `update()` here — we don't want to update outroing nodes,
	// as that will typically result in glitching
	const exit = branch.hasOutroMethod ?
		deindent`
			${name}.outro( function () {
				${name}.destroy( true );
				${name} = null;
			});
		` :
		deindent`
			${name}.destroy( true );
			${name} = null;
		`;

	block.builders.update.addBlock( deindent`
		if ( ${branch.condition} ) {
			${enter}
		} else if ( ${name} ) {
			${exit}
		}
	` );

	block.builders.destroy.addLine(
		`${if_name}${name}.destroy( ${state.parentNode ? 'false' : 'detach'} );`
	);
}

function compound ( generator, block, state, node, branches, dynamic, ref ) {
	var name = ref.name;
	var anchor = ref.anchor;
	var params = ref.params;
	var hasElse = ref.hasElse;
	var if_name = ref.if_name;

	const get_block = block.getUniqueName( `get_block` );
	const current_block = block.getUniqueName( `current_block` );
	const current_block_and = hasElse ? '' : `${current_block} && `;

	block.builders.create.addBlock( deindent`
		function ${get_block} ( ${params} ) {
			${branches.map( (ref) => {
				var condition = ref.condition;
				var block = ref.block;

				return `${condition ? `if ( ${condition} ) ` : ''}return ${block};`;
			} ).join( '\n' )}
		}

		var ${current_block} = ${get_block}( ${params} );
		var ${name} = ${current_block_and}${current_block}( ${params}, ${block.component} );
	` );

	const isTopLevel = !state.parentNode;
	const mountOrIntro = branches[0].hasIntroMethod ? 'intro' : 'mount';

	if ( isTopLevel ) {
		block.builders.mount.addLine( `${if_name}${name}.${mountOrIntro}( ${block.target}, anchor );` );
	} else {
		block.builders.create.addLine( `${if_name}${name}.${mountOrIntro}( ${state.parentNode}, null );` );
	}

	const parentNode = state.parentNode || `${anchor}.parentNode`;

	const changeBlock = deindent`
		${if_name}${name}.destroy( true );
		${name} = ${current_block_and}${current_block}( ${params}, ${block.component} );
		${if_name}${name}.${mountOrIntro}( ${parentNode}, ${anchor} );
	`;

	if ( dynamic ) {
		block.builders.update.addBlock( deindent`
			if ( ${current_block} === ( ${current_block} = ${get_block}( ${params} ) ) && ${name} ) {
				${name}.update( changed, ${params} );
			} else {
				${changeBlock}
			}
		` );
	} else {
		block.builders.update.addBlock( deindent`
			if ( ${current_block} !== ( ${current_block} = ${get_block}( ${params} ) ) ) {
				${changeBlock}
			}
		` );
	}

	block.builders.destroy.addLine(
		`${if_name}${name}.destroy( ${state.parentNode ? 'false' : 'detach'} );`
	);
}

// if any of the siblings have outros, we need to keep references to the blocks
// (TODO does this only apply to bidi transitions?)
function compoundWithOutros ( generator, block, state, node, branches, dynamic, ref ) {
	var name = ref.name;
	var anchor = ref.anchor;
	var params = ref.params;
	var hasElse = ref.hasElse;

	const get_block = block.getUniqueName( `get_block` );
	const current_block_index = block.getUniqueName( `current_block_index` );
	const previous_block_index = block.getUniqueName( `previous_block_index` );
	const if_block_creators = block.getUniqueName( `if_block_creators` );
	const if_blocks = block.getUniqueName( `if_blocks` );

	const if_current_block_index = hasElse ? '' : `if ( ~${current_block_index} ) `;

	block.addVariable( current_block_index );
	block.addVariable( name );

	block.builders.create.addBlock( deindent`
		var ${if_block_creators} = [
			${branches.map( branch => branch.block ).join( ',\n' )}
		];

		var ${if_blocks} = [];

		function ${get_block} ( ${params} ) {
			${branches.map( (ref, i ) => {
				var condition = ref.condition;
				var block = ref.block;

				return `${condition ? `if ( ${condition} ) ` : ''}return ${block ? i : -1};`;
			} ).join( '\n' )}
		}
	` );

	if ( hasElse ) {
		block.builders.create.addBlock( deindent`
			${current_block_index} = ${get_block}( ${params} );
			${name} = ${if_blocks}[ ${current_block_index} ] = ${if_block_creators}[ ${current_block_index} ]( ${params}, ${block.component} );
		` );
	} else {
		block.builders.create.addBlock( deindent`
			if ( ~( ${current_block_index} = ${get_block}( ${params} ) ) ) {
				${name} = ${if_blocks}[ ${current_block_index} ] = ${if_block_creators}[ ${current_block_index} ]( ${params}, ${block.component} );
			}
		` );
	}

	const isTopLevel = !state.parentNode;
	const mountOrIntro = branches[0].hasIntroMethod ? 'intro' : 'mount';

	if ( isTopLevel ) {
		block.builders.mount.addLine( `${if_current_block_index}${if_blocks}[ ${current_block_index} ].${mountOrIntro}( ${block.target}, anchor );` );
	} else {
		block.builders.create.addLine( `${if_current_block_index}${if_blocks}[ ${current_block_index} ].${mountOrIntro}( ${state.parentNode}, null );` );
	}

	const parentNode = state.parentNode || `${anchor}.parentNode`;

	const destroyOldBlock = deindent`
		${name}.outro( function () {
			${if_blocks}[ ${previous_block_index} ].destroy( true );
			${if_blocks}[ ${previous_block_index} ] = null;
		});
	`;

	const createNewBlock = deindent`
		${name} = ${if_blocks}[ ${current_block_index} ] = ${if_block_creators}[ ${current_block_index} ]( ${params}, ${block.component} );
		${name}.${mountOrIntro}( ${parentNode}, ${anchor} );
	`;

	const changeBlock = hasElse ?
		deindent`
			${destroyOldBlock}

			${createNewBlock}
		` :
		deindent`
			if ( ${name} ) {
				${destroyOldBlock}
			}

			if ( ~${current_block_index} ) {
				${createNewBlock}
			} else {
				${name} = null;
			}
		`;

	if ( dynamic ) {
		block.builders.update.addBlock( deindent`
			var ${previous_block_index} = ${current_block_index};
			${current_block_index} = ${get_block}( state );
			if ( ${current_block_index} === ${previous_block_index} ) {
				${if_current_block_index}${if_blocks}[ ${current_block_index} ].update( changed, ${params} );
			} else {
				${changeBlock}
			}
		` );
	} else {
		block.builders.update.addBlock( deindent`
			var ${previous_block_index} = ${current_block_index};
			${current_block_index} = ${get_block}( state );
			if ( ${current_block_index} !== ${previous_block_index} ) {
				${changeBlock}
			}
		` );
	}

	block.builders.destroy.addLine(
		`${if_current_block_index}${if_blocks}[ ${current_block_index} ].destroy( ${state.parentNode ? 'false' : 'detach'} );`
	);
}

function visitMustacheTag ( generator, block, state, node ) {
	const name = node._state.name;
	const value = block.getUniqueName( `${name}_value` );

	var ref = block.contextualise( node.expression );
	var snippet = ref.snippet;

	block.addVariable( value );
	block.addElement( name, `${generator.helper( 'createText' )}( ${value} = ${snippet} )`, state.parentNode, true );

	block.builders.update.addBlock( deindent`
		if ( ${value} !== ( ${value} = ${snippet} ) ) {
			${name}.data = ${value};
		}
	` );
}

function visitRawMustacheTag ( generator, block, state, node ) {
	const name = node._state.basename;
	const before = node._state.name;
	const value = block.getUniqueName( `${name}_value` );
	const after = block.getUniqueName( `${name}_after` );

	var ref = block.contextualise( node.expression );
	var snippet = ref.snippet;

	// we would have used comments here, but the `insertAdjacentHTML` api only
	// exists for `Element`s.
	block.addElement( before, `${generator.helper( 'createElement' )}( 'noscript' )`, state.parentNode, true );
	block.addElement( after, `${generator.helper( 'createElement' )}( 'noscript' )`, state.parentNode, true );

	const isToplevel = !state.parentNode;

	block.builders.create.addLine( `var ${value} = ${snippet};` );
	const mountStatement = `${before}.insertAdjacentHTML( 'afterend', ${value} );`;
	const detachStatement = `${generator.helper( 'detachBetween' )}( ${before}, ${after} );`;

	if ( isToplevel ) {
		block.builders.mount.addLine( mountStatement );
	} else {
		block.builders.create.addLine( mountStatement );
	}

	block.builders.update.addBlock( deindent`
		if ( ${value} !== ( ${value} = ${snippet} ) ) {
			${detachStatement}
			${mountStatement}
		}
	` );

	block.builders.detachRaw.addBlock( detachStatement );
}

function visitText ( generator, block, state, node ) {
	if ( !node._state.shouldCreate ) { return; }
	block.addElement( node._state.name, `${generator.helper( 'createText' )}( ${JSON.stringify( node.data )} )`, state.parentNode, node.usedAsAnchor );
}

function visitYieldTag ( generator, block, state ) {
	const parentNode = state.parentNode || block.target;

	( state.parentNode ? block.builders.create : block.builders.mount ).addLine(
		`if ( ${block.component}._yield ) ${block.component}._yield.mount( ${parentNode}, null );`
	);

	block.builders.destroy.addLine(
		`if ( ${block.component}._yield ) ${block.component}._yield.destroy( detach );`
	);
}

var visitors = {
	EachBlock: visitEachBlock,
	Element: visitElement,
	IfBlock: visitIfBlock,
	MustacheTag: visitMustacheTag,
	RawMustacheTag: visitRawMustacheTag,
	Text: visitText,
	YieldTag: visitYieldTag
};

function visit$1 ( generator, block, state, node ) {
	const visitor = visitors[ node.type ];
	visitor( generator, block, state, node );
}

// this file is auto-generated, do not edit it
var shared = {
	"appendNode": "function appendNode ( node, target ) {\n\ttarget.appendChild( node );\n}",
	"insertNode": "function insertNode ( node, target, anchor ) {\n\ttarget.insertBefore( node, anchor );\n}",
	"detachNode": "function detachNode ( node ) {\n\tnode.parentNode.removeChild( node );\n}",
	"detachBetween": "function detachBetween ( before, after ) {\n\twhile ( before.nextSibling && before.nextSibling !== after ) {\n\t\tbefore.parentNode.removeChild( before.nextSibling );\n\t}\n}",
	"destroyEach": "function destroyEach ( iterations, detach, start ) {\n\tfor ( var i = start; i < iterations.length; i += 1 ) {\n\t\tif ( iterations[i] ) iterations[i].destroy( detach );\n\t}\n}",
	"createElement": "function createElement ( name ) {\n\treturn document.createElement( name );\n}",
	"createSvgElement": "function createSvgElement ( name ) {\n\treturn document.createElementNS( 'http://www.w3.org/2000/svg', name );\n}",
	"createText": "function createText ( data ) {\n\treturn document.createTextNode( data );\n}",
	"createComment": "function createComment () {\n\treturn document.createComment( '' );\n}",
	"addEventListener": "function addEventListener ( node, event, handler ) {\n\tnode.addEventListener( event, handler, false );\n}",
	"removeEventListener": "function removeEventListener ( node, event, handler ) {\n\tnode.removeEventListener( event, handler, false );\n}",
	"setAttribute": "function setAttribute ( node, attribute, value ) {\n\tnode.setAttribute( attribute, value );\n}",
	"setXlinkAttribute": "function setXlinkAttribute ( node, attribute, value ) {\n\tnode.setAttributeNS( 'http://www.w3.org/1999/xlink', attribute, value );\n}",
	"getBindingGroupValue": "function getBindingGroupValue ( group ) {\n\tvar value = [];\n\tfor ( var i = 0; i < group.length; i += 1 ) {\n\t\tif ( group[i].checked ) value.push( group[i].__value );\n\t}\n\treturn value;\n}",
	"differs": "function differs ( a, b ) {\n\treturn ( a !== b ) || ( a && ( typeof a === 'object' ) || ( typeof a === 'function' ) );\n}",
	"dispatchObservers": "function dispatchObservers ( component, group, newState, oldState ) {\n\tfor ( var key in group ) {\n\t\tif ( !( key in newState ) ) continue;\n\n\t\tvar newValue = newState[ key ];\n\t\tvar oldValue = oldState[ key ];\n\n\t\tif ( differs( newValue, oldValue ) ) {\n\t\t\tvar callbacks = group[ key ];\n\t\t\tif ( !callbacks ) continue;\n\n\t\t\tfor ( var i = 0; i < callbacks.length; i += 1 ) {\n\t\t\t\tvar callback = callbacks[i];\n\t\t\t\tif ( callback.__calling ) continue;\n\n\t\t\t\tcallback.__calling = true;\n\t\t\t\tcallback.call( component, newValue, oldValue );\n\t\t\t\tcallback.__calling = false;\n\t\t\t}\n\t\t}\n\t}\n}",
	"get": "function get ( key ) {\n\treturn key ? this._state[ key ] : this._state;\n}",
	"fire": "function fire ( eventName, data ) {\n\tvar handlers = eventName in this._handlers && this._handlers[ eventName ].slice();\n\tif ( !handlers ) return;\n\n\tfor ( var i = 0; i < handlers.length; i += 1 ) {\n\t\thandlers[i].call( this, data );\n\t}\n}",
	"observe": "function observe ( key, callback, options ) {\n\tvar group = ( options && options.defer ) ? this._observers.post : this._observers.pre;\n\n\t( group[ key ] || ( group[ key ] = [] ) ).push( callback );\n\n\tif ( !options || options.init !== false ) {\n\t\tcallback.__calling = true;\n\t\tcallback.call( this, this._state[ key ] );\n\t\tcallback.__calling = false;\n\t}\n\n\treturn {\n\t\tcancel: function () {\n\t\t\tvar index = group[ key ].indexOf( callback );\n\t\t\tif ( ~index ) group[ key ].splice( index, 1 );\n\t\t}\n\t};\n}",
	"observeDev": "function observeDev ( key, callback, options ) {\n\tvar c = ( key = '' + key ).search( /[^\\w]/ );\n\tif ( c > -1 ) {\n\t\tvar message = \"The first argument to component.observe(...) must be the name of a top-level property\";\n\t\tif ( c > 0 ) message += \", i.e. '\" + key.slice( 0, c ) + \"' rather than '\" + key + \"'\";\n\n\t\tthrow new Error( message );\n\t}\n\n\treturn observe.call( this, key, callback, options );\n}",
	"on": "function on ( eventName, handler ) {\n\tif ( eventName === 'teardown' ) return this.on( 'destroy', handler );\n\n\tvar handlers = this._handlers[ eventName ] || ( this._handlers[ eventName ] = [] );\n\thandlers.push( handler );\n\n\treturn {\n\t\tcancel: function () {\n\t\t\tvar index = handlers.indexOf( handler );\n\t\t\tif ( ~index ) handlers.splice( index, 1 );\n\t\t}\n\t};\n}",
	"onDev": "function onDev ( eventName, handler ) {\n\tif ( eventName === 'teardown' ) {\n\t\tconsole.warn( \"Use component.on('destroy', ...) instead of component.on('teardown', ...) which has been deprecated and will be unsupported in Svelte 2\" );\n\t\treturn this.on( 'destroy', handler );\n\t}\n\n\treturn on.call( this, eventName, handler );\n}",
	"set": "function set ( newState ) {\n\tthis._set( assign( {}, newState ) );\n\tthis._root._flush();\n}",
	"_flush": "function _flush () {\n\tif ( !this._renderHooks ) return;\n\n\twhile ( this._renderHooks.length ) {\n\t\tthis._renderHooks.pop()();\n\t}\n}",
	"proto": "{\n\tget: get,\n\tfire: fire,\n\tobserve: observe,\n\ton: on,\n\tset: set,\n\t_flush: _flush\n}",
	"protoDev": "{\n\tget: get,\n\tfire: fire,\n\tobserve: observeDev,\n\ton: onDev,\n\tset: set,\n\t_flush: _flush\n}",
	"linear": "function linear ( t ) {\n\treturn t;\n}",
	"generateKeyframes": "function generateKeyframes ( a, b, delta, duration, ease, fn, node, style ) {\n\tvar id = '__svelte' + ~~( Math.random() * 1e9 ); // TODO make this more robust\n\tvar keyframes = '@keyframes ' + id + '{\\n';\n\n\tfor ( var p = 0; p <= 1; p += 16.666 / duration ) {\n\t\tvar t = a + delta * ease( p );\n\t\tkeyframes += ( p * 100 ) + '%{' + fn( t ) + '}\\n';\n\t}\n\n\tkeyframes += '100% {' + fn( b ) + '}\\n}';\n\tstyle.textContent += keyframes;\n\n\tdocument.head.appendChild( style );\n\n\tnode.style.animation = node.style.animation.split( ',' )\n\t\t.filter( function ( anim ) {\n\t\t\t// when introing, discard old animations if there are any\n\t\t\treturn anim && ( delta < 0 || !/__svelte/.test( anim ) );\n\t\t})\n\t\t.concat( id + ' ' + duration + 'ms linear 1 forwards' )\n\t\t.join( ', ' );\n}",
	"wrapTransition": "function wrapTransition ( node, fn, params, intro, outgroup ) {\n\tvar obj = fn( node, params );\n\tvar duration = obj.duration || 300;\n\tvar ease = obj.easing || linear;\n\n\t// TODO share <style> tag between all transitions?\n\tif ( obj.css ) {\n\t\tvar style = document.createElement( 'style' );\n\t}\n\n\tif ( intro && obj.tick ) obj.tick( 0 );\n\n\treturn {\n\t\tt: intro ? 0 : 1,\n\t\trunning: false,\n\t\tprogram: null,\n\t\tpending: null,\n\t\trun: function ( intro, callback ) {\n\t\t\tvar program = {\n\t\t\t\tstart: window.performance.now() + ( obj.delay || 0 ),\n\t\t\t\tintro: intro,\n\t\t\t\tcallback: callback\n\t\t\t};\n\n\t\t\tif ( obj.delay ) {\n\t\t\t\tthis.pending = program;\n\t\t\t} else {\n\t\t\t\tthis.start( program );\n\t\t\t}\n\n\t\t\tif ( !this.running ) {\n\t\t\t\tthis.running = true;\n\t\t\t\ttransitionManager.add( this );\n\t\t\t}\n\t\t},\n\t\tstart: function ( program ) {\n\t\t\tprogram.a = this.t;\n\t\t\tprogram.b = program.intro ? 1 : 0;\n\t\t\tprogram.delta = program.b - program.a;\n\t\t\tprogram.duration = duration * Math.abs( program.b - program.a );\n\t\t\tprogram.end = program.start + program.duration;\n\n\t\t\tif ( obj.css ) {\n\t\t\t\tgenerateKeyframes( program.a, program.b, program.delta, program.duration, ease, obj.css, node, style );\n\t\t\t}\n\n\t\t\tthis.program = program;\n\t\t\tthis.pending = null;\n\t\t},\n\t\tupdate: function ( now ) {\n\t\t\tvar program = this.program;\n\t\t\tif ( !program ) return;\n\n\t\t\tvar p = now - program.start;\n\t\t\tthis.t = program.a + program.delta * ease( p / program.duration );\n\t\t\tif ( obj.tick ) obj.tick( this.t );\n\t\t},\n\t\tdone: function () {\n\t\t\tthis.t = this.program.b;\n\t\t\tif ( obj.tick ) obj.tick( this.t );\n\t\t\tif ( obj.css ) document.head.removeChild( style );\n\t\t\tthis.program.callback();\n\t\t\tthis.program = null;\n\t\t\tthis.running = !!this.pending;\n\t\t},\n\t\tabort: function () {\n\t\t\tif ( obj.tick ) obj.tick( 1 );\n\t\t\tif ( obj.css ) document.head.removeChild( style );\n\t\t\tthis.program = this.pending = null;\n\t\t\tthis.running = false;\n\t\t}\n\t};\n}",
	"transitionManager": "{\n\trunning: false,\n\ttransitions: [],\n\n\tadd: function ( transition ) {\n\t\ttransitionManager.transitions.push( transition );\n\n\t\tif ( !this.running ) {\n\t\t\tthis.running = true;\n\t\t\tthis.next();\n\t\t}\n\t},\n\n\tnext: function () {\n\t\ttransitionManager.running = false;\n\n\t\tvar now = window.performance.now();\n\t\tvar i = transitionManager.transitions.length;\n\n\t\twhile ( i-- ) {\n\t\t\tvar transition = transitionManager.transitions[i];\n\n\t\t\tif ( transition.program && now >= transition.program.end ) {\n\t\t\t\ttransition.done();\n\t\t\t}\n\n\t\t\tif ( transition.pending && now >= transition.pending.start ) {\n\t\t\t\ttransition.start( transition.pending );\n\t\t\t}\n\n\t\t\tif ( transition.running ) {\n\t\t\t\ttransition.update( now );\n\t\t\t\ttransitionManager.running = true;\n\t\t\t} else if ( !transition.pending ) {\n\t\t\t\ttransitionManager.transitions.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\tif ( transitionManager.running ) {\n\t\t\trequestAnimationFrame( transitionManager.next );\n\t\t}\n\t}\n}",
	"noop": "function noop () {}",
	"assign": "function assign ( target ) {\n\tfor ( var i = 1; i < arguments.length; i += 1 ) {\n\t\tvar source = arguments[i];\n\t\tfor ( var k in source ) target[k] = source[k];\n\t}\n\n\treturn target;\n}"
};

var globalWhitelist = new Set( [ 'Array', 'Boolean', 'console', 'Date', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Infinity', 'Intl', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'RegExp', 'Set', 'String', 'undefined' ] );

const reservedNames = new Set( [ 'arguments', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield' ] );

// prevent e.g. `{{#each states as state}}` breaking
reservedNames.add( 'state' );

const keys = {
	ObjectExpression: 'properties',
	Program: 'body'
};

const offsets = {
	ObjectExpression: [ 1, -1 ],
	Program: [ 0, 0 ]
};

function removeNode ( code, parent, node ) {
	const key = keys[ parent.type ];
	const offset = offsets[ parent.type ];
	if ( !key || !offset ) { throw new Error( `not implemented: ${parent.type}` ); }

	const list = parent[ key ];
	const i = list.indexOf( node );
	if ( i === -1 ) { throw new Error( 'node not in list' ); }

	let a;
	let b;

	if ( list.length === 1 ) {
		// remove everything, leave {}
		a = parent.start + offset[0];
		b = parent.end + offset[1];
	} else if ( i === 0 ) {
		// remove everything before second node, including comments
		a = parent.start + offset[0];
		while ( /\s/.test( code.original[a] ) ) { a += 1; }

		b = list[i].end;
		while ( /[\s,]/.test( code.original[b] ) ) { b += 1; }
	} else {
		// remove the end of the previous node to the end of this one
		a = list[ i - 1 ].end;
		b = node.end;
	}

	code.remove( a, b );
	list.splice( i, 1 );
	return;
}

function removeObjectKey ( code, node, key ) {
	if ( node.type !== 'ObjectExpression' ) { return; }

	let i = node.properties.length;
	while ( i-- ) {
		const property = node.properties[i];
		if ( property.key.type === 'Identifier' && property.key.name === key ) {
			removeNode( code, node, property );
		}
	}
}

function getGlobals ( imports, ref ) {
	var globals = ref.globals;
	var onerror = ref.onerror;
	var onwarn = ref.onwarn;

	const globalFn = getGlobalFn( globals );

	return imports.map( x => {
		let name = globalFn( x.source.value );

		if ( !name ) {
			if ( x.name.startsWith( '__import' ) ) {
				const error = new Error( `Could not determine name for imported module '${x.source.value}' – use options.globals` );
				if ( onerror ) {
					onerror( error );
				} else {
					throw error;
				}
			}

			else {
				const warning = {
					message: `No name was supplied for imported module '${x.source.value}'. Guessing '${x.name}', but you should use options.globals`
				};

				if ( onwarn ) {
					onwarn( warning );
				} else {
					console.warn( warning ); // eslint-disable-line no-console
				}
			}

			name = x.name;
		}

		return name;
	});
}

function getGlobalFn ( globals ) {
	if ( typeof globals === 'function' ) { return globals; }
	if ( typeof globals === 'object' ) {
		return id => globals[ id ];
	}

	return () => undefined;
}

function getIntro ( format, options, imports ) {
	if ( format === 'es' ) { return ''; }
	if ( format === 'amd' ) { return getAmdIntro( options, imports ); }
	if ( format === 'cjs' ) { return getCjsIntro( options, imports ); }
	if ( format === 'iife' ) { return getIifeIntro( options, imports ); }
	if ( format === 'umd' ) { return getUmdIntro( options, imports ); }
	if ( format === 'eval' ) { return getEvalIntro( options, imports ); }

	throw new Error( `Not implemented: ${format}` );
}

function getAmdIntro ( options, imports ) {
	const sourceString = imports.length ?
		`[ ${imports.map( declaration => `'${removeExtension( declaration.source.value )}'` ).join( ', ' )} ], ` :
		'';

	const id = options.amd && options.amd.id;

	return `define(${id ? ` '${id}', ` : ''}${sourceString}function (${paramString( imports )}) { 'use strict';\n\n`;
}

function getCjsIntro ( options, imports ) {
	const requireBlock = imports
		.map( declaration => `var ${declaration.name} = require( '${declaration.source.value}' );` )
		.join( '\n\n' );

	if ( requireBlock ) {
		return `'use strict';\n\n${requireBlock}\n\n`;
	}

	return `'use strict';\n\n`;
}

function getIifeIntro ( options, imports ) {
	if ( !options.name ) {
		throw new Error( `Missing required 'name' option for IIFE export` );
	}

	return `var ${options.name} = (function (${paramString( imports )}) { 'use strict';\n\n`;
}

function getUmdIntro ( options, imports ) {
	if ( !options.name ) {
		throw new Error( `Missing required 'name' option for UMD export` );
	}

	const amdId = options.amd && options.amd.id ? `'${options.amd.id}', ` : '';

	const amdDeps = imports.length ? `[${imports.map( declaration => `'${removeExtension( declaration.source.value )}'` ).join( ', ')}], ` : '';
	const cjsDeps = imports.map( declaration => `require('${declaration.source.value}')` ).join( ', ' );
	const globalDeps = getGlobals( imports, options );

	return deindent`
		(function ( global, factory ) {
			typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(${cjsDeps}) :
			typeof define === 'function' && define.amd ? define(${amdId}${amdDeps}factory) :
			(global.${options.name} = factory(${globalDeps}));
		}(this, (function (${paramString( imports )}) { 'use strict';` + '\n\n';
}

function getEvalIntro ( options, imports ) {
	return `(function (${paramString( imports )}) { 'use strict';\n\n`;
}

function paramString ( imports ) {
	return imports.length ? ` ${imports.map( dep => dep.name ).join( ', ' )} ` : '';
}

function removeExtension ( file ) {
	const index = file.lastIndexOf( '.' );
	return ~index ? file.slice( 0, index ) : file;
}

function getOutro ( format, name, options, imports ) {
	if ( format === 'es' ) {
		return `export default ${name};`;
	}

	if ( format === 'amd' ) {
		return `return ${name};\n\n});`;
	}

	if ( format === 'cjs' ) {
		return `module.exports = ${name};`;
	}

	if ( format === 'iife' ) {
		const globals = getGlobals( imports, options );
		return `return ${name};\n\n}(${globals.join( ', ' )}));`;
	}

	if ( format === 'eval' ) {
		const globals = getGlobals( imports, options );
		return `return ${name};\n\n}(${globals.join( ', ' )}));`;
	}

	if ( format === 'umd' ) {
		return `return ${name};\n\n})));`;
	}

	throw new Error( `Not implemented: ${format}` );
}

const commentsPattern = /\/\*[\s\S]*?\*\//g;

function processCss ( parsed, code ) {
	const css = parsed.css.content.styles;
	const offset = parsed.css.content.start;

	const attr = `[svelte-${parsed.hash}]`;

	const keyframes = new Map();

	function walkKeyframes ( node ) {
		if ( node.type === 'Atrule' && node.name.toLowerCase() === 'keyframes' ) {
			node.expression.children.forEach( expression => {
				if ( expression.type === 'Identifier' ) {
					const newName = `svelte-${parsed.hash}-${expression.name}`;
					code.overwrite( expression.start, expression.end, newName );
					keyframes.set( expression.name, newName );
				}
			});
		} else if ( node.children ) {
			node.children.forEach( walkKeyframes );
		} else if ( node.block ) {
			walkKeyframes( node.block );
		}
	}

	parsed.css.children.forEach( walkKeyframes );

	function transform ( rule ) {
		rule.selector.children.forEach( selector => {
			const start = selector.start - offset;
			const end = selector.end - offset;

			const selectorString = css.slice( start, end );

			const firstToken = selector.children[0];

			let transformed;

			if ( firstToken.type === 'TypeSelector' ) {
				const insert = firstToken.end - offset;
				const head = css.slice( start, insert );
				const tail = css.slice( insert, end );

				transformed = `${head}${attr}${tail}, ${attr} ${selectorString}`;
			} else {
				transformed = `${attr}${selectorString}, ${attr} ${selectorString}`;
			}

			code.overwrite( start + offset, end + offset, transformed );
		});

		rule.block.children.forEach( block => {
			if ( block.type === 'Declaration' ) {
				const property = block.property.toLowerCase();
				if ( property === 'animation' || property === 'animation-name' ) {
					block.value.children.forEach( block => {
						if ( block.type === 'Identifier' ) {
							const name = block.name;
							if ( keyframes.has( name ) ) {
								code.overwrite( block.start, block.end, keyframes.get( name ) );
							}
						}
					});
				}
			}
		});
	}

	function walk ( node ) {
		if ( node.type === 'Rule' ) {
			transform( node );
		} else if ( node.type === 'Atrule' && node.name.toLowerCase() === 'keyframes' ) {
			// these have already been processed
		} else if ( node.children ) {
			node.children.forEach( walk );
		} else if ( node.block ) {
			walk( node.block );
		}
	}

	parsed.css.children.forEach( walk );

	// remove comments. TODO would be nice if this was exposed in css-tree
	let match;
	while ( match = commentsPattern.exec( css ) ) {
		const start = match.index + offset;
		const end = start + match[0].length;

		code.remove( start, end );
	}

	return code.slice( parsed.css.content.start, parsed.css.content.end );
}

const test = typeof global !== 'undefined' && global.__svelte_test;

class Generator {
	constructor ( parsed, source, name, options ) {
		this.parsed = parsed;
		this.source = source;
		this.name = name;
		this.options = options;

		this.imports = [];
		this.helpers = new Set();
		this.components = new Set();
		this.events = new Set();
		this.transitions = new Set();
		this.importedComponents = new Map();

		this.bindingGroups = [];

		// track which properties are needed, so we can provide useful info
		// in dev mode
		this.expectedProperties = new Set();

		this.code = new MagicString$1( source );
		this.css = parsed.css ? processCss( parsed, this.code ) : null;
		this.cssId = parsed.css ? `svelte-${parsed.hash}` : '';
		this.usesRefs = false;

		// allow compiler to deconflict user's `import { get } from 'whatever'` and
		// Svelte's builtin `import { get, ... } from 'svelte/shared.js'`;
		this.importedNames = new Set();
		this.aliases = new Map();
		this._usedNames = new Set( [ name ] );
	}

	addSourcemapLocations ( node ) {
		walk$2( node, {
			enter: node => {
				this.code.addSourcemapLocation( node.start );
				this.code.addSourcemapLocation( node.end );
			}
		});
	}

	alias ( name ) {
		if ( !this.aliases.has( name ) ) {
			this.aliases.set( name, this.getUniqueName( name ) );
		}

		return this.aliases.get( name );
	}

	contextualise ( block, expression, context, isEventHandler ) {
		this.addSourcemapLocations( expression );

		const usedContexts = [];

		var ref = this;
		var code = ref.code;
		var helpers = ref.helpers;
		var contexts = block.contexts;
		var indexes = block.indexes;

		let scope = annotateWithScopes( expression ); // TODO this already happens in findDependencies
		let lexicalDepth = 0;

		const self = this;

		walk$2( expression, {
			enter ( node, parent, key ) {
				if ( /^Function/.test( node.type ) ) { lexicalDepth += 1; }

				if ( node._scope ) {
					scope = node._scope;
					return;
				}

				if ( node.type === 'ThisExpression' ) {
					if ( lexicalDepth === 0 && context ) { code.overwrite( node.start, node.end, context, true ); }
				}

				else if ( isReference( node, parent ) ) {
					var ref = flatten( node );
					var name = ref.name;
					if ( scope.has( name ) ) { return; }

					if ( parent && parent.type === 'CallExpression' && node === parent.callee && helpers.has( name ) ) {
						code.prependRight( node.start, `${self.alias( 'template' )}.helpers.` );
					}

					else if ( name === 'event' && isEventHandler ) {
						// noop
					}

					else if ( contexts.has( name ) ) {
						const contextName = contexts.get( name );
						if ( contextName !== name ) {
							// this is true for 'reserved' names like `state` and `component`
							code.overwrite( node.start, node.start + name.length, contextName, true );
						}

						if ( !~usedContexts.indexOf( name ) ) { usedContexts.push( name ); }
					}

					else if ( indexes.has( name ) ) {
						const context = indexes.get( name );
						if ( !~usedContexts.indexOf( context ) ) { usedContexts.push( context ); }
					}

					else {
						// handle shorthand properties
						if ( parent && parent.type === 'Property' && parent.shorthand ) {
							if ( key === 'key' ) {
								code.appendLeft( node.start, `${name}: ` );
								return;
							}
						}

						if ( globalWhitelist.has( name ) ) {
							code.prependRight( node.start, `( '${name}' in state ? state.` );
							code.appendLeft( node.object ? node.object.end : node.end, ` : ${name} )` );
						} else {
							code.prependRight( node.start, `state.` );
						}

						if ( !~usedContexts.indexOf( 'state' ) ) { usedContexts.push( 'state' ); }
					}

					this.skip();
				}
			},

			leave ( node ) {
				if ( /^Function/.test( node.type ) ) { lexicalDepth -= 1; }
				if ( node._scope ) { scope = scope.parent; }
			}
		});

		return {
			dependencies: expression._dependencies, // TODO probably a better way to do this
			contexts: usedContexts,
			snippet: `[✂${expression.start}-${expression.end}✂]`
		};
	}

	findDependencies ( contextDependencies, indexes, expression ) {
		if ( expression._dependencies ) { return expression._dependencies; }

		let scope = annotateWithScopes( expression );
		const dependencies = [];

		const generator = this; // can't use arrow functions, because of this.skip()

		walk$2( expression, {
			enter ( node, parent ) {
				if ( node._scope ) {
					scope = node._scope;
					return;
				}

				if ( isReference( node, parent ) ) {
					var ref = flatten( node );
					var name = ref.name;
					if ( scope.has( name ) || generator.helpers.has( name ) ) { return; }

					if ( contextDependencies.has( name ) ) {
						dependencies.push.apply( dependencies, contextDependencies.get( name ) );
					} else if ( !indexes.has( name ) ) {
						dependencies.push( name );
					}

					this.skip();
				}
			},

			leave ( node ) {
				if ( node._scope ) { scope = scope.parent; }
			}
		});

		dependencies.forEach( name => {
			if ( !globalWhitelist.has( name ) ) {
				this.expectedProperties.add( name );
			}
		});

		return ( expression._dependencies = dependencies );
	}

	generate ( result, options, ref ) {
		var name = ref.name;
		var format = ref.format;

		if ( this.imports.length ) {
			const statements = [];

			this.imports.forEach( ( declaration, i ) => {
				if ( format === 'es' ) {
					statements.push( this.source.slice( declaration.start, declaration.end ) );
					return;
				}

				const defaultImport = declaration.specifiers.find( x => x.type === 'ImportDefaultSpecifier' || x.type === 'ImportSpecifier' && x.imported.name === 'default' );
				const namespaceImport = declaration.specifiers.find( x => x.type === 'ImportNamespaceSpecifier' );
				const namedImports = declaration.specifiers.filter( x => x.type === 'ImportSpecifier' && x.imported.name !== 'default' );

				const name = ( defaultImport || namespaceImport ) ? ( defaultImport || namespaceImport ).local.name : `__import${i}`;
				declaration.name = name; // hacky but makes life a bit easier later

				namedImports.forEach( specifier => {
					statements.push( `var ${specifier.local.name} = ${name}.${specifier.imported.name}` );
				});

				if ( defaultImport ) {
					statements.push( `${name} = ( ${name} && ${name}.__esModule ) ? ${name}['default'] : ${name};` );
				}
			});

			result = `${statements.join( '\n' )}\n\n${result}`;
		}

		const pattern = /\[✂(\d+)-(\d+)$/;

		const parts = result.split( '✂]' );
		const finalChunk = parts.pop();

		const compiled = new Bundle({ separator: '' });

		function addString ( str ) {
			compiled.addSource({
				content: new MagicString$1( str )
			});
		}

		const intro = getIntro( format, options, this.imports );
		if ( intro ) { addString( intro ); }

		var filename = options.filename;

		// special case — the source file doesn't actually get used anywhere. we need
		// to add an empty file to populate map.sources and map.sourcesContent
		if ( !parts.length ) {
			compiled.addSource({
				filename,
				content: new MagicString$1( this.source ).remove( 0, this.source.length )
			});
		}

		parts.forEach( str => {
			const chunk = str.replace( pattern, '' );
			if ( chunk ) { addString( chunk ); }

			const match = pattern.exec( str );

			const snippet = this.code.snip( +match[1], +match[2] );

			compiled.addSource({
				filename,
				content: snippet
			});
		});

		addString( finalChunk );
		addString( '\n\n' + getOutro( format, name, options, this.imports ) );

		return {
			code: compiled.toString(),
			map: compiled.generateMap({ includeContent: true, file: options.outputFilename }),
			css: this.css
		};
	}

	getUniqueName ( name ) {
		if ( test ) { name = `${name}$`; }
		let alias = name;
		for ( let i = 1; reservedNames.has( alias ) || this.importedNames.has( alias ) || this._usedNames.has( alias ); alias = `${name}_${i++}` ){  }
		this._usedNames.add( alias );
		return alias;
	}

	getUniqueNameMaker ( params ) {
		const localUsedNames = new Set( params );
		return name => {
			if ( test ) { name = `${name}$`; }
			let alias = name;
			for ( let i = 1; reservedNames.has( alias ) || this.importedNames.has( alias ) || this._usedNames.has( alias ) || localUsedNames.has( alias ); alias = `${name}_${i++}` ){  }
			localUsedNames.add( alias );
			return alias;
		};
	}

	parseJs ( ssr ) {
		var ref = this;
		var source = ref.source;
		var ref$1 = this.parsed;
		var js = ref$1.js;

		const imports = this.imports;
		const computations = [];
		const templateProperties = {};

		let namespace = null;
		let hasJs = !!js;

		if ( js ) {
			this.addSourcemapLocations( js.content );
			const body = js.content.body.slice(); // slice, because we're going to be mutating the original

			// imports need to be hoisted out of the IIFE
			for ( let i = 0; i < body.length; i += 1 ) {
				const node = body[i];
				if ( node.type === 'ImportDeclaration' ) {
					removeNode( this.code, js.content, node );
					imports.push( node );

					node.specifiers.forEach( specifier => {
						this.importedNames.add( specifier.local.name );
					});
				}
			}

			const defaultExport = body.find( node => node.type === 'ExportDefaultDeclaration' );

			if ( defaultExport ) {
				defaultExport.declaration.properties.forEach( prop => {
					templateProperties[ prop.key.name ] = prop;
				});
			}

			[ 'helpers', 'events', 'components', 'transitions' ].forEach( key => {
				if ( templateProperties[ key ] ) {
					templateProperties[ key ].value.properties.forEach( prop => {
						this[ key ].add( prop.key.name );
					});
				}
			});

			if ( templateProperties.computed ) {
				const dependencies = new Map();

				templateProperties.computed.value.properties.forEach( prop => {
					const key = prop.key.name;
					const value = prop.value;

					const deps = value.params.map( param => param.type === 'AssignmentPattern' ? param.left.name : param.name );
					dependencies.set( key, deps );
				});

				const visited = new Set();

				function visit ( key ) {
					if ( !dependencies.has( key ) ) { return; } // not a computation

					if ( visited.has( key ) ) { return; }
					visited.add( key );

					const deps = dependencies.get( key );
					deps.forEach( visit );

					computations.push({ key, deps });
				}

				templateProperties.computed.value.properties.forEach( prop => visit( prop.key.name ) );
			}

			if ( templateProperties.namespace ) {
				const ns = templateProperties.namespace.value.value;
				namespace = namespaces[ ns ] || ns;

				removeObjectKey( this.code, defaultExport.declaration, 'namespace' );
			}

			if ( templateProperties.components ) {
				let hasNonImportedComponent = false;
				templateProperties.components.value.properties.forEach( property => {
					const key = property.key.name;
					const value = source.slice( property.value.start, property.value.end );
					if ( this.importedNames.has( value ) ) {
						this.importedComponents.set( key, value );
					} else {
						hasNonImportedComponent = true;
					}
				});
				if ( hasNonImportedComponent ) {
					// remove the specific components that were imported, as we'll refer to them directly
					Array.from( this.importedComponents.keys() ).forEach( key => {
						removeObjectKey( this.code, templateProperties.components.value, key );
					});
				} else {
					// remove the entire components portion of the export
					removeObjectKey( this.code, defaultExport.declaration, 'components' );
				}
			}

			// Remove these after version 2
			if ( templateProperties.onrender ) {
				var ref$2 = templateProperties.onrender;
				var key = ref$2.key;
				this.code.overwrite( key.start, key.end, 'oncreate', true );
				templateProperties.oncreate = templateProperties.onrender;
			}

			if ( templateProperties.onteardown ) {
				var ref$3 = templateProperties.onteardown;
				var key = ref$3.key;
				this.code.overwrite( key.start, key.end, 'ondestroy', true );
				templateProperties.ondestroy = templateProperties.onteardown;
			}

			// in an SSR context, we don't need to include events, methods, oncreate or ondestroy
			if ( ssr ) {
				if ( templateProperties.oncreate ) { removeNode( this.code, defaultExport.declaration, templateProperties.oncreate ); }
				if ( templateProperties.ondestroy ) { removeNode( this.code, defaultExport.declaration, templateProperties.ondestroy ); }
				if ( templateProperties.methods ) { removeNode( this.code, defaultExport.declaration, templateProperties.methods ); }
				if ( templateProperties.events ) { removeNode( this.code, defaultExport.declaration, templateProperties.events ); }
			}

			// now that we've analysed the default export, we can determine whether or not we need to keep it
			let hasDefaultExport = !!defaultExport;
			if ( defaultExport && defaultExport.declaration.properties.length === 0 ) {
				hasDefaultExport = false;
				removeNode( this.code, js.content, defaultExport );
			}

			// if we do need to keep it, then we need to generate a return statement
			if ( hasDefaultExport ) {
				const finalNode = body[ body.length - 1 ];
				if ( defaultExport === finalNode ) {
					// export is last property, we can just return it
					this.code.overwrite( defaultExport.start, defaultExport.declaration.start, `return ` );
				} else {
					var ref$4 = annotateWithScopes( js );
					var declarations = ref$4.declarations;
					let template = 'template';
					for ( let i = 1; declarations.has( template ); template = `template_${i++}` ){  }

					this.code.overwrite( defaultExport.start, defaultExport.declaration.start, `var ${template} = ` );

					let i = defaultExport.start;
					while ( /\s/.test( source[ i - 1 ] ) ) { i--; }

					const indentation = source.slice( i, defaultExport.start );
					this.code.appendLeft( finalNode.end, `\n\n${indentation}return ${template};` );
				}
			}

			// user code gets wrapped in an IIFE
			if ( js.content.body.length ) {
				const prefix = hasDefaultExport ? `var ${this.alias( 'template' )} = (function () {` : `(function () {`;
				this.code.prependRight( js.content.start, prefix ).appendLeft( js.content.end, '}());' );
			}

			// if there's no need to include user code, remove it altogether
			else {
				this.code.remove( js.content.start, js.content.end );
				hasJs = false;
			}
		}

		return {
			computations,
			hasJs,
			namespace,
			templateProperties
		};
	}
}

class Block$2 {
	constructor ( options ) {
		this.generator = options.generator;
		this.name = options.name;
		this.expression = options.expression;
		this.context = options.context;

		// for keyed each blocks
		this.key = options.key;
		this.first = null;

		this.contexts = options.contexts;
		this.indexes = options.indexes;
		this.contextDependencies = options.contextDependencies;
		this.dependencies = new Set();

		this.params = options.params;
		this.indexNames = options.indexNames;
		this.listNames = options.listNames;

		this.listName = options.listName;

		this.builders = {
			create: new CodeBuilder(),
			mount: new CodeBuilder(),
			update: new CodeBuilder(),
			intro: new CodeBuilder(),
			outro: new CodeBuilder(),
			detach: new CodeBuilder(),
			detachRaw: new CodeBuilder(),
			destroy: new CodeBuilder()
		};

		this.hasIntroMethod = false; // a block could have an intro method but not intro transitions, e.g. if a sibling block has intros
		this.hasOutroMethod = false;
		this.outros = 0;

		this.aliases = new Map();
		this.variables = new Map();
		this.getUniqueName = this.generator.getUniqueNameMaker( options.params );

		// unique names
		this.component = this.getUniqueName( 'component' );
		this.target = this.getUniqueName( 'target' );

		this.hasUpdateMethod = false; // determined later
	}

	addDependencies ( dependencies ) {
		dependencies.forEach( dependency => {
			this.dependencies.add( dependency );
		});
	}

	addElement ( name, renderStatement, parentNode, needsIdentifier ) {
		if ( needsIdentifier === void 0 ) needsIdentifier = false;

		const isToplevel = !parentNode;
		if ( needsIdentifier || isToplevel ) {
			this.builders.create.addLine(
				`var ${name} = ${renderStatement};`
			);

			this.mount( name, parentNode );
		} else {
			this.builders.create.addLine( `${this.generator.helper( 'appendNode' )}( ${renderStatement}, ${parentNode} );` );
		}

		if ( isToplevel ) {
			this.builders.detach.addLine( `${this.generator.helper( 'detachNode' )}( ${name} );` );
		}
	}

	addVariable ( name, init ) {
		if ( this.variables.has( name ) && this.variables.get( name ) !== init ) {
			throw new Error( `Variable '${name}' already initialised with a different value` );
		}

		this.variables.set( name, init );
	}

	alias ( name ) {
		if ( !this.aliases.has( name ) ) {
			this.aliases.set( name, this.getUniqueName( name ) );
		}

		return this.aliases.get( name );
	}

	child ( options ) {
		return new Block$2( Object.assign( {}, this, options, { parent: this } ) );
	}

	contextualise ( expression, context, isEventHandler ) {
		return this.generator.contextualise( this, expression, context, isEventHandler );
	}

	findDependencies ( expression ) {
		return this.generator.findDependencies( this.contextDependencies, this.indexes, expression );
	}

	mount ( name, parentNode ) {
		if ( parentNode ) {
			this.builders.create.addLine( `${this.generator.helper( 'appendNode' )}( ${name}, ${parentNode} );` );
		} else {
			this.builders.mount.addLine( `${this.generator.helper( 'insertNode' )}( ${name}, ${this.target}, anchor );` );
		}
	}

	render () {
		let introing;
		const hasIntros = !this.builders.intro.isEmpty();
		if ( hasIntros ) {
			introing = this.getUniqueName( 'introing' );
			this.addVariable( introing );
		}

		let outroing;
		const hasOutros = !this.builders.outro.isEmpty();
		if ( hasOutros ) {
			outroing = this.getUniqueName( 'outroing' );
			this.addVariable( outroing );
		}

		if ( this.variables.size ) {
			const variables = Array.from( this.variables.keys() )
				.map( key => {
					const init = this.variables.get( key );
					return init !== undefined ? `${key} = ${init}` : key;
				})
				.join( ', ' );

			this.builders.create.addBlockAtStart( `var ${variables};` );
		}

		if ( this.autofocus ) {
			this.builders.create.addLine( `${this.autofocus}.focus();` );
		}

		// minor hack – we need to ensure that any {{{triples}}} are detached
		// first, so we append normal detach statements to detachRaw
		this.builders.detachRaw.addBlock( this.builders.detach );

		if ( !this.builders.detachRaw.isEmpty() ) {
			this.builders.destroy.addBlock( deindent`
				if ( detach ) {
					${this.builders.detachRaw}
				}
			` );
		}

		const properties = new CodeBuilder();

		let localKey;
		if ( this.key ) {
			localKey = this.getUniqueName( 'key' );
			properties.addBlock( `key: ${localKey},` );
		}

		if ( this.first ) {
			properties.addBlock( `first: ${this.first},` );
		}

		if ( this.builders.mount.isEmpty() ) {
			properties.addBlock( `mount: ${this.generator.helper( 'noop' )},` );
		} else {
			properties.addBlock( deindent`
				mount: function ( ${this.target}, anchor ) {
					${this.builders.mount}
				},
			` );
		}

		if ( this.hasUpdateMethod ) {
			if ( this.builders.update.isEmpty() ) {
				properties.addBlock( `update: ${this.generator.helper( 'noop' )},` );
			} else {
				properties.addBlock( deindent`
					update: function ( changed, ${this.params.join( ', ' )} ) {
						${this.builders.update}
					},
				` );
			}
		}

		if ( this.hasIntroMethod ) {
			if ( hasIntros ) {
				properties.addBlock( deindent`
					intro: function ( ${this.target}, anchor ) {
						if ( ${introing} ) return;
						${introing} = true;
						${hasOutros && `${outroing} = false;`}

						${this.builders.intro}

						this.mount( ${this.target}, anchor );
					},
				` );
			} else {
				properties.addBlock( deindent`
					intro: function ( ${this.target}, anchor ) {
						this.mount( ${this.target}, anchor );
					},
				` );
			}
		}

		if ( this.hasOutroMethod ) {
			if ( hasOutros ) {
				properties.addBlock( deindent`
					outro: function ( ${this.alias( 'outrocallback' )} ) {
						if ( ${outroing} ) return;
						${outroing} = true;
						${hasIntros && `${introing} = false;`}

						var ${this.alias( 'outros' )} = ${this.outros};

						${this.builders.outro}
					},
				` );
			} else {
				properties.addBlock( deindent`
					outro: function ( outrocallback ) {
						outrocallback();
					},
				` );
			}
		}

		if ( this.builders.destroy.isEmpty() ) {
			properties.addBlock( `destroy: ${this.generator.helper( 'noop' )}` );
		} else {
			properties.addBlock( deindent`
				destroy: function ( detach ) {
					${this.builders.destroy}
				}
			` );
		}

		return deindent`
			function ${this.name} ( ${this.params.join( ', ' )}, ${this.component}${this.key ? `, ${localKey}` : ''} ) {
				${this.builders.create}

				return {
					${properties}
				};
			}
		`;
	}
}

function assign ( target ) {
	for ( var i = 1; i < arguments.length; i += 1 ) {
		var source = arguments[i];
		for ( var k in source ) target[k] = source[k];
	}

	return target;
}

var transitionManager = {
	running: false,
	transitions: [],

	add: function ( transition ) {
		transitionManager.transitions.push( transition );

		if ( !this.running ) {
			this.running = true;
			this.next();
		}
	},

	next: function () {
		transitionManager.running = false;

		var now = window.performance.now();
		var i = transitionManager.transitions.length;

		while ( i-- ) {
			var transition = transitionManager.transitions[i];

			if ( transition.program && now >= transition.program.end ) {
				transition.done();
			}

			if ( transition.pending && now >= transition.pending.start ) {
				transition.start( transition.pending );
			}

			if ( transition.running ) {
				transition.update( now );
				transitionManager.running = true;
			} else if ( !transition.pending ) {
				transitionManager.transitions.splice( i, 1 );
			}
		}

		if ( transitionManager.running ) {
			requestAnimationFrame( transitionManager.next );
		}
	}
};

function isElseIf$1 ( node ) {
	return node && node.children.length === 1 && node.children[0].type === 'IfBlock';
}

function getChildState ( parent, child ) {
	return assign( {}, parent, { name: null, parentNode: null }, child || {} );
}

// Whitespace inside one of these elements will not result in
// a whitespace node being created in any circumstances. (This
// list is almost certainly very incomplete)
const elementsWithoutText = new Set([
	'audio',
	'datalist',
	'dl',
	'ol',
	'optgroup',
	'select',
	'ul',
	'video'
]);

const preprocessors = {
	MustacheTag: ( generator, block, state, node ) => {
		const dependencies = block.findDependencies( node.expression );
		block.addDependencies( dependencies );

		node._state = getChildState( state, {
			name: block.getUniqueName( 'text' )
		});
	},

	RawMustacheTag: ( generator, block, state, node ) => {
		const dependencies = block.findDependencies( node.expression );
		block.addDependencies( dependencies );

		const basename = block.getUniqueName( 'raw' );
		const name = block.getUniqueName( `${basename}_before` );

		node._state = getChildState( state, { basename, name });
	},

	Text: ( generator, block, state, node ) => {
		node._state = getChildState( state );

		if ( !/\S/.test( node.data ) ) {
			if ( state.namespace ) { return; }
			if ( elementsWithoutText.has( state.parentNodeName ) ) { return; }
		}

		node._state.shouldCreate = true;
		node._state.name = block.getUniqueName( `text` );
	},

	IfBlock: ( generator, block, state, node ) => {
		const blocks = [];
		let dynamic = false;
		let hasIntros = false;
		let hasOutros = false;

		function attachBlocks ( node ) {
			const dependencies = block.findDependencies( node.expression );
			block.addDependencies( dependencies );

			node._block = block.child({
				name: generator.getUniqueName( `create_if_block` )
			});

			node._state = getChildState( state );

			blocks.push( node._block );
			preprocessChildren( generator, node._block, node._state, node );

			if ( node._block.dependencies.size > 0 ) {
				dynamic = true;
				block.addDependencies( node._block.dependencies );
			}

			if ( node._block.hasIntroMethod ) { hasIntros = true; }
			if ( node._block.hasOutroMethod ) { hasOutros = true; }

			if ( isElseIf$1( node.else ) ) {
				attachBlocks( node.else.children[0] );
			} else if ( node.else ) {
				node.else._block = block.child({
					name: generator.getUniqueName( `create_if_block` )
				});

				node.else._state = getChildState( state );

				blocks.push( node.else._block );
				preprocessChildren( generator, node.else._block, node.else._state, node.else );

				if ( node.else._block.dependencies.size > 0 ) {
					dynamic = true;
					block.addDependencies( node.else._block.dependencies );
				}
			}
		}

		attachBlocks( node );

		blocks.forEach( block => {
			block.hasUpdateMethod = dynamic;
			block.hasIntroMethod = hasIntros;
			block.hasOutroMethod = hasOutros;
		});

		(ref = generator.blocks).push.apply( ref, blocks );
		var ref;
	},

	EachBlock: ( generator, block, state, node ) => {
		const dependencies = block.findDependencies( node.expression );
		block.addDependencies( dependencies );

		const indexNames = new Map( block.indexNames );
		const indexName = node.index || block.getUniqueName( `${node.context}_index` );
		indexNames.set( node.context, indexName );

		const listNames = new Map( block.listNames );
		const listName = block.getUniqueName( `each_block_value` );
		listNames.set( node.context, listName );

		const context = generator.getUniqueName( node.context );
		const contexts = new Map( block.contexts );
		contexts.set( node.context, context );

		const indexes = new Map( block.indexes );
		if ( node.index ) { indexes.set( indexName, node.context ); }

		const contextDependencies = new Map( block.contextDependencies );
		contextDependencies.set( node.context, dependencies );

		node._block = block.child({
			name: generator.getUniqueName( 'create_each_block' ),
			expression: node.expression,
			context: node.context,
			key: node.key,

			contextDependencies,
			contexts,
			indexes,

			listName,
			indexName,

			indexNames,
			listNames,
			params: block.params.concat( listName, context, indexName )
		});

		node._state = getChildState( state, {
			inEachBlock: true
		});

		generator.blocks.push( node._block );
		preprocessChildren( generator, node._block, node._state, node );
		block.addDependencies( node._block.dependencies );
		node._block.hasUpdateMethod = node._block.dependencies.size > 0;

		if ( node.else ) {
			node.else._block = block.child({
				name: generator.getUniqueName( `${node._block.name}_else` )
			});

			node.else._state = getChildState( state );

			generator.blocks.push( node.else._block );
			preprocessChildren( generator, node.else._block, node.else._state, node.else );
			node.else._block.hasUpdateMethod = node.else._block.dependencies.size > 0;
		}
	},

	Element: ( generator, block, state, node ) => {
		const isComponent = generator.components.has( node.name ) || node.name === ':Self';

		if ( isComponent ) {
			node._state = getChildState( state );
		} else {
			const name = block.getUniqueName( node.name.replace( /[^a-zA-Z0-9_$]/g, '_' ) );

			node._state = getChildState( state, {
				isTopLevel: false,
				name,
				parentNode: name,
				parentNodeName: node.name,
				namespace: node.name === 'svg' ? 'http://www.w3.org/2000/svg' : state.namespace,
				allUsedContexts: []
			});
		}

		node.attributes.forEach( attribute => {
			if ( attribute.type === 'Attribute' && attribute.value !== true ) {
				attribute.value.forEach( chunk => {
					if ( chunk.type !== 'Text' ) {
						const dependencies = block.findDependencies( chunk.expression );
						block.addDependencies( dependencies );
					}
				});
			}

			else if ( attribute.type === 'Binding' ) {
				const dependencies = block.findDependencies( attribute.value );
				block.addDependencies( dependencies );
			}

			else if ( attribute.type === 'Transition' ) {
				if ( attribute.intro ) { generator.hasIntroTransitions = block.hasIntroMethod = true; }
				if ( attribute.outro ) {
					generator.hasOutroTransitions = block.hasOutroMethod = true;
					block.outros += 1;
				}
			}
		});

		if ( node.children.length ) {
			if ( isComponent ) {
				const name = block.getUniqueName( ( node.name === ':Self' ? generator.name : node.name ).toLowerCase() );

				node._block = block.child({
					name: generator.getUniqueName( `create_${name}_yield_fragment` )
				});

				generator.blocks.push( node._block );
				preprocessChildren( generator, node._block, node._state, node );
				block.addDependencies( node._block.dependencies );
				node._block.hasUpdateMethod = node._block.dependencies.size > 0;
			}

			else {
				preprocessChildren( generator, block, node._state, node );
			}
		}
	}
};

function preprocessChildren ( generator, block, state, node, isTopLevel ) {
	// glue text nodes together
	const cleaned = [];
	let lastChild;

	node.children.forEach( child => {
		if ( child.type === 'Comment' ) { return; }

		if ( child.type === 'Text' && lastChild && lastChild.type === 'Text' ) {
			lastChild.data += child.data;
			lastChild.end = child.end;
		} else {
			cleaned.push( child );
		}

		lastChild = child;
	});

	if ( isTopLevel ) {
		// trim leading and trailing whitespace from the top level
		const firstChild = cleaned[0];
		if ( firstChild && firstChild.type === 'Text' ) {
			firstChild.data = trimStart( firstChild.data );
			if ( !firstChild.data ) { cleaned.shift(); }
		}

		const lastChild = cleaned[ cleaned.length - 1 ];
		if ( lastChild && lastChild.type === 'Text' ) {
			lastChild.data = trimEnd( lastChild.data );
			if ( !lastChild.data ) { cleaned.pop(); }
		}
	}

	lastChild = null;

	cleaned.forEach( child => {
		const preprocess = preprocessors[ child.type ];
		if ( preprocess ) { preprocess( generator, block, state, child ); }

		if ( lastChild ) {
			lastChild.next = child;
			lastChild.needsAnchor = !child._state || !child._state.name;
		}

		lastChild = child;
	});

	if ( lastChild ) {
		lastChild.needsAnchor = !state.parentNode;
	}

	node.children = cleaned;
}

function preprocess ( generator, state, node ) {
	const block = new Block$2({
		generator,
		name: generator.alias( 'create_main_fragment' ),
		key: null,

		contexts: new Map(),
		indexes: new Map(),
		contextDependencies: new Map(),

		params: [ 'state' ],
		indexNames: new Map(),
		listNames: new Map(),

		dependencies: new Set()
	});

	generator.blocks.push( block );
	preprocessChildren( generator, block, state, node, true );
	block.hasUpdateMethod = block.dependencies.size > 0;

	return block;
}

class DomGenerator extends Generator {
	constructor ( parsed, source, name, options ) {
		super( parsed, source, name, options );
		this.blocks = [];
		this.uses = new Set();

		this.readonly = new Set();

		// initial values for e.g. window.innerWidth, if there's a <:Window> meta tag
		this.metaBindings = [];
	}

	helper ( name ) {
		if ( this.options.dev && `${name}Dev` in shared ) {
			name = `${name}Dev`;
		}

		this.uses.add( name );

		return this.alias( name );
	}
}

function dom ( parsed, source, options ) {
	const format = options.format || 'es';
	const name = options.name || 'SvelteComponent';

	const generator = new DomGenerator( parsed, source, name, options );

	var ref = generator.parseJs();
	var computations = ref.computations;
	var hasJs = ref.hasJs;
	var templateProperties = ref.templateProperties;
	var namespace = ref.namespace;

	const state = {
		namespace,
		parentNode: null,
		isTopLevel: true
	};

	const block = preprocess( generator, state, parsed.html );

	parsed.html.children.forEach( node => {
		visit$1( generator, block, state, node );
	});

	const builders = {
		main: new CodeBuilder(),
		_set: new CodeBuilder()
	};

	if ( computations.length ) {
		const builder = new CodeBuilder();
		const differs = generator.helper( 'differs' );

		computations.forEach( (ref) => {
			var key = ref.key;
			var deps = ref.deps;

			if ( generator.readonly.has( key ) ) {
				// <:Window> bindings
				throw new Error( `Cannot have a computed value '${key}' that clashes with a read-only property` );
			}

			generator.readonly.add( key );

			const condition = `isInitial || ${deps.map( dep => `( '${dep}' in newState && ${differs}( state.${dep}, oldState.${dep} ) )` ).join( ' || ' )}`;
			const statement = `state.${key} = newState.${key} = ${generator.alias( 'template' )}.computed.${key}( ${deps.map( dep => `state.${dep}` ).join( ', ' )} );`;

			builder.addConditionalLine( condition, statement );
		});

		builders.main.addBlock( deindent`
			function ${generator.alias( 'recompute' )} ( state, newState, oldState, isInitial ) {
				${builder}
			}
		` );
	}

	builders._set.addBlock( deindent`
		${options.dev && deindent`
			if ( typeof newState !== 'object' ) {
				throw new Error( 'Component .set was called without an object of data key-values to update.' );
			}

			${Array.from( generator.readonly ).map( prop =>
				`if ( '${prop}' in newState && !this._updatingReadonlyProperty ) throw new Error( "Cannot set read-only property '${prop}'" );`
			)}
		`}

		var oldState = this._state;
		this._state = ${generator.helper( 'assign' )}( {}, oldState, newState );
		${computations.length && `${generator.alias( 'recompute' )}( this._state, newState, oldState, false )`}
		${generator.helper( 'dispatchObservers' )}( this, this._observers.pre, newState, oldState );
		${block.hasUpdateMethod && `this._fragment.update( newState, this._state );`}
		${generator.helper( 'dispatchObservers' )}( this, this._observers.post, newState, oldState );
		${generator.hasComplexBindings && `while ( this._bindings.length ) this._bindings.pop()();`}
		${( generator.hasComponents || generator.hasIntroTransitions ) && `this._flush();`}
	` );

	if ( hasJs ) {
		builders.main.addBlock( `[✂${parsed.js.content.start}-${parsed.js.content.end}✂]` );
	}

	if ( generator.css && options.css !== false ) {
		builders.main.addBlock( deindent`
			function ${generator.alias( 'add_css' )} () {
				var style = ${generator.helper( 'createElement' )}( 'style' );
				style.id = ${JSON.stringify( generator.cssId + '-style' )};
				style.textContent = ${JSON.stringify( generator.css )};
				${generator.helper( 'appendNode' )}( style, document.head );
			}
		` );
	}

	generator.blocks.forEach( block => {
		builders.main.addBlock( block.render() );
	});

	const sharedPath = options.shared === true ? 'svelte/shared.js' : options.shared;

	const prototypeBase = `${name}.prototype` + ( templateProperties.methods ? `, ${generator.alias( 'template' )}.methods` : '' );
	const proto = sharedPath ? `${generator.helper( 'proto' )} ` : deindent`
		{
			${
				[ 'get', 'fire', 'observe', 'on', 'set', '_flush' ]
					.map( n => `${n}: ${generator.helper( n )}` )
					.join( ',\n' )
			}
		}`;

	// TODO deprecate component.teardown()
	builders.main.addBlock( deindent`
		function ${name} ( options ) {
			options = options || {};
			${options.dev && `if ( !options.target && !options._root ) throw new Error( "'target' is a required option" );`}
			${generator.usesRefs && `this.refs = {};`}
			this._state = ${templateProperties.data ? `${generator.helper( 'assign' )}( ${generator.alias( 'template' )}.data(), options.data )` : `options.data || {}`};
			${generator.metaBindings}
			${computations.length && `${generator.alias( 'recompute' )}( this._state, this._state, {}, true );`}
			${options.dev && Array.from( generator.expectedProperties ).map( prop => `if ( !( '${prop}' in this._state ) ) console.warn( "Component was created without expected data property '${prop}'" );`)}
			${generator.bindingGroups.length && `this._bindingGroups = [ ${Array( generator.bindingGroups.length ).fill( '[]' ).join( ', ' )} ];`}

			this._observers = {
				pre: Object.create( null ),
				post: Object.create( null )
			};

			this._handlers = Object.create( null );

			this._root = options._root || this;
			this._yield = options._yield;

			this._torndown = false;
			${parsed.css && options.css !== false && `if ( !document.getElementById( ${JSON.stringify( generator.cssId + '-style' )} ) ) ${generator.alias( 'add_css' )}();`}
			${( generator.hasComponents || generator.hasIntroTransitions ) && `this._renderHooks = [];`}
			${generator.hasComplexBindings && `this._bindings = [];`}

			this._fragment = ${generator.alias( 'create_main_fragment' )}( this._state, this );
			if ( options.target ) this._fragment.mount( options.target, null );
			${generator.hasComplexBindings && `while ( this._bindings.length ) this._bindings.pop()();`}
			${( generator.hasComponents || generator.hasIntroTransitions ) && `this._flush();`}

			${templateProperties.oncreate && deindent`
				if ( options._root ) {
					options._root._renderHooks.push( ${generator.alias( 'template' )}.oncreate.bind( this ) );
				} else {
					${generator.alias( 'template' )}.oncreate.call( this );
				}
			`}
		}

		${generator.helper( 'assign' )}( ${prototypeBase}, ${proto});

		${name}.prototype._set = function _set ( newState ) {
			${builders._set}
		};

		${name}.prototype.teardown = ${name}.prototype.destroy = function destroy ( detach ) {
			this.fire( 'destroy' );
			${templateProperties.ondestroy && `${generator.alias( 'template' )}.ondestroy.call( this );`}

			this._fragment.destroy( detach !== false );
			this._fragment = null;

			this._state = {};
			this._torndown = true;
		};
	` );

	if ( sharedPath ) {
		if ( format !== 'es' ) {
			throw new Error( `Components with shared helpers must be compiled to ES2015 modules (format: 'es')` );
		}

		const names = Array.from( generator.uses ).sort().map( name => {
			return name !== generator.alias( name ) ? `${name} as ${generator.alias( name )}` : name;
		});

		builders.main.addLineAtStart(
			`import { ${names.join( ', ' )} } from ${JSON.stringify( sharedPath )};`
		);
	} else {
		generator.uses.forEach( key => {
			const str = shared[ key ];
			const code = new MagicString$1( str );
			const expression = parseExpressionAt( str, 0 );

			let scope = annotateWithScopes( expression );

			walk$2( expression, {
				enter ( node, parent ) {
					if ( node._scope ) { scope = node._scope; }

					if ( node.type === 'Identifier' && isReference( node, parent ) && !scope.has( node.name ) ) {
						if ( node.name in shared ) {
							// this helper function depends on another one
							const dependency = node.name;
							generator.uses.add( dependency );

							const alias = generator.alias( dependency );
							if ( alias !== node.name ) { code.overwrite( node.start, node.end, alias ); }
						}
					}
				},

				leave ( node ) {
					if ( node._scope ) { scope = scope.parent; }
				}
			});

			if ( key === 'transitionManager' ) { // special case
				const global = `_svelteTransitionManager`;

				builders.main.addBlock(
					`var ${generator.alias( 'transitionManager' )} = window.${global} || ( window.${global} = ${code});`
				);
			} else {
				const alias = generator.alias( expression.id.name );
				if ( alias !== expression.id.name ) { code.overwrite( expression.id.start, expression.id.end, alias ); }

				builders.main.addBlock( code.toString() );
			}
		});
	}

	return generator.generate( builders.main.toString(), options, { name, format } );
}

class Block$3 {
	constructor ( options ) {
		Object.assign( this, options );
	}

	addBinding ( binding, name ) {
		const conditions = [ `!( '${binding.name}' in state )`].concat( // TODO handle contextual bindings...
			this.conditions.map( c => `(${c})` )
		);

		var ref = flatten( binding.value );
		var keypath = ref.keypath;

		this.generator.bindings.push( deindent`
			if ( ${conditions.join( '&&' )} ) {
				tmp = ${name}.data();
				if ( '${keypath}' in tmp ) {
					state.${binding.name} = tmp.${keypath};
					settled = false;
				}
			}
		` );
	}

	child ( options ) {
		return new Block$3( Object.assign( {}, this, options, { parent: this } ) );
	}

	contextualise ( expression, context, isEventHandler ) {
		return this.generator.contextualise( this, expression, context, isEventHandler );
	}
}

function visitComment () {
	// do nothing
}

function visitEachBlock$1 ( generator, block, node ) {
	var ref = block.contextualise( node.expression );
	var dependencies = ref.dependencies;
	var snippet = ref.snippet;

	const open = `\${ ${snippet}.map( ${ node.index ? `( ${node.context}, ${node.index} )` : node.context} => \``;
	generator.append( open );

	// TODO should this be the generator's job? It's duplicated between
	// here and the equivalent DOM compiler visitor
	const contexts = new Map( block.contexts );
	contexts.set( node.context, node.context );

	const indexes = new Map( block.indexes );
	if ( node.index ) { indexes.set( node.index, node.context ); }

	const contextDependencies = new Map( block.contextDependencies );
	contextDependencies.set( node.context, dependencies );

	const childBlock = block.child({
		contexts,
		indexes,
		contextDependencies
	});

	node.children.forEach( child => {
		visit$2( generator, childBlock, child );
	});

	const close = `\` ).join( '' )}`;
	generator.append( close );
}

function visitComponent$1 ( generator, block, node ) {
	function stringify ( chunk ) {
		if ( chunk.type === 'Text' ) { return chunk.data; }
		if ( chunk.type === 'MustacheTag' ) {
			var ref = block.contextualise( chunk.expression );
			var snippet = ref.snippet;
			return '${__escape( ' + snippet + ')}';
		}
	}

	const attributes = [];
	const bindings = [];

	node.attributes.forEach( attribute => {
		if ( attribute.type === 'Attribute' ) {
			attributes.push( attribute );
		} else if ( attribute.type === 'Binding' ) {
			bindings.push( attribute );
		}
	});

	const props = attributes
		.map( attribute => {
			let value;

			if ( attribute.value === true ) {
				value = `true`;
			} else if ( attribute.value.length === 0 ) {
				value = `''`;
			} else if ( attribute.value.length === 1 ) {
				const chunk = attribute.value[0];
				if ( chunk.type === 'Text' ) {
					value = isNaN( chunk.data ) ? JSON.stringify( chunk.data ) : chunk.data;
				} else {
					var ref = block.contextualise( chunk.expression );
					var snippet = ref.snippet;
					value = snippet;
				}
			} else {
				value = '`' + attribute.value.map( stringify ).join( '' ) + '`';
			}

			return `${attribute.name}: ${value}`;
		})
		.concat( bindings.map( binding => {
			var ref = flatten( binding.value );
			var name = ref.name;
			var keypath = ref.keypath;
			const value = block.contexts.has( name ) ? keypath : `state.${keypath}`;
			return `${binding.name}: ${value}`;
		}))
		.join( ', ' );

	const expression = node.name === ':Self' ? generator.name : generator.importedComponents.get( node.name ) || `${generator.alias( 'template' )}.components.${node.name}`;

	bindings.forEach( binding => {
		block.addBinding( binding, expression );
	});

	let open = `\${${expression}.render({${props}}`;

	if ( node.children.length ) {
		open += `, { yield: () => \``;
	}

	generator.append( open );

	generator.elementDepth += 1;

	node.children.forEach( child => {
		visit$2( generator, block, child );
	});

	generator.elementDepth -= 1;

	const close = node.children.length ? `\` })}` : ')}';
	generator.append( close );
}

function visitWindow$1 () {
	// noop
}

const meta$2 = {
	':Window': visitWindow$1
};

function visitElement$1 ( generator, block, node ) {
	if ( node.name in meta$2 ) {
		return meta$2[ node.name ]( generator, block, node );
	}

	if ( generator.components.has( node.name ) || node.name === ':Self' ) {
		visitComponent$1( generator, block, node );
		return;
	}

	let openingTag = `<${node.name}`;

	node.attributes.forEach( attribute => {
		if ( attribute.type !== 'Attribute' ) { return; }

		let str = ` ${attribute.name}`;

		if ( attribute.value !== true ) {
			str += `="` + attribute.value.map( chunk => {
				if ( chunk.type === 'Text' ) {
					return chunk.data;
				}

				var ref = block.contextualise( chunk.expression );
				var snippet = ref.snippet;
				return '${' + snippet + '}';
			}).join( '' ) + `"`;
		}

		openingTag += str;
	});

	if ( generator.cssId && !generator.elementDepth ) {
		openingTag += ` ${generator.cssId}`;
	}

	openingTag += '>';

	generator.append( openingTag );

	generator.elementDepth += 1;

	node.children.forEach( child => {
		visit$2( generator, block, child );
	});

	generator.elementDepth -= 1;

	if ( !isVoidElementName( node.name ) ) {
		generator.append( `</${node.name}>` );
	}
}

function visitIfBlock$1 ( generator, block, node ) {
	var ref = block.contextualise( node.expression );
	var snippet = ref.snippet;

	generator.append( '${ ' + snippet + ' ? `' );

	const childBlock = block.child({
		conditions: block.conditions.concat( snippet )
	});

	node.children.forEach( child => {
		visit$2( generator, childBlock, child );
	});

	generator.append( '` : `' );

	if ( node.else ) {
		node.else.children.forEach( child => {
			visit$2( generator, childBlock, child );
		});
	}

	generator.append( '` }' );
}

function visitMustacheTag$1 ( generator, block, node ) {
	var ref = block.contextualise( node.expression );
	var snippet = ref.snippet;
	generator.append( '${__escape( ' + snippet + ' )}' );
}

function visitRawMustacheTag$1 ( generator, block, node ) {
	var ref = block.contextualise( node.expression );
	var snippet = ref.snippet;
	generator.append( '${' + snippet + '}' );
}

function visitText$1 ( generator, block, node ) {
	generator.append( node.data.replace( /\${/g, '\\${' ) );
}

function visitYieldTag$1 ( generator ) {
	generator.append( `\${options && options.yield ? options.yield() : ''}` );
}

var visitors$3 = {
	Comment: visitComment,
	EachBlock: visitEachBlock$1,
	Element: visitElement$1,
	IfBlock: visitIfBlock$1,
	MustacheTag: visitMustacheTag$1,
	RawMustacheTag: visitRawMustacheTag$1,
	Text: visitText$1,
	YieldTag: visitYieldTag$1
};

function visit$2 ( generator, fragment, node ) {
	const visitor = visitors$3[ node.type ];
	visitor( generator, fragment, node );
}

class SsrGenerator extends Generator {
	constructor ( parsed, source, name, options ) {
		super( parsed, source, name, options );
		this.bindings = [];
		this.renderCode = '';
	}

	append ( code ) {
		this.renderCode += code;
	}
}

function ssr ( parsed, source, options ) {
	const format = options.format || 'cjs';
	const name = options.name || 'SvelteComponent';

	const generator = new SsrGenerator( parsed, source, name, options );

	var ref = generator.parseJs( true );
	var computations = ref.computations;
	var hasJs = ref.hasJs;
	var templateProperties = ref.templateProperties;

	// create main render() function
	const mainBlock = new Block$3({
		generator,
		contexts: new Map(),
		indexes: new Map(),
		conditions: []
	});

	parsed.html.children.forEach( node => {
		visit$2( generator, mainBlock, node );
	});

	const result = deindent`
		${hasJs && `[✂${parsed.js.content.start}-${parsed.js.content.end}✂]`}

		var ${name} = {};

		${name}.filename = ${JSON.stringify( options.filename )};

		${name}.data = function () {
			return ${templateProperties.data ? `${generator.alias( 'template' )}.data()` : `{}`};
		};

		${name}.render = function ( state, options ) {
			${templateProperties.data ? `state = Object.assign( ${generator.alias( 'template' )}.data(), state || {} );` : `state = state || {};`}

			${computations.map( (ref) =>
				{
					var key = ref.key;
					var deps = ref.deps;

					return `state.${key} = ${generator.alias( 'template' )}.computed.${key}( ${deps.map( dep => `state.${dep}` ).join( ', ' )} );`;
	}
			)}

			${generator.bindings.length && deindent`
				var settled = false;
				var tmp;

				while ( !settled ) {
					settled = true;

					${generator.bindings.join( '\n\n' )}
				}
			`}

			return \`${generator.renderCode}\`;
		};

		${name}.renderCss = function () {
			var components = [];

			${generator.css && deindent`
				components.push({
					filename: ${name}.filename,
					css: ${JSON.stringify( generator.css )},
					map: null // TODO
				});
			`}

			${templateProperties.components && deindent`
				var seen = {};

				function addComponent ( component ) {
					var result = component.renderCss();
					result.components.forEach( x => {
						if ( seen[ x.filename ] ) return;
						seen[ x.filename ] = true;
						components.push( x );
					});
				}

				${
					templateProperties.components.value.properties.map( prop => {
						var ref = prop.key;
						var name = ref.name;
						const expression = generator.importedComponents.get( name ) || `${generator.alias( 'template' )}.components.${name}`;
						return `addComponent( ${expression} );`;
					})
				}
			`}

			return {
				css: components.map( x => x.css ).join( '\\n' ),
				map: null,
				components
			};
		};

		var escaped = {
			'"': '&quot;',
			"'": '&#39;',
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;'
		};

		function __escape ( html ) {
			return String( html ).replace( /["'&<>]/g, match => escaped[ match ] );
		}
	`;

	return generator.generate( result, options, { name, format } );
}

var version$1 = "1.20.2";

function normalizeOptions ( options ) {
	return assign( {
		generate: 'dom',

		// a filename is necessary for sourcemap generation
		filename: 'SvelteComponent.html',

		onwarn: warning => {
			if ( warning.loc ) {
				console.warn( `(${warning.loc.line}:${warning.loc.column}) – ${warning.message}` ); // eslint-disable-line no-console
			} else {
				console.warn( warning.message ); // eslint-disable-line no-console
			}
		},

		onerror: error => {
			throw error;
		}
	}, options );
}

function compile ( source, _options ) {
	const options = normalizeOptions( _options );

	let parsed;

	try {
		parsed = parse( source, options );
	} catch ( err ) {
		options.onerror( err );
		return;
	}

	validate( parsed, source, options );

	const compiler = options.generate === 'ssr'
		? ssr
		: dom;

	return compiler( parsed, source, options );
}

function create ( source, _options ) {
	if ( _options === void 0 ) _options = {};

	_options.format = 'eval';

	const compiled = compile( source, _options );

	if ( !compiled || !compiled.code ) {
		return;
	}

	try {
		return (new Function( 'return ' + compiled.code ))();
	} catch ( err ) {
		if ( _options.onerror ) {
			_options.onerror( err );
			return;
		} else {
			throw err;
		}
	}
}

exports.compile = compile;
exports.create = create;
exports.parse = parse;
exports.validate = validate;
exports.VERSION = version$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=svelte.js.map
